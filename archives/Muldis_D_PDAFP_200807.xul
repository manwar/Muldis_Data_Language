<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="chrome://global/skin/" type="text/css"?>
<?xml-stylesheet href="takahashi.css" type="text/css"?>

<page xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    id="presentation" xmlns:html="http:/www.w3.org/1999/xhtml"
    orient="vertical" onkeypress="Presentation.onKeyPress(event);">

<html:textarea id="builtinCode" style="visibility: collapse">

<![CDATA[
NOTE: THIS
TALK'S IN
THE MIDDLE
OF BEING
REWRITTEN
----
Muldis D -
Portable Databases
At Full Power
(2008 July Edition)
----
Darren Duncan
Muldis Data Systems
----
Victoria, BC, Canada
----
Database Software
Products and Services
(Perl by Default)
----
Miss something?
http://muldis.com
has a copy of this
slideshow and a
list of all urls
----
Questions?
You may ask anywhen
But at the end is best
----
So what's this
talk about?
----
1. Introduce
Muldis D
----
New programming
language for
truly relational
databases
----
Official Muldis D language
spec is on CPAN
(Comprehensive Perl Archive Network),
in the namespace Muldis::D
****
http://search.cpan.org/dist/Muldis-D/
****
Or you can see the spec by
way of http://muldis.com
----
2. Introduce
Muldis Rosetta
----
Reference
Implementation
of Muldis D,
in Perl
----
Also on CPAN, in the
namespace Muldis::Rosetta
****
http://search.cpan.org/dist/Muldis-Rosetta/
****
Or by way of http://muldis.com
----
Note that both the Muldis D
spec and the Muldis Rosetta
implementation are presently
incomplete; the first is
about 90% done, and the
second is about 10% done,
as of this writing
----
Now before anyone asks,
the word "Muldis" means
"Multiverse of Discourse";
search for its singular form
----
The phrase is meaningful
to what my work's about,
and the contraction's
good for branding
----
So moving
right along ...
----
Muldis D is a Turing /
computationally
complete language
with fully integrated
database functionality
----
It can perform any
operation that a
typical general purpose
language is capable of
----
Muldis D is intended to be
a "D" language as defined by
"Databases, Types, and
The Relational Model:
The Third Manifesto" (TTM),
a book by Hugh Darwen
and Christopher J. Date
----
The Third Manifesto is a
formal proposal for a solid
foundation for data and
database management systems
(DBMSs)
----
It is an abstract blueprint
for the design of a truly
relational DBMS and the
language interface
to such a DBMS
----
It consists in essence of a
rigorous set of principles,
stated in the form of a
series of prescriptions
and proscriptions
----
A hypothetical language
that conforms to those,
Darwen and Date call "D"
----
The "D" part of
"Muldis D"
refers to that
----
It's just a
coincidence
my own names
start with "D"
----
The main part of the book,
chapter 4, is also a free
download at their website
****
http://www.thethirdmanifesto.com
----
Muldis D is effectively a
generalization of all the
dialects of SQL out there,
as well as a modernization
of SQL that isn't hobbled by
ill-conceived or out-dated
aspects and features
----
In this case, a dialect of
SQL refers to the specific
combination of what concrete
SQL syntax a specific DBMS
product accepts as input,
and the exact semantics of
executing said
----
Muldis D is intended to
serve as an intermediate
language for translating
any kind of SQL code from
one dialect to another,
while exactly preserving all
of its semantics
----
The "any kind" includes
queries, data manipulation,
schema definitions,
user-defined types,
user-defined routines,
utilities, applications
----
At the same time, either the
source or the destination
language of such translation
doesn't have to be SQL;
it could be some non-SQL
language, either database
specific or general purpose
----
Muldis D is designed with a
high degree of determinism;
traditionally implicit
semantic differences between
various languages / dialects
become explicit decisions
or options in Muldis D
----
For example, the semantics
for when and how a number
loses precision or is
rounded are made explicit;
or when and how the case
or accents or whitespace of
text affects comparisons
----
How Muldis D specifies
behaviour is done in as
neutral and portable a
manner as possible; for
example, all numbers are
radix-agnostic in concept,
regardless of implementation
----
Muldis D is a homoiconic
declarative language; you
write Muldis D code by
writing data which declares
what you want the code to
do; this code-as-data can be
manipulated by Muldis D code
----
The fundamental grammar of
Muldis D is abstract, and
conceptually takes the form
of an abstract syntax tree
(AST); Muldis D can have any
number of concrete grammars
which are equivalent to that
----
This means you can choose
whether you write Muldis D
code as plain text strings
like typical languages, or
as multi-dimensional data
structures of some other
host language, such as Perl
----
The plain text choice makes
more sense if you want to
use Muldis D in a more
isolated manner, and compile
it into apps or libraries
the same as you would with
C or Haskell or Perl code
----
The hosted data choice makes
more sense if you want to
actually write your Muldis D
code in the same language as
your main application, such
as when dynamically
generating database queries
----
The Muldis D spec bundles 2
"Tiny" concrete grammars,
named "PTMD_Tiny" (Tiny
Plain Text Muldis D) and
"HDMD_Perl_Tiny" (Tiny
Perl-Hosted Data Muldis D);
each is a "Muldis D Dialect"
----
It should be possible to
make a complete parser for
either that is composed of
very little code; however,
Muldis D code written in a
Tiny dialect is somewhat
verbose, much like an AST is
----
As examples, here are some
scalar literals in the
PTMD_Tiny dialect:
  Bool:true
  Int:9:42
  Blob:F:A705E
  Text:'サンプル'
  Rat:radix:9:3.14159
  Rat:ratio:9:1/43
----
And here are the same scalar literals in the
HDMD_Perl_Tiny dialect:
  [ 'Bool', 'perl_bool', Bool::True ] # Perl 6 only
  [ 'Bool', 'perl_bool', (1 == 1) ]  # alternative
  [ 'Int', 'perl_int', 42 ]
  [ 'Blob', 'md_blob', 'F', 'A705E' ]
  [ 'Text', 'サンプル' ]
  [ 'Rat', 'perl_rat', 3.14159 ]
  [ 'Rat', 'perl_int_ratio', [ 1, 43 ] ]
Note this grammar has more
lit formats to choose from
----
Future Muldis D dialects
should permit considerably
less verbose Muldis D code,
but their grammars would
either be more complicated,
or they would handle only
a subset of the language
----
The Muldis D code examples
in the rest of this
slideshow will be in either
one of the Tiny dialects or
in a fake terse Muldis D
dialect ("fake" meaning no
grammar exists for it yet)
----
Muldis D is intended to be
used as a toolkit for
building better database
wrappers, persistence tools,
abstraction frameworks,
migration tools, ORMs, etc,
in any gen purpose language
----
Such projects could use it
as the design of their
internal AST for database
meta-data, schemas, queries,
data, rather than
proprietary ones, or as an
interchange format for such
----
Muldis D is also intended to
be used by actual DBMSs, as
the design of their internal
AST that input queries are
parsed into, or as their
public query language as an
alternative to taking SQL
----
Not accustomed to some
basic relational terms?
Here's what refers to what:
  attribute : field/column
  tuple     : row
  relation  : rowset
  relvar    : table
----
Also, a relational database
gets that name "relational"
*because* it is composed of
relation-typed variables
(relvars)
----
Muldis D has very distinct
concepts for the terms
"value" and "variable"
----
A value is conceptually
unique, eternal, immutable,
and isn't fixed in time
or space; it has no address
----
So when one appears to be
testing 2 values for
equality, they are
actually testing whether
2 value appearances are
in fact the same value
----
A variable is fixed in
time and space; it does
have an address; it holds
an appearance of a value;
a variable can be created
and destroyed, and its
value might not be distinct
----
The term "object" isn't
used since it doesn't make
a value/variable distinction
in the general case
----
We use the term "selector"
in places where an OO
language might use the term
"constructor" for a routine;
it doesn't make sense to say
we are "building" a value;
rather we're "selecting" one
----
In the Muldis D type system,
a "data type" is a set of
values; as with individual
values, a data type is
conceptually eternal and
immutable
----
A subtype or supertype
is a type whose values
are a subset or superset,
respectively, of some
other type
----
A union type or intersection
type is a type whose values
are the union or
intersection, respectively,
of multiple other types
----
The 2 special types "Empty"
and "Universal" have exactly
zero values and all possible
values, respectively; they
are the intersection and
union type, respectively,
of all other types
----
When you define a data type,
you are defining a not-empty
set of values, as well as
picking one of those as the
type's "default value",
one of which every not-empty
type must have
----
Muldis D is polymorphic;
if a context requires a
value of some given type,
then a value of any of
that type's subtypes may
be used there
----
Subtyping in Muldis D, as in
any "D" language, takes the
form of "specialization by
constraint", not
"specialization
by extension"
----
So conceptually speaking, a
"circle" is an "ellipse",
but a "coloured circle" is
neither a "circle" nor a
"colour"
----
So then, a type "circle" is
a subtype of "ellipse", and
"coloured circle" is neither
a subtype of "circle" nor of
"colour"
----
Rather, for example, a
"coloured circle" is a
multi-component type which
has components of type
"circle" and "colour", but
composition like this does
not a subtype make
----
Every Muldis D value that
can be in a database is a
member of exactly 1 of 3
special union types:
Scalar, Tuple, and Relation
----
Subtypes of those 3 are
scalar, tuple, and relation
types, respectively; their
values are scalar, tuple,
and relation values; tuples
and relations together
are called nonscalars
----
There are also quasi-
scalar/tuple/relation types,
which are disjoint from the
above, but their values
can't be in databases;
they're used with routine
parameters or lexical vars
----
Remnant types round out the
main categories; they are
any sets of 2+ values that
don't qualify for the other
6 categories
----
Scalar types are
conceptually encapsulated;
they're like OO languages'
concepts of object classes
where all their attributes
are private, and only
accessible indirectly
----
The definition of a scalar
type comprises usually one
or more named "possreps" or
"possible representations"
----
A possrep of a type is like
an OO "role" or "interface"
definition; it looks like a
set of named attributes that
the type could logically be
implemented as, but the real
implementation could differ
----
A possrep is exactly like a
tuple, in fact
----
If a type has multiple
possreps, they can differ in
arbitrarily large ways, but
every one is individually
capable of representing all
of the type's values
----
Any possrep could be used
exclusively by a user when
they work with its type,
without diminishing what
they can do; they can
select any value of the type
and extract any possrep attr
----
A few scalar types are
special and don't have any
possreps: Bool, Int, Blob,
Text; a few others exist too
but those aren't intended
for general purpose use
----
Tuple and relation types
are conceptually
non-encapsulated; they are
the fundamental
heterogeneous and
homogeneous collection
types, respectively
----
A tuple is like a SQL row
but that a tuple's attrs all
have names, those names are
all distinct, and the attrs
are *not* ordered; you only
ref them by name; also, a
tuple may have zero attrs
----
A relation is like a SQL
rowset as a tuple is like a
SQL row, but that a relation
is a set of tuples and never
has duplicate tuples; also,
a relation's tuples are
never ordered
----
Muldis D also has canonical
representations of plain
sets, arrays, and bags,
represented by the special
Set, Array, and Bag types;
these are just relations
with pre-defined attributes
----
Next are a few details about
the system-defined generic
scalar types
----
Boolean types
----
A Bool is a simple boolean,
whose 2 values are FALSE
and TRUE; it is the only
essential general-purpose
scalar data type of a "D"
language, as it is the
result of an identity test
----
Some SQL dialects don't have
a distinct boolean type,
requiring that users
overload a numeric type to
represent truth values
----
Muldis D:
  Bool
SQL:
  BOOLEAN, TINYINT(1), ?
----
Numeric types
----


1234567890123456789012345678901234567890

----
----
----
[FOLLOWING NOT IN ORDER PER SE]
[intro routine kinds]
[params are named]
[intro system-defined scalar types]
  [contrast with multiplicity of SQL types]
[intro user-defined routines, types]
[intro RVAs, TVAs]
[Muldis D is 2VL]
[talk about no pointers when saying relation
  tuples id'd by attr values only not hidden things]
----
[content goes here]
----
Copyright © 2008,
Darren Duncan
----
http://muldis.com
for email, see above
----
This slideshow text is
free documentation for software;
you can redistribute it and/or
modify it under the terms of the
GNU General Public License (GPL) as
published by the Free Software Foundation
(http://www.fsf.org/); either
version 3 of the License,
or (at your option) any later version.
----
END
]]>
</html:textarea>

<deck flex="1" id="deck">

<vbox flex="1" onmousemove="Presentation.onMouseMoveOnCanvas(event);">
  <toolbox id="canvasToolbar">
    <toolbar>
      <toolbarbutton oncommand="Presentation.home()" label="|&lt;&lt;"
        observes="canBack"/>
      <toolbarbutton oncommand="Presentation.back()" label="&lt;"
        observes="canBack"/>
      <toolbarbutton oncommand="Presentation.forward()" label="&gt;"
        observes="canForward"/>
      <toolbarbutton oncommand="Presentation.end()" label="&gt;&gt;|"
        observes="canForward"/>
      <toolbarseparator/>
      <hbox align="center">
        <textbox id="current_page" size="4"
          oninput="if (this.value) Presentation.showPage(parseInt(this.value)-1);"/>
        <description value="/"/>
        <description id="max_page"/>
      </hbox>
      <toolbarseparator/>
      <vbox flex="2">
        <spacer flex="1"/>
        <scrollbar id="scroller"
          align="center" orient="horizontal"
          oncommand="Presentation.showPage(parseInt(event.target.getAttribute('curpos')));"
          onclick="Presentation.showPage(parseInt(event.target.getAttribute('curpos')));"
          onmousedown="Presentation.onScrollerDragStart();"
          onmousemove="Presentation.onScrollerDragMove();"
          onmouseup="Presentation.onScrollerDragDrop();"/>
        <spacer flex="1"/>
      </vbox>
      <toolbarseparator/>
      <spacer flex="1"/>
      <toolbarseparator/>
      <toolbarbutton id="toggleEva" label="Eva"
        type="checkbox"
        autoCheck="false"
        oncommand="Presentation.toggleEvaMode();"/>
      <toolbarseparator/>
      <toolbarbutton label="Edit"
        oncommand="Presentation.toggleEditMode();"/>
      <toolbarbutton oncommand="Presentation.reload();" label="Reload"/>
    </toolbar>
  </toolbox>
  <vbox flex="1" id="canvas"
    onclick="Presentation.onPresentationClick(event);">
    <spacer flex="1"/>
    <hbox flex="1">
      <spacer flex="1"/>
      <vbox id="content"/>
      <spacer flex="1"/>
    </hbox>
    <spacer flex="1"/>
  </vbox>
</vbox>

<vbox flex="1" id="edit">
  <toolbox>
    <toolbar>
      <toolbarbutton label="New Page"
        oncommand="Presentation.addPage()"/>
      <spacer flex="1"/>
      <toolbarseparator/>
      <toolbarbutton label="View"
        oncommand="Presentation.toggleEditMode();"/>
      <toolbarbutton oncommand="Presentation.reload();" label="Reload"/>
    </toolbar>
  </toolbox>
  <textbox id="textField" flex="1" multiline="true"
    oninput="Presentation.onEdit()"/>
  <hbox collapsed="true">
    <iframe id="dataLoader" onload="if (window.Presentation) Presentation.onDataLoad();"/>
  </hbox>
</vbox>

</deck>

<broadcasterset>
  <broadcaster id="canBack"/>
  <broadcaster id="canForward"/>
</broadcasterset>

<commandset>
  <command id="cmd_forward"
    oncommand="if (Presentation.isPresentationMode) Presentation.forward();"/>
  <command id="cmd_back"
    oncommand="if (Presentation.isPresentationMode) Presentation.back();"/>
  <command id="cmd_home"
    oncommand="if (Presentation.isPresentationMode) Presentation.home();"/>
  <command id="cmd_end"
    oncommand="if (Presentation.isPresentationMode) Presentation.end();"/>
</commandset>

<keyset>
  <key keycode="VK_ENTER"    command="cmd_forward"/>
  <key keycode="VK_RETURN"   command="cmd_forward"/>
  <key keycode="VK_PAGE_DOWN"  command="cmd_forward"/>
  <key keycode="VK_RIGHT"    command="cmd_forward"/>
  <key keycode="VK_DOWN"     command="cmd_forward"/>
  <!-- key keycode="VK_BACK_SPACE" command="cmd_back"/-->
  <key keycode="VK_PAGE_UP"  command="cmd_back"/>
    <!-- <key keycode="VK_BACK_UP"  command="cmd_back"/>-->
    <!-- <key keycode="VK_BACK_LEFT"  command="cmd_back"/>-->
  <key keycode="VK_HOME"     command="cmd_home"/>
  <key keycode="VK_END"    command="cmd_end"/>
  <key key="n" modifiers="accel" oncommand="Presentation.addPage();"/>
  <key key="r" modifiers="accel" oncommand="window.location.reload();"/>
  <key key="e" modifiers="accel" oncommand="Presentation.toggleEditMode();"/>
  <key key="a" modifiers="accel" oncommand="Presentation.toggleEvaMode();"/>
</keyset>

<script src="takahashi.js" type="application/x-javascript" />

</page>

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1
   -
   - The contents of this file [except for the slideshow text in the CDATA
   - block, which is independent user data to display by the rest of the file]
   - are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is the Takahashi-Method-based Presentation Tool in XUL.
   -
   - The Initial Developer of the Original Code is SHIMODA Hiroshi.
   - Portions created by the Initial Developer are Copyright (C) 2005
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s): SHIMODA Hiroshi <piro@p.club.ne.jp>
   -
   - ***** END LICENSE BLOCK ***** -->
