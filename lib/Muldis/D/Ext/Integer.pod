=pod

=encoding utf8

=head1 NAME

Muldis::D::Ext::Integer -
Muldis D extension for integer data types and operators

=head1 VERSION

This document is Muldis::D::Ext::Integer version 0.71.0.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document
before you read this one, which provides subservient details.

=head1 DESCRIPTION

Muldis D has a mandatory core set of system-defined (eternally available)
entities, which is referred to as the I<Muldis D core> or the I<core>; they
are the minimal entities that all Muldis D implementations need to provide;
they are mutually self-describing and are used to bootstrap the language;
any entities outside the core, called I<Muldis D extensions>, are
non-mandatory and are defined in terms of the core or each other, but the
reverse isn't true.

This current C<Integer> document describes the system-defined I<Muldis D
Integer Extension>, which consists of integer data types and operators,
essentially all the generic ones that a typical programming language should
have, but for the bare minimum needed for bootstrapping Muldis D, which are
defined in the language core instead.

This current document does not describe the polymorphic operators that all
types, or some types including core types, have defined over them; said
operators are defined once for all types in L<Muldis::D::Core>.

I<This documentation is pending.>

=head1 TYPE SUMMARY

Following are all the data types described in this document, arranged in a
type graph according to their proper sub|supertype relationships (but that
a few of them just reappear from the core set to provide a similar context,
and aren't re-described here):

    sys.std.Core.Type.Universal

        sys.std.Core.Type.Empty

        sys.std.Core.Type.QScalar
            sys.std.Core.Type.Scalar
                sys.std.Core.Type.Int
                    sys.std.Core.Type.NNInt
                        sys.std.Core.Type.PInt

                            # These are all finite integer types.

                            sys.std.Integer.Type.PInt2_36

I<This documentation is pending.>

=head1 SYSTEM-DEFINED INTEGER-CONCERNING DATA TYPES

=head2 sys.std.Integer.Type.PInt2_36

This is an enumeration data type.  C<PInt2_36> is a proper subtype of
C<PInt> where all member values are between 2 and 36.  (The significance of
the number 36 is 10 digits plus 26 letters.)  Its default and minimum value
is 2.  Its maximum value is 36.  The cardinality of this type is 35.

=head1 FUNCTIONS FOR INTEGER MATH

These functions implement commonly used integer numeric operations.

=head2 sys.std.Integer.increment

C<< function sys.std.Integer.increment (Int <-- Int $topic) >>

This function results in its argument incremented by 1.

=head2 sys.std.Integer.decrement

C<< function sys.std.Integer.decrement (Int <-- Int $topic) >>

This function results in its argument decremented by 1.

=head2 sys.std.Integer.abs

C<< function sys.std.Integer.abs (NNInt <-- Int $topic) >>

This function results in the absolute value of its argument.

=head2 sys.std.Integer.sum

C<< function sys.std.Integer.sum (Int <-- bag_of.Int $topic?) >>

This function results in the sum of the N element values of its argument;
it is a reduction operator that recursively takes each pair of input values
and adds (which is both commutative and associative) them together until
just one is left, which is the result.  If C<topic> has zero values, then
C<sum> results in the integer zero, which is the identity value for
addition.

=head2 sys.std.Integer.difference

C<< function sys.std.Integer.difference (Int <-- Int $minuend,
Int $subtrahend) >>

This function results in the difference when its C<subtrahend> argument is
subtracted from its C<minuend> argument.

=head2 sys.std.Integer.abs_difference

C<< function sys.std.Integer.abs_difference (Int <-- Int $topic,
Int $other) >>

This function results in the absolute difference between its 2 arguments.

=head2 sys.std.Integer.product

C<< function sys.std.Integer.product (Int <-- bag_of.Int $topic?) >>

This function results in the product of the N element values of its
argument; it is a reduction operator that recursively takes each pair of
input values and multiplies (which is both commutative and associative)
them together until just one is left, which is the result.  If C<topic>
has zero values, then C<product> results in the integer 1, which is the
identity value for multiplication.

=head2 sys.std.Integer.quotient

C<< function sys.std.Integer.quotient (Int <-- Int $dividend, Int $divisor)
>>

This function results in the quotient when its C<dividend> argument is
divided by its C<divisor> argument using integer division.  This function
will fail if C<divisor> is zero.

=head2 sys.std.Integer.remainder

C<< function sys.std.Integer.remainder (NNInt <-- Int $dividend,
Int $divisor) >>

This function results in the remainder when its C<dividend> argument is
divided by its C<divisor> argument using integer division.  This function
will fail if C<divisor> is zero.

=head2 sys.std.Integer.quotient_and_remainder

C<< function sys.std.Integer.quotient_and_remainder (Tuple <--
Int $dividend, Int $divisor) >>

This function results in a binary tuple whose attribute names are
C<quotient> (an C<Int>) and C<remainder> (a C<NNInt>) and whose respective
attribute values are what C<sys.std.Integer.quotient> and
C<sys.std.Integer.remainder> would result in when given the same arguments.
This function will fail if C<divisor> is zero.

=head2 sys.std.Integer.maybe_quotient

C<< function sys.std.Integer.maybe_quotient (maybe_of.Int <--
Int $dividend, Int $divisor) >>

This function is exactly the same as C<sys.std.Integer.quotient> except
that it results in a C<Maybe> of what is otherwise the result, and that
result has zero elements if C<divisor> is zero.

=head2 sys.std.Integer.maybe_remainder

C<< function sys.std.Integer.maybe_remainder (maybe_of.NNInt <--
Int $dividend, Int $divisor) >>

This function is exactly the same as C<sys.std.Integer.remainder> except
that it results in a C<Maybe> of what is otherwise the result, and that
result has zero elements if C<divisor> is zero.

=head2 sys.std.Integer.maybe_quotient_and_remainder

C<< function sys.std.Integer.maybe_quotient_and_remainder (Relation <--
Int $dividend, Int $divisor) >>

This function results in a binary relation whose attribute names are
C<quotient> (an C<Int>) and C<remainder> (a C<NNInt>).  If C<divisor> is
nonzero then the result has a single tuple whose respective attribute
values are what C<sys.std.Integer.quotient> and
C<sys.std.Integer.remainder> would result in when given the same arguments;
if C<divisor> is zero, then the result has zero tuples.

=head2 sys.std.Integer.range

C<< function sys.std.Integer.range (Int <-- set_of.Int $topic) >>

This function results in the difference between the lowest and highest
element values of its argument.  If C<topic> has zero values, then C<range>
results in the integer zero.

=head2 sys.std.Integer.median

C<< function sys.std.Integer.median (set_of.Int <-- bag_of.Int $topic) >>

This function results in the 1 or 2 median values of the N element values
of its argument; they are returned as a set.  It is equivalent to first
arranging the input values from least to greatest, and then taking the
single middle value, if the count of input values is odd, or taking the 2
middle values, if the count of input values is even (but if the 2 middle
values are the same value, the output has one element).  If C<topic> has
zero values, then the result set is empty.

=head2 sys.std.Integer.mode

C<< function sys.std.Integer.mode (set_of.Int <-- bag_of.Int $topic) >>

This function results in the mode of the N element values of its argument;
it is the set of values that appear the most often as input elements, and
all have the same count of occurrances.  As a trivial case, if all input
elements have the same count of occurrances, then they will all be in the
output.  If C<topic> has zero values, then the result set is empty.

=head2 sys.std.Integer.power

C<< function sys.std.Integer.power (Int <-- Int $radix, NNInt $exponent) >>

This function results in its C<radix> argument taken to the power of its
(non-negative integer) C<exponent> argument.  This function will result in
1 if C<radix> and C<exponent> are both zero (rather than failing), which
seems reasonable given that the C<Integer.power> function strictly has no
numeric continuity (unlike C<Rational.power>) and that this is by far the
most common practice in both pure integer math contexts and computer
languages, including SQL.

=head2 sys.std.Integer.factorial

C<< function sys.std.Integer.factorial (PInt <-- NNInt $topic) >>

This function results in the factorial of its argument (it is defined for
an argument of zero to result in 1, as per the identity value for
multiplication of an empty set).

=head1 FUNCTIONS FOR INTEGER CONVERSION WITH TEXT

These functions convert between C<Int> values and canonically formatted
representations of integers as character strings.

=head2 sys.std.Integer.Int_from_Text

C<< function sys.std.Integer.Int_from_Text (Int <-- Text $text,
PInt2_36 $radix) >>

This selector function results in the C<Int> value that its (not-empty)
C<text> argument maps to when the whole character string is evaluated as a
base-C<radix> integer.  Extending the typical formats of [base-2, base-8,
base-10, base-16], this function supports base-2 through base-36; to get
the latter, the characters 0-9 and A-Z represent values in 0-35.  This
function will fail if C<text> can't be mapped as specified.

=head2 sys.std.Integer.Text_from_Int

C<< function sys.std.Integer.Text_from_Int (Text <-- Int $int,
PInt2_36 $radix) >>

This selector function results in the (not-empty) C<Text> value where its
C<int> argument is formatted as a base-C<radix> integer.

=head1 FUNCTIONS FOR INTEGER CONVERSION WITH BLOB

These functions convert between C<Int> values and canonically formatted
representations of integers as binary strings.  I<Conjecture: These may not
actually be useful, and perhaps only operators that take an argument
specifying a fixed-length field size, with big and little endian versions,
would be appropriate instead.  Or maybe both kinds are necessary.>

=head2 sys.std.Integer.Int_from_Blob_S_VBE

C<< function sys.std.Integer.Int_from_Blob_S_VBE (Int <-- Blob $blob) >>

This selector function results in the C<Int> value that its C<blob>
argument maps to when the whole bit string is treated literally as a
variable-length binary (two's complement) signed integer of 1 or more bits
in length.  The first bit is taken as the sign bit, and any other bits
provide greater precision than the -1 thru 0 range.  The bit string is
assumed to be big-endian, since it may not be possible to use little-endian
in situations where the bit length isn't a multiple of 8.

=head2 sys.std.Integer.Blob_S_VBE_from_Int

C<< function sys.std.Integer.Blob_S_VBE_from_Int (Blob <-- Int $int) >>

This selector function results in the C<Blob> value where its C<int>
argument is formatted as a variable-length binary (two's complement) signed
integer of 1 or more bits in length; the smallest number of bits necessary
to store C<int> is used.

=head2 sys.std.Integer.Int_from_Blob_U_VBE

C<< function sys.std.Integer.Int_from_Blob_U_VBE (NNInt <-- Blob $blob) >>

This function is the same as C<sys.std.Integer.Int_from_Blob_S_VBE> but
that it does unsigned integers.

=head2 sys.std.Integer.Blob_U_VBE_from_Int

C<< function sys.std.Integer.Blob_U_VBE_from_Int (NNInt <-- Blob $blob) >>

This function is the same as C<sys.std.Integer.Blob_S_VBE_from_Int> but
that it does unsigned integers.

=head1 SYSTEM SERVICES FOR RANDOM NUMBER GENERATORS

These system service routines provide ways to get random numbers from the
system.  Where the results are in the range between truly random and
pseudo-random is, for the moment, an implementation detail, but the details
of these functions is subject to become more formalized later.

=head2 sys.std.Integer.fetch_random

C<system_service sys.std.Integer.fetch_random (Int &$target, Int $min,
Int $max, Bool $exclude_min?, Bool $exclude_max?)>

This system service routine will update the variable supplied as its
C<target> argument so that it holds a randomly generated integer value in
the range whose bounds are defined by its C<min> and C<max> arguments.  If
C<exclude_min> or C<exclude_max> are C<Bool:true>, then the randomly
generated value will not be equal to C<min> or C<max>, respectively;
otherwise, the generated value might be equal to C<min> or C<max>.  This
function will fail if C<max> is before C<min>.  Each of the
C<exclude_m[in|ax]> parameters is optional and defaults to C<Bool:false> if
no explicit argument is given to it.

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::SeeAlso> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<perl@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright © 2002-2009, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
