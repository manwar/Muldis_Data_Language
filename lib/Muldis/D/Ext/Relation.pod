=pod

=encoding utf8

=head1 NAME

Muldis::D::Ext::Relation -
Muldis D extension adding more generic relational operators

=head1 VERSION

This document is Muldis::D::Ext::Relation version 0.90.0.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document
before you read this one, which provides subservient details.

=head1 DESCRIPTION

Muldis D has a mandatory core set of system-defined (eternally available)
entities, which is referred to as the I<Muldis D core> or the I<core>; they
are the minimal entities that all Muldis D implementations need to provide;
they are mutually self-describing and are used to bootstrap the language;
any entities outside the core, called I<Muldis D extensions>, are
non-mandatory and are defined in terms of the core or each other, but the
reverse isn't true.

This current C<Relation> document describes the system-defined I<Muldis D
Relation Extension>, which consists of many generic relational operators
(for generic relations), adding to the minimum few defined in the
language core.

This current document does not describe the polymorphic operators that all
types, or some types including core types, have defined over them; said
operators are defined once for all types in L<Muldis::D::Core>.

I<This documentation is pending.>

=head1 SYSTEM-DEFINED GENERIC SINGLE INPUT RELATION FUNCTIONS

These functions are applicable to mainly relation types, but are generic
in that they typically work with any relation types.

=head2 sys.std.Relation.d0c0

C<< function sys.std.Relation.d0c0 (Relation <--) >>

This C<named_value> selector function results in the only zero-attribute,
zero-tuple Relation value, which is known by the special name
C<Relation:d0c0>, aka C<d0c0>.  Note that I<The Third Manifesto> also
refers to this value by the special shorthand name I<TABLE_DUM>.

=head2 sys.std.Relation.d0c1

C<< function sys.std.Relation.d0c1 (Relation <--) >>

This C<named_value> selector function results in the only zero-attribute,
single-tuple Relation value, which is known by the special name
C<Relation:d0c1>, aka C<d0c1>.  Note that I<The Third Manifesto> also
refers to this value by the special shorthand name I<TABLE_DEE>.

=head2 sys.std.Relation.degree

C<< function sys.std.Relation.degree (NNInt <-- Relation $topic) >>

This function results in the degree of its argument (that is, the count of
attributes it has).

=head2 sys.std.Relation.is_nullary

C<< function sys.std.Relation.is_nullary (Bool <-- Relation $topic) >>

This function results in C<Bool:true> iff its argument has a degree of zero
(that is, it has zero attributes), and C<Bool:false> otherwise.  By
definition, the only 2 relation values for which this function would
result in C<Bool:true> are the values C<Relation:d0c[0|1]>.

=head2 sys.std.Relation.is_not_nullary

C<< function sys.std.Relation.is_not_nullary (Bool <-- Relation $topic) >>

This function is exactly the same as C<sys.std.Relation.is_nullary> except
that it results in the opposite boolean value when given the same argument.

=head2 sys.std.Relation.has_attrs

C<< function sys.std.Relation.has_attrs (Bool <-- Relation $topic,
set_of.Name $attr_names) >>

This function results in C<Bool:true> iff, for every one of the attribute
names specified by its C<attr_names> argument, its C<topic> argument has an
attribute with that name; otherwise it results in C<Bool:false>.  As a
trivial case, this function's result is C<Bool:true> if C<attr_names> is
empty.

=head2 sys.std.Relation.attr_names

C<< function sys.std.Relation.attr_names (set_of.Name <--
Relation $topic) >>

This function results in the set of the names of the attributes of its
argument.

=head2 sys.std.Relation.is_empty

C<< function sys.std.Relation.is_empty (Bool <-- Relation $topic) >>

This function results in C<Bool:true> iff its argument has a cardinality of
zero (that is, it has zero tuples), and C<Bool:false> otherwise.  Note
that if you are using a C<Maybe> to represent a sparse data item,
analagously to a SQL nullable context, then testing the C<Maybe> with
C<is_empty> is analagous to testing a SQL nullable with C<is null>.

=head2 sys.std.Relation.is_not_empty

C<< function sys.std.Relation.is_not_empty (Bool <-- Relation $topic) >>

This function is exactly the same as C<sys.std.Relation.is_empty> except
that it results in the opposite boolean value when given the same argument.
And following the analogy with C<is_empty>, C<is_not_empty> is analagous to
SQL's C<is not null>.

=head2 sys.std.Relation.has_key

C<< function sys.std.Relation.has_key (Bool <-- Relation $topic,
set_of.Name $attr_names) >>

This function results in C<Bool:true> iff its C<topic> argument has a
(unique) key over the subset of its attributes whose names are specified by
its C<attr_names> argument; otherwise it results in C<Bool:false>.  This
function will fail if C<topic> does not have all of the attributes named by
C<attr_names>.  As a trivial case, this function's result is C<Bool:true>
if C<topic> is empty.

=head2 sys.std.Relation.empty

C<< function sys.std.Relation.empty (Relation <-- Relation $topic) >>

This function results in the empty relation of the same heading of its
argument, that is having the same degree and attribute names; it has zero
tuples.

=head2 sys.std.Relation.power_set

C<< function sys.std.Relation.power_set (set_of.Relation <--
Relation $topic) >>

This function results in the power set of its argument.  The result is a
C<Set> whose sole attribute is C<Relation>-typed (its type is nominally
the same as that of the argument) and which has a tuple for every
distinct subset of tuples in the argument.  The cardinality of the result
is equal to 2 raised to the power of the cardinality of the argument (which
may easily lead to a very large result, so use this function with care).
Note that the N-adic relational union of the power set of some relation
is that relation; the N-adic intersection of any power set is the empty
relation.

=head2 sys.std.Relation.tclose

C<< function sys.std.Relation.tclose (Relation <-- Relation $topic) >>

This function results in the transitive closure of its argument.  The
argument must be a binary relation whose attributes are both of the same
type, and the result is a relation having the same heading and a body
which is a superset of the argument's tuples.  Assuming that the argument
represents all of the node pairs in a directed graph that have an arc
between them, and so each argument tuple represents an arc, C<tclose>
will determine all of the node pairs in that graph which have a path
between them (a recursive operation), so each tuple of the result
represents a path.  The result is a superset since all arcs are also
complete paths.  The C<tclose> function is intended to support recursive
queries, such as in connection with the "part explosion problem" (the
problem of finding all components, at all levels, of some specified part).

=head2 sys.std.Relation.classification

C<< function sys.std.Relation.classification (Relation <-- Relation $topic,
ValMapFuncRef $func, Name $class_attr_name, Name $group_attr_name) >>

This function conceptually is to C<sys.std.Core.Relation.restriction> what
C<sys.std.Core.Relation.group> is to C<sys.std.Core.Relation.semijoin>.
It classifies the tuples of C<topic> into N groups using the C<value_map>
function named by C<func>, such that any distinct tuples are in a common
group if the function named by C<func> results in the same value when given
either of those tuples as its C<topic>
argument.  This function conceptually is a short-hand for first
extending C<topic> with a new attribute whose name is given in
C<class_attr_name>, whose value per tuple is determined from C<topic> using
C<func>, and then grouping that result relation on all of
its original attributes, with the post-group RVA having the name given in
C<group_attr_name>; the result of C<classification> is a binary relation
whose 2 attributes have the names given in C<class_attr_name> and
C<group_attr_name>.  This function is intended for use when you want to
partition a relation's tuples into an arbitrary number of groups using
arbitrary criteria, in contrast with C<restriction> where you are dividing
into exactly 2 groups (and returning one) using arbitrary criteria.

=head2 sys.std.Relation.reduction

C<< function sys.std.Relation.reduction (Tuple <-- Relation $topic,
ValRedFuncRef $func, Tuple $identity) >>

This function is a generic reduction operator that recursively takes each
pair of tuples in C<topic> and applies an argument-specified tuple
value-resulting C<value_reduction> function (which is both commutative and
associative) to the pair until just one input tuple is left, which is the
result.  The C<value_reduction> function to apply is named in the C<func>
argument, and that function must have 2 parameters named C<v1> and C<v2>,
which take the 2 input tuples for an invocation.  If C<topic> has zero
tuples, then C<reduction> results in the tuple given in C<identity>.
I<Note that C<identity> may be changed to take a function name rather than
a value, for consistency with C<func>.>  This function will fail|warn if
the |declared headings of C<identity> and C<topic> aren't compatible.

=head2 sys.std.Relation.maybe_reduction

C<< function sys.std.Relation.maybe_reduction (maybe_of.Tuple <--
Relation $topic, ValRedFuncRef $func) >>

This function is exactly the same as C<sys.std.Relation.reduction> except
that it does not take an C<identity> argument, and it results in a
C<Maybe> of what is otherwise the result type, and that result has zero
elements if the argument has zero elements.

=head2 sys.std.Relation.map

C<< function sys.std.Relation.map (Relation <-- Relation $topic,
set_of.Name $result_attr_names, ValMapFuncRef $func) >>

This function provides a convenient one-place generalization of per-tuple
transformations that otherwise might require the chaining of up to a
half-dozen other operators like projection, extension, and rename.  This
function results in a relation each of whose tuples is the result of
applying, to each of the tuples of its C<topic> argument, the
C<Tuple>-resulting C<value_map> function named in its C<func>
argument.  There is no restriction
on what attributes the result tuple of C<func> may have (except that all
tuples from C<func> must have compatible headings); this tuple from
C<func> would completely replace the original tuple from C<topic>.  The
result relation has a cardinality that is the same as that of C<topic>,
unless the result of C<func> was redundant tuples, in which case the
result has appropriately fewer tuples.  As a trivial case, if C<func> is
defined to unconditionally result in the same tuple as its own C<topic>
argument, then this function results simply in C<topic>; or, if C<func> is
defined to have a static result, then this function's result will have just
0..1 tuples.  Now, C<map> requires the extra C<result_attr_names>
argument to prevent ambiguity in the general case where C<topic> might have
zero tuples, because in that situation, C<func> would never be invoked,
and the names of the attributes of the result are not known (we don't
generally assume that C<map> can reverse-engineer C<func> to see what
attributes it would have resulted in).  This function will fail if C<topic>
has at least 1 tuple and the result of C<func> does not have matching
attribute names to those named by C<result_attr_names>.

=head1 SYSTEM-DEFINED GENERIC MULTIPLE INPUT RELATION FUNCTIONS

These functions are applicable to mainly relation types, but are generic
in that they typically work with any relation types.

=head2 sys.std.Relation.is_proper_subset

C<< function sys.std.Relation.is_proper_subset (Bool <--
Relation $topic, Relation $other) >>

This function is exactly the same as C<sys.std.Core.Relation.is_subset>
except that it results in C<Bool:false> if its 2 arguments are identical.
Note that this operation is also known as C<⊂>.

=head2 sys.std.Relation.is_not_proper_subset

C<< function sys.std.Relation.is_not_proper_subset (Bool <--
Relation $topic, Relation $other) >>

This function is exactly the same as C<sys.std.Relation.is_proper_subset>
except that it results in the opposite boolean value when given the same
arguments.  Note that this operation is also known as C<⊄>.

=head2 sys.std.Relation.is_proper_superset

C<< function sys.std.Relation.is_proper_superset (Bool <--
Relation $topic, Relation $other) >>

This function is an alias for C<sys.std.Relation.is_proper_subset> except
that it transposes the C<topic> and C<other> arguments.  This function
is exactly the same as C<sys.std.Core.Relation.is_superset> except that it
results in C<Bool:false> if its 2 arguments are identical.  Note that this
operation is also known as C<⊃>.

=head2 sys.std.Relation.is_not_proper_superset

C<< function sys.std.Relation.is_not_proper_superset (Bool <--
Relation $topic, Relation $other) >>

This function is an alias for C<sys.std.Relation.is_not_proper_subset>
except that it transposes the C<topic> and C<other> arguments.  This
function is exactly the same as C<sys.std.Relation.is_proper_superset>
except that it results in the opposite boolean value when given the same
arguments.  Note that this operation is also known as C<⊅>.

=head2 sys.std.Relation.is_disjoint

C<< function sys.std.Relation.is_disjoint (Bool <-- Relation $topic,
Relation $other) >>

This symmetric function results in C<Bool:true> iff the set of tuples
comprising each of its 2 arguments are mutually disjoint, that is, iff the
intersection of the 2 arguments is empty; it results in C<Bool:false>
otherwise.

=head2 sys.std.Relation.is_not_disjoint

C<< function sys.std.Relation.is_not_disjoint (Bool <-- Relation $topic,
Relation $other) >>

This symmetric function is exactly the same as
C<sys.std.Relation.is_disjoint> except that it results in the opposite
boolean value when given the same arguments.

=head2 sys.std.Relation.exclusion

C<< function sys.std.Relation.exclusion (Relation <--
bag_of.Relation $topic) >>

This function results in the relational exclusion/exclusive-or of the N
element values of its argument; it is a reduction operator that recursively
takes each pair of input values and relationally excludes (which is both
commutative and associative) them together until just one is left, which is
the result.  The result relation has the same heading as all of its
inputs, and its body contains every tuple that is in just an odd number
of the input relations.  Matters concerning a C<topic> with zero values
are as per C<sys.std.Core.Relation.union>; this function will fail when
given such, and the per-distinct-heading identity value for relational
exclusion is the same as for relational union.  Note that this operation is
also known as I<symmetric difference> or C<∆>.

=head2 sys.std.Relation.symmetric_diff

C<< function sys.std.Relation.symmetric_diff (Relation <--
bag_of.Relation $topic) >>

This function is an alias for C<sys.std.Relation.exclusion>.

=head2 sys.std.Relation.composition

C<< function sys.std.Relation.composition (Relation <-- Relation $topic,
Relation $other) >>

This symmetric function results in the relational composition of its
2 arguments.  It is conceptually a short-hand for first doing
an ordinary relational join between its 2 arguments, and then performing a
relational projection on all of the attributes that only one of the
arguments has; that is, the result has all of and just the attributes that
were not involved in matching the tuples of the 2 arguments.  This
function will fail|warn any time that C<join> would fail|warn on the same 2
input relations.

=head2 sys.std.Relation.join_with_group

C<< function sys.std.Relation.join_with_group (Relation <--
Relation $primary, Relation $secondary, Name $group_attr) >>

This function is a short-hand for first taking a (natural inner) C<join> of
its C<primary> and C<secondary> arguments, and then taking a C<group> on
all of the attributes that only the C<secondary> argument had, such that
the attribute resulting from the group has the name C<group_attr>.  The
result has 1 tuple for every tuple of C<primary> where at least 1
matching tuple exists in C<secondary>.  This function will fail if
C<group_attr> is the same name as any source attribute that wasn't grouped.
This function is a convenient tool for gathering both parent and child
records from a database using a single query while avoiding duplication of
the parent record values.

=head1 SYSTEM-DEFINED RELATIONAL RANKING AND QUOTA FUNCTIONS

These additional functions are specific to supporting ranking and quotas.

=head2 sys.std.Relation.rank

C<< function sys.std.Relation.rank (Relation <-- Relation $topic,
Name $name, OrdDetFuncRef $ord_func, Bool $is_reverse_order?) >>

This function results in the relational extension of its C<topic> argument
by a single C<NNInt>-typed attribute whose name is provided by the C<name>
argument, where the value of the new attribute for each tuple is the rank
of that tuple as determined by the (total) C<order_determination>
function named in the C<ord_func> argument when the latter function is
curried by the C<is_reverse_order> argument.  The C<order_determination>
function compares tuples, with each invocation of it getting a C<topic>
tuple as each its C<topic> and C<other> arguments.  The new attribute of
C<rank>'s result has a value of zero for its ranked-first tuple, and each
further consecutive ranked tuple has the next larger integer value.  Note
that C<rank> provides the functionality of SQL's "RANK" feature but that
the result of C<rank> is always a total ordering (as per a (total)
C<order_determination> function) and so there is no "dense" / "not dense"
distinction (however a partial ordering can be implemented over it).  See
also the C<sys.std.Array.Array_from_wrap> function, which is the same as
C<sys.std.Relation.rank> but that it wraps the source tuples rather than
just adding an attribute to them.

=head2 sys.std.Relation.rank_by_attr_names

C<< function sys.std.Relation.rank_by_attr_names (Relation <--
Relation $topic, Name $name, array_of.OrderByName $order_by,
Bool $is_reverse_order?) >>

This function is a short-hand for invoking C<rank> with the function
C<sys.std.Tuple.order_by_attr_names> as its C<ord_func> argument after the
latter is curried with this function's C<order_by> argument.

=head2 sys.std.Relation.limit

C<< function sys.std.Relation.limit (Relation <-- Relation $topic,
OrdDetFuncRef $ord_func, NNInt $min_rank,
NNInt $max_rank, Bool $is_reverse_order?) >>

This function results in the relational restriction of its C<topic>
argument as determined by first ranking its tuples as per C<rank>
function (using C<ord_func> and C<is_reverse_order>) and then keeping just
those tuples whose rank is within the inclusive range specified by the
C<min_rank> and C<max_rank> arguments (C<rank>'s extra attribute is not
kept).  The C<limit> function implements a certain kind of quota query
where all the result tuples are consecutive in their ranks.  This
function will fail if C<max_rank> is before C<min_rank>.  It is valid for
C<min_rank> or C<max_rank> to be greater than the maximum rank of the
source tuples; in the first case, the result has zero tuples; in the
second case, the result has all remaining tuples starting at C<min_rank>.
If C<topic> has any tuples and C<min_rank> matches the rank of a source
tuple, then the result will always have at least 1 tuple.  Note that
C<limit> provides the functionality of SQL's "LIMIT/OFFSET" feature in
combination with "ORDER BY" but that the result tuples of C<limit> do not
remain ordered (but see C<sys.std.Array.limit_of_Array_from_wrap> for an
alternative).

=head2 sys.std.Relation.limit_by_attr_names

C<< function sys.std.Relation.limit_by_attr_names (Relation <--
Relation $topic, array_of.OrderByName $order_by, NNInt $min_rank,
NNInt $max_rank, Bool $is_reverse_order?) >>

This function is to C<limit> what C<rank_by_attr_names> is to C<rank>.

=head1 SYSTEM-DEFINED RELATIONAL SUBSTITUTION FUNCTIONS

These additional functions are specific to supporting substitutions.

=head2 sys.std.Relation.substitution

C<< function sys.std.Relation.substitution (Relation <-- Relation $topic,
set_of.Name $attr_names, ValMapFuncRef $func) >>

This function is similar to C<extension> except that it substitutes values
of existing relation attributes rather than adding new attributes.  The
result relation has the same heading as C<topic>.  The result tuple of
the C<value_map> function named in C<func> must have a heading that is a
subset of the
heading of C<topic>; corresponding values resulting from the function named
in C<func> will replace the values of the tuples of C<topic>.  The result
relation has a cardinality that is the same as that of C<topic>, unless
the result of any substitutions was redundant tuples, in which case the
result has appropriately fewer tuples.  As a trivial case, if C<func> is
defined to unconditionally result in either the degree-zero tuple or in the
same tuple as its own C<topic> argument, then this function results
simply in C<topic>; or, if C<func> is defined to have a static result and
it replaces all attributes, then this function's result will have just 0..1
tuples.  Now, strictly speaking, C<substitution> could conceivably be
implemented such that each result from C<func> is allowed to specify
replacement values for different subsets of C<topic> attributes; however,
to improve the function's predictability and ease of implementation over
disparate foundations, C<substitution> requires the extra C<attr_names>
argument so that users can specify a consistent subset that C<func> will
update (possibly to itself).  This function will fail if C<topic> has at
least 1 tuple and the result of C<func> does not have matching attribute
names to those named by C<attr_names>.

=head2 sys.std.Relation.static_subst

C<< function sys.std.Relation.static_subst (Relation <--
Relation $topic, Tuple $attrs) >>

This function is a simpler-syntax alternative to
C<sys.std.Relation.substitution> in the typical scenario where every
tuple of a relation, given in the C<topic> argument, is updated with
identical values for the same attributes; the new attribute values are
given in the C<attrs> argument.

=head2 sys.std.Relation.subst_in_restr

C<< function sys.std.Relation.subst_in_restr (Relation <-- Relation $topic,
ValFiltFuncRef $restr_func, set_of.Name $subst_attr_names,
ValMapFuncRef $subst_func) >>

This function is like C<substitution> except that it only transforms a
subset of the tuples of C<topic> rather than all of them.  It is a
short-hand for first separating the tuples of C<topic> into 2 groups
where those passed by a relational restriction (defined by C<restr_func>)
are then transformed (defined by
C<subst_attr_names> and C<subst_func>), then the result
of the substitution is unioned with the un-transformed group.  See also the
C<subst_in_semijoin> function, which is a simpler-syntax alternative for
C<subst_in_restr> in its typical usage where restrictions are composed
simply of anded or ored tests for attribute value equality.

=head2 sys.std.Relation.static_subst_in_restr

C<< function sys.std.Relation.static_subst_in_restr (Relation <--
Relation $topic, ValFiltFuncRef $restr_func, Tuple $subst) >>

This function is to C<sys.std.Relation.subst_in_restr> what
C<sys.std.Relation.static_subst> is to
C<sys.std.Relation.substitution>.  See also the
C<static_subst_in_semijoin> function.

=head2 sys.std.Relation.subst_in_semijoin

C<< function sys.std.Relation.subst_in_semijoin (Relation <--
Relation $topic, Relation $restr, set_of.Name $subst_attr_names,
ValMapFuncRef $subst_func) >>

This function is like C<subst_in_restr> except that the subset of the
tuples of C<topic> to be transformed is determined by those matched by a
semijoin with C<restr> rather than those that pass a generic relational
restriction.

=head2 sys.std.Relation.static_subst_in_semijoin

C<< function sys.std.Relation.static_subst_in_semijoin (Relation <--
Relation $topic, Relation $restr, Tuple $subst) >>

This function is to C<sys.std.Relation.subst_in_semijoin> what
C<sys.std.Relation.static_subst> is to
C<sys.std.Relation.substitution>.

=head1 SYSTEM-DEFINED RELATIONAL OUTER-JOIN FUNCTIONS

These additional functions are specific to supporting outer-joins.

=head2 sys.std.Relation.outer_join_with_group

C<< function sys.std.Relation.outer_join_with_group (Relation <--
Relation $primary, Relation $secondary, Name $group_attr) >>

This function is the same as C<sys.std.Relation.join_with_group> except
that it results in a half-outer natural join rather than an inner natural
join; every tuple of C<primary> has exactly 1 corresponding tuple in
the result, but where there were no matching C<secondary> tuples, the
result attribute named by C<group_attr> contains zero tuples rather than
1+.

=head2 sys.std.Relation.outer_join_with_maybes

C<< function sys.std.Relation.outer_join_with_maybes (Relation <--
Relation $primary, Relation $secondary) >>

This function results in a plain half-outer natural join of its C<primary>
and C<secondary> arguments where all the result attributes that come from
just C<secondary> are C<Maybe>-typed; for result tuples from matched
source tuples, each C<secondary> attribute value is a C<Single>; for
result tuples from non-matched C<primary> tuples, each C<secondary>
attribute value is C<nothing>.  The C<outer_join_with_maybes> function is
Muldis D's answer to the SQL LEFT OUTER JOIN where SQL NULL is implicitly
used in result rows that were a non-match.

=head2 sys.std.Relation.outer_join_with_defaults

C<< function sys.std.Relation.outer_join_with_defaults (Relation <--
Relation $primary, Relation $secondary, TypeRef $filler) >>

This function is the same as
C<sys.std.Relation.outer_join_with_static_exten> but that the filler
tuple is the default value of the tuple data type whose name is given
in the C<filler> argument.  This function is a short-hand for invoking
C<outer_join_with_static_exten> with the result from invoking
C<sys.std.Core.Universal.default>.

=head2 sys.std.Relation.outer_join_with_static_exten

C<< function sys.std.Relation.outer_join_with_static_exten (Relation <--
Relation $primary, Relation $secondary, Tuple $filler) >>

This function is the same as C<sys.std.Relation.outer_join_with_maybes>
but that C<secondary>-sourced result attributes are not converted to
C<Maybe>; rather, for result tuples from non-matches, the missing values
are provided explicitly from the C<filler> argument, which is a tuple
whose heading matches the projection of C<secondary>'s attributes that
aren't in common with C<primary>, and whose body is the specific values to
use for those missing attribute values.

=head2 sys.std.Relation.outer_join_with_exten

C<< function sys.std.Relation.outer_join_with_exten (Relation <--
Relation $primary, Relation $secondary, ValMapFuncRef $exten_func) >>

This function is the same as
C<sys.std.Relation.outer_join_with_static_exten> but that the result
tuples from non-matches are the result of performing a relational
extension on the un-matched C<primary> tuples such that each said result
tuple is determined by applying the function named in C<exten_func> to
each said C<primary> tuple.

=head1 SYSTEM-DEFINED GENERIC RELVAR UPDATERS

=head2 sys.std.Relation.assign_empty

C<updater sys.std.Relation.assign_empty (Relation &$topic)>

This update operator is a short-hand for first invoking the
C<sys.std.Relation.empty> function with the same argument, and then
assigning the result of that function to C<topic>.  This updater is
analagous to the SQL "TRUNCATE" statement.

=head2 sys.std.Relation.assign_exclusion

C<updater sys.std.Relation.assign_exclusion (Relation &$topic,
Relation $other)>

This update operator is a short-hand for first invoking the
C<sys.std.Relation.exclusion> function such that it has 2 input
relations from C<assign_exclusion>'s 2 arguments, and then assigning the
result of that function to C<topic>.

=head2 sys.std.Relation.assign_substitution

C<updater sys.std.Relation.assign_substitution (Relation &$topic,
set_of.Name $attr_names, ValMapFuncRef $func)>

This update operator is a short-hand for first invoking the
C<sys.std.Core.Relation.substitution> function with the same arguments,
and then assigning the result of that function to C<topic>.  This updater
is analagous to the general case of the unconditional SQL "UPDATE"
statement.

=head2 sys.std.Relation.assign_static_subst

C<updater sys.std.Relation.assign_static_subst (Relation &$topic,
Tuple $attrs)>

This update operator is a short-hand for first invoking the
C<sys.std.Core.Relation.static_subst> function with the same
arguments, and then assigning the result of that function to C<topic>.

=head2 sys.std.Relation.assign_subst_in_restr

C<updater sys.std.Relation.assign_subst_in_restr (Relation &$topic,
ValFiltFuncRef $restr_func, set_of.Name $subst_attr_names,
ValMapFuncRef $subst_func)>

This update operator is a short-hand for first invoking the
C<sys.std.Core.Relation.subst_in_restr> function with the same arguments,
and then assigning the result of that function to C<topic>.  This updater
is analagous to the general case of the conditional SQL "UPDATE" statement.

=head2 sys.std.Relation.assign_static_subst_in_restr

C<updater sys.std.Relation.assign_static_subst_in_restr (Relation &$topic,
ValFiltFuncRef $restr_func, Tuple $subst)>

This update operator is a short-hand for first invoking the
C<sys.std.Core.Relation.static_subst_in_restr> function with the same
arguments, and then assigning the result of that function to C<topic>.

=head2 sys.std.Relation.assign_subst_in_semijoin

C<updater sys.std.Relation.assign_subst_in_semijoin (Relation &$topic,
Relation $restr, set_of.Name $subst_attr_names, ValMapFuncRef $subst_func)>

This update operator is a short-hand for first invoking the
C<sys.std.Core.Relation.subst_in_semijoin> function with the same
arguments, and then assigning the result of that function to C<topic>.
This updater is analagous to the common case of the conditional SQL
"UPDATE" statement where the criteria is simply a set of and-ed and or-ed
value equality tests.

=head2 sys.std.Relation.assign_static_subst_in_semijoin

C<updater sys.std.Relation.assign_static_subst_in_semijoin
(Relation &$topic, Relation $restr, Tuple $subst)>

This update operator is a short-hand for first invoking the
C<sys.std.Core.Relation.static_subst_in_semijoin> function with the same
arguments, and then assigning the result of that function to C<topic>.

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::SeeAlso> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<perl@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright © 2002-2009, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
