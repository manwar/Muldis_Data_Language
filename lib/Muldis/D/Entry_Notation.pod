=pod

=encoding utf8

=head1 NAME

Muldis::D::Entry_Notation -
Muldis D concrete syntax for source code

=head1 VERSION

This document is Muldis::D::Entry_Notation version 0.201.0.-9.

=head1 DESCRIPTION

This document is the human readable authoritative formal specification of
the B<Muldis D Entry Notation> (B<MDEN>) primary component of the B<Muldis D>
language.  The fully-qualified name of this document and the specification
it contains is C<Muldis_D_Entry_Notation 'http://muldis.com' '0.201.0.-9'>.

I<TODO: This file is a rough first cut initially cloned from
Muldis::D::Plain_Text and will need further cleanup and simplification.>

See also L<Muldis::D> to read the B<Muldis D> language meta-specification.

The B<Muldis D Entry Notation> specification defines the grammar of the official
concrete Muldis D language syntax that every Muldis D implementation
is expected to support as an option.  It is intended to be a standard format
of interchange of both code and data between all Muldis D implementations.
It is also expected to be the syntax of choice for users to write Muldis D
applications or database schemas in, having the most direct correspondance
to the I<native> homoiconic Muldis D defined by B<Muldis D Foundation>, and
is designed to have a similar level of conciseness and readability as what
users get in both typical general purpose application programming languages
as well as SQL.
That being said, Muldis D is designed to empower a variety of alternate
language syntaxes to be used in different areas of a program, either in
support of user tastes, or for better host/peer language integration
(including their ORMs), or as a method of emulating other programming
language environments or SQL DBMSs.

This document defines the grammar that all non-hosted plain-text Muldis D
source code must conform to when it claims to be written in the
C<Muldis_D Entry_Notation 'http://muldis.com' '0.201.0.-9'> (B<MDEN>) language.

This grammar is meant to be more illustrative to human readers than
executable, as is typical for standards documents; you wouldn't likely be
able to just hand if off to a parser-generator and expect it to work as is.
But it should still have enough information to derive an executable parser.

Note that the standard filename extension for files with such source code
is C<.mdpt>, though as per standard UNIX conventions, such Muldis D source
code files can in fact have any filename extension when there is other
context to interpret them with.  Filename extensions are more for the
benefit of the operating system or command shell or users than for a Muldis
D implementation, the latter just cares about the content of the file.

I<TODO: Comment about resolving package names to package source files;
the CompUnitRepo concept of Perl 6 would be a good precedent.
That will probably go somewhere else in the spec rather than here.>

A primary feature of Muldis D is a grammar that is small and simple while
still being quite rich and expressive.  As much as possible of the language
is defined in terms of ordinary packages, types and routines, in exactly
the same manner as users write their own code in.  Therefore, a Muldis D
grammar has no special knowledge of, or specific syntax for, the vast
majority of the language, and mainly just concerns itself with the minimal
syntactic framework for defining generic types and routines, generic
expressions and statements, and has special handling for just a small
number of data types or routines.  A key benefit of this is that it is very
easy for users to extend the language with new features that look and work
in the same way as the system-defined ones, and are drop-in substitutable
for them, rather than user-defined things being second-class citizens.  The
design also means it is much easier to implement the Muldis D language
itself, a large part of the langauge can be bootstrapped, and both parsers
and generators of Muldis D Entry Notation can be simple and easy to make.

Muldis D Entry Notation has a I<linear syntax>, and is designed to be easily
handled by a single-pass parser, or at least a single-pass lexer; all the
context that one needs to know for how to parse or lex any arbitrary
substring of code is provided by prior code, or any required lookahead is
just by a few characters in general.  Therefore, a parser/lexer can easily
work on a streaming input like a file-handle where you can't go back
earlier in the stream.  Often this means a parser/lexer can work with
little RAM.

Also the grammar is designed that any amount of whitespace can be added or
omitted next to most non-alphanumeric characters (which happen to be next
to alphanumeric tokens) without that affecting the meaning of the code at
all, except obviously for within character string literals.  And long
binary or character or numeric or identifier strings can be split into
arbitrary-size substrings, without affecting the meaning.  And many
elements are identified by name rather than ordinal position, so to some
degree the order they appear has no effect on the meaning.  So programmers
can easily format (separate, indent, linewrap, order) code how they like,
and making an automated code reformatter shouldn't be difficult.  Often,
named elements can also be omitted entirely for brevity, in which case the
parser would use context to supply default values for those elements.

=head1 GRAMMAR INTERPRETATION

I<TODO: Describe the grammar itself and how to interpret it.  Meanwhile,
keep in mind that the grammar is inspired by both EBNF and Perl 6 rules.>

    About separator-defined repetitions:
    - ** takes number or range on right
    - % takes list item separator on right, eg allows "x,y" but not "x,y,"
    - %% is like % but allows separator to end the list, eg allows "x,y,"

=head1 PARSING UNITS

A I<parsing unit> of Muldis D Entry Notation source code is composed of two
main parts, the I<parsing unit subject> and the I<parsing unit predicate>,
in this context abbreviated as I<subject> and I<predicate>.

A I<parsing unit subject> is the meat-and-potatoes of Muldis D Entry Notation
source code, and generally takes the form in memory of a Muldis D C<Blob>
or C<Text> value I<S>; parsing a well-formed I<S> results in some other
Muldis D value I<N>.  Typically I<N> is a value of the C<Package> type and
thus comprises a Muldis D I<compilation unit>, but it might also be a value
of some other type.

A I<parsing unit predicate> is a guide for I<how> to unambiguously parse
the I<subject>, and generally takes the form in memory of a Muldis D
C<Blob> or C<Text> value; it includes such details as a grammar version
declaration and a text encoding declaration.

When Muldis D Entry Notation source code is kept in its own self-describing
file, typically one with the C<.mdpt> standard filename extension, as per
library or project conventions for typical general-purpose programming
languages or structured data files, the entire I<parsing unit> is combined
into the single file, with the I<parsing unit predicate> appearing first as
a file heading, and the I<parsing unit subject> following that.

In this combined-file situation, a primary role of the I<predicate> is to
serve as a "magic number" that identifies the file as being MDEN source
code.  Its secondary role is to explicitly state the character encoding and
similar details of the file so that the file can be correctly converted
from octets (a C<Blob>) to character data (a C<Text>) which most of the
MDEN grammar assumes it is taking as input; this means the parser does not
have to rely on hueristics or other methods of determining encoding that
could be wrong.  Its tertiary role is to explicitly state what versions of
the MDEN grammar the author of the MDEN code believes it is known to be
compatible or incompatible with, so that the grammar can be more free to
evolve without that leading to parsers wrongly interpreting code.

When Muldis D Entry Notation source code is not kept in its own self-describing
file, typically when a source code repository is in use that provides
context externally to each I<parsing unit subject> on how to interpret it,
then the I<subject> and I<predicate> are typically given to the parser as
separate inputs.  This is particularly likely in situations where the
virtual machine environment running the Muldis D code is a library of some
host language that is feeding in Muldis D code piecemeal (possibly
generated), such as a typical DBMS client application may do.  Such uses
would be served by not having to provide the I<predicate> boilerplate every
time they want to run I<subject> code, which often is very small itself.

The root grammar token for Muldis D Entry Notation is C<< <MDEN> >>.

The root grammar token for a Muldis D Entry Notation self-describing file is
C<< <parsing_unit> >>.

The root grammar token for a Muldis D Entry Notation I<parsing_unit_predicate>
in isolation is C<< <parsing_unit_predicate> >>.

The root grammar token for a Muldis D Entry Notation I<parsing_unit_subject>
in isolation is C<< <parsing_unit_subject> >>.

Grammar:

    <MDEN> ::=
        ^ <parsing_unit> | <parsing_unit_predicate> | <parsing_unit_subject> $

    <parsing_unit> ::=
        <shebang_line>? <sp> <parsing_unit_predicate> <sp> <parsing_unit_subject>

See the sections in this file named L<SHEBANG LINE>,
L<PARSING UNIT PREDICATES>, and L</PARSING UNIT SUBJECTS> for more details.

=head1 SHEBANG LINE

Grammar:

    <shebang_line> ::=
        '#!' <shebang_directive> <shebang_whitespace_break>

    <shebang_directive> ::=
        ...

    <shebang_whitespace_break> ::=
        ...

A C<< <shebang_line> >>, if it exists, must be the first characters of the
text file, and consists of a magic number which expressed as ASCII or UTF-8
is C<#!>, followed by a Unix-like interpreter directive or path to an
executable that can interpret Muldis D Entry Notation files.  When a Muldis D
Entry Notation file starts with a shebang line, it can be invoked directly as
if it were an executable on a Unix-like system.  The format of
C<< <shebang_directive> >> isn't defined in this document; see the appropriate
external Unix/etc documentation for that; however, the Muldis D Entry Notation
file must have at least one line-breaking whitespace character of some kind
following it, which is how we know where the Muldis D code begins.

Examples:

    #!/usr/bin/env muldisdre

=head1 PARSING UNIT PREDICATES

Grammar:

    <parsing_unit_predicate> ::=
        <language_name> <sp>
        <script_name>

See the sections in this file named L</LANGUAGE NAME> and L</SCRIPT NAME>
for more details.

=head1 LANGUAGE NAME

Grammar:

    <language_name> ::=
        <ln_family_name>
        <sp> <ln_syntax_name>
        <sp> <ln_authority>
        <sp> <ln_version_number>

    <ln_family_name> ::=
        Muldis_D

    <ln_syntax_name> ::=
        Entry_Notation

    <ln_authority> ::=
        <Text_seg>

    <ln_version_number> ::=
        <Text_seg>

As per the VERSIONING section of L<Muldis::D>, every source code or data
expression as Muldis D Entry Notation must be accompanied by an explicit
declaration that it is MDEN, and specify at least 1 version of the MDEN
standard that its author intends that it conforms with; this declaration is
called a fully-qualified I<language name> and serves as a "magic number".

I<Note that the terminology "language name" might be renamed soon.>

SEE ALSO http://design.perl6.org/S11.html#Versioning FOR GUIDANCE...

Examples:

    Muldis_D Entry_Notation 'http://muldis.com' '0.201.0.-9'

    Muldis_D Entry_Notation 'http://example.com' '42'

=head1 SCRIPT NAME

Grammar:

    <script_name> ::=
        meta script <Text_seg>

The C<< <script_name> >> indicates the primary script of the Muldis D code,
meaning is character repertoire and/or character encoding and/or character
normalization.  Under the assumption that a C<Muldis_D Entry_Notation> parser
might be reading the source code as binary data or otherwise as
unnormalized character data, declaring the I<script name> makes it completely
unambiguous as to what characters it is to be treating the input as.

For a simple example, a I<script name> of C<ASCII> says every literal source
code character is a 7-bit ASCII character (and representing any non-ASCII
characters is being done with escape sequences), and this is recommended
for any C<Muldis_D Entry_Notation> file that doesn't need to be something else.
For various legacy 8-bit formats the I<script name> can tell us if we're using
C<Latin1> or C<CP1252> or C<EBCDIC> etc.  For Unicode the I<script name> would
have multiple parts, such as C<Unicode(10.0,UTF-8,canon)>, indicating
expected repertoire, and encoding (useful more with ones lacking BOMs); but
at the very least it is useful with normalization; if C<compat> is declared
then the source code is folded before it is parsed so possibly distinct
literal characters in the original code are seen as identical character
strings by the main parser, while C<canon> would not do this folding.

A Muldis D parser would possibly scan through the same source code multiple
times filtering by a variety of text encodings until it can read a Muldis D
language name declaring the same encoding that the name is itself written
in, and then from that point it would expect the whole file to be that
declared encoding or it would consider the code invalid.

Iff C<< <foundational_indicator> >> is present, then C<< <script_name> >>
is absent, and the Muldis D code as binary data is expected to be valid
UTF-8 according to the latest Unicode standard of the time, and it will be
treated literally without applying any Unicode normalization.  In practice,
such code will often just be ASCII, a proper subset of UTF-8, but it is not
required to be so limited.  In practice, having a specific implied Unicode
version not be fixed shouldn't be a problem, as the definition of UTF-8
tends to be both simple and very stable over time.

Examples:

    meta script 'ASCII'

    meta script 'Unicode 10.0 UTF-8 canon'

=head1 PARSING UNIT SUBJECTS

Grammar:

    <parsing_unit_subject> ::=
        <expr>

    <expr> ::=
        <opaque_literal_expr> | <collection_selector_expr>

See the sections in this file named L</OPAQUE LITERAL EXPRESSIONS>
and L</COLLECTION SELECTOR EXPRESSIONS> for more details.

=head1 CHARACTER CLASSES

Grammar:

    <enumerated_char> ::=
          <alphanumeric_char>
        | <quoting_char>
        | <bracketing_char>
        | <symbolic_char>
        | <whitespace_char>
        | <illegal_char>

    <alphanumeric_char> ::=
        <alpha_char> | <digit_char>

    <alpha_char> ::=
        <[ A..Z _ a..z ]>

    <digit_char> ::=
        <[ 0..9 ]>

    <quoting_char> ::=
        <["'`]>

    <bracketing_char> ::=
        '(' | ')' | '[' | ']' | '{' | '}'

    <symbolic_char> ::=
        <special_symbolic_char> | <regular_symbolic_char>

    <special_symbolic_char> ::=
        ',' | ':' | ';' | '\\'

    <regular_symbolic_char> ::=
          '!' | '#' | '$' | '%' | '&' | '*' | '+' | '-' | '.' | '/'
        | '<' | '=' | '>' | '?' | '@' | '^' | '|' | '~'

    <whitespace_char> ::=
        <ws_unrestricted_char> | <ws_restricted_outside_char>

    <ws_unrestricted_char> ::=
        ' '

    <ws_restricted_outside_char> ::=
        '\t' | '\n' | '\r'

    <illegal_char> ::=
        <[ \x<0>..\x<8> \x<B>..\x<C> \x<E>..\x<1F> \x<80>..\x<9F> ]>

    <unrestricted_char> ::=
          <alphanumeric_char>
        | <bracketing_char>
        | <symbolic_char>
        | <ws_unrestricted_char>

    <restricted_outside_char> ::=
        <unrestricted_char> | <ws_restricted_outside_char>

    <restricted_inside_char> ::=
        <-quoting_char -illegal_char -ws_restricted_outside_char>

The Muldis D Entry Notation grammar recognizes 7 distinct character codepoint
(hereafter referred to as I<character>) classes,
which are mutually disjoint proper subsets of the character repertoire
identified by the I<script name>: I<alphanumeric>, I<quoting>, I<bracketing>,
I<symbolic>, I<whitespace>, I<illegal>, I<nonenumerated>; the first 6 are
collectively I<enumerated>.

The first 5 I<enumerated> classes (all but I<illegal>) are the more
syntactically interesting ones and are generally what the grammar are
defined in terms of.

Broadly speaking, Muldis D Entry Notation code is made up of 2 primary
grammatical contexts which are mutually disjoint and complementary; one of
these is anywhere I<outside> all quoted strings, and its complement is
anywhere I<inside> any quoted string; it is the I<quoting> characters that
mark the transition between these 2 contexts.  Broadly speaking, all of the
I<enumerated> classes (except I<illegal>) represent characters that are
I<unrestricted> and may appear anywhere in Entry Notation source code.  In
contrast, I<nonenumerated> characters may only appear literally
inside of a quoted string, and I<illegal> characters may not appear
literally in source code at all.

All characters of the ASCII repertoire are I<enumerated>; loosely speaking,
all printable ASCII characters are I<unrestricted>, as
are the small number of non-printable ASCII characters named in C<<
<whitespace_char> >>; all other (non-printable) ASCII characters are
I<illegal>.

The vast majority of non-ASCII Unicode characters are I<restricted> to
appearing literally inside of a quoted string, loosely speaking the
only exceptions being the small number named in C<< <symbolic_char> >> or
C<< <whitespace_char> >>; any non-ASCII Unicode control characters not
otherwise named are I<illegal>.

Regardless of character class, all characters may be logically represented
in terms of character escape sequences, but only inside of a quoted string.

Note that the primary reason most enumerated whitespace characters are
generally restricted from being inside of a quoted string is so that the
Muldis D Entry Notation code is resilient to passage through environments that
might have different native line-breaking characters; the restriction
guarantees that executing the code will produce logically identical values
and behaviour for character string literals or quoted identifiers.  In
contrast, changing the line-breaking whitespace outside of string literals
is okay and doesn't change behavior, so code can be formatted with them.

Note that the symbolic category is arbitrary in the trans-ASCII range and
is highly subject to gain or lose characters over time.

Note that, while in theory supporting bareword Greek letters may make math
or logic expressions more pleasant, for now they aren't partly to avoid
confusion with similar-looking ASCII letters, and because its hard to know
where to draw the line if one wanted to include the whole un-accented Greek
alphabet, not just C<[ Α..Ρ Σ..Ω α..ω ]>; so in the end, simplicity rules.
UPDATE: A select few Greek letters are supported bareword, enumerated above.

=head1 ESCAPED CHARACTERS

Grammar:

    <escaped_char> ::=
          '\\q' | '\\a' | '\\g'
        | '\\b'
        | '\\t' | '\\n' | '\\r'
        | ['\\c<' <asigned_int> '>']

The meanings of the simple character escape sequences are:

    Esc | Unicode   | Unicode         | Chr | Literal character used
    Seq | Codepoint | Character Name  | Lit | for when not escaped
    ----+-----------+-----------------+-----+------------------------------
    \q  | 0x22      | QUOTATION MARK  | "   | delimit quoted names
    \a  | 0x27      | APOSTROPHE      | '   | delimit Text/opaque literals
    \g  | 0x60      | GRAVE ACCENT    | `   | delimit dividing space comments
    \b  | 0x5C      | REVERSE SOLIDUS | \   | no special meaning in non-escaped
    \t  | 0x9       | CHAR... TAB...  |     | control char horizontal tab
    \n  | 0xA       | LINE FEED (LF)  |     | ctrl char line feed / newline
    \r  | 0xD       | CARR. RET. (CR) |     | control char carriage return

There is currently just one complex escape sequence, of the format C<<
\c<...> >>, that supports specifying characters in terms of their Unicode
abstract codepoint number.  One reason for this feature is to empower more
elegant passing of Unicode-savvy Entry_Notation source code through a
communications channel that is more limited, such as to 7-bit ASCII.

Examples:

    \a

    \n

    \c<0x263A>

    \c<65>

Note that Entry_Notation eschews built-in support for a C<< \c<...> >> format
that specifies characters in terms of their Unicode character name, for
example C<< \c<LATIN SMALL LETTER OU> >>.  Instead, it is left to the
domain of non-core Muldis D packages to support such a feature.  The main
reason for this is to avoid an unconditionally-mandatory complex dependency
that is the Unicode character database.

=head1 DIVIDING SPACE

Grammar:

    <sp> ::=
        [<whitespace> | <quoted_sp_comment_str>]*

    <whitespace> ::=
        <whitespace_char>+

    <quoted_sp_comment_str> ::=
        '`' <-[`]>* '`'

The primary function of I<dividing space>, represented by C<< <sp> >>, is
to disambiguate the boundaries of otherwise-consecutive grammar tokens.

Once Muldis D Entry Notation code is parsed, any dividing space is just
discardable non-semantic metadata for its wider context, but during a parse
its presence is often critical to properly interpret the wider context.

The grammar doesn't specify this explicitly for simplicity, but anywhere a
C<< <sp> >> token appears, it should be interpreted as carrying a number of
look-around assertions regarding adjacent tokens.

In the context of any C<< <foo> <sp> <bar> >>, these syntax rules apply:

=over

=item *

If C<< <foo> >> and C<< <bar> >> are of different character classes
(alphanumeric vs quoting vs bracketing vs symbolic vs whitespace) then C<<
<sp> >> is allowed to be empty.

=item *

Otherwise, if C<< <foo> >> and C<< <bar> >> are both alphanumeric then C<<
<sp> >> must be nonempty.

=item *

Otherwise, if C<< <foo> >> and C<< <bar> >> are both quoting or bracketing
or whitespace then C<< <sp> >> is allowed to be empty.

=item *

Otherwise, C<< <foo> >> and C<< <bar> >> are both symbolic; whether or not
C<< <sp> >> is allowed to be empty or not depends on the specific sequence
of symbolic characters in the original source code, as described by the
subsequent syntax rules.

=item *

If either C<< <foo> >> or C<< <bar> >> or both are either C<,> or C<;> or
C<\> then C<< <sp> >> is allowed to be empty.

=item *

Otherwise, if exactly one of C<< <foo> >> or C<< <bar> >> is C<:> and the
other doesn't have that character then C<< <sp> >> is allowed to be empty.

=item *

OBSOLETE: Otherwise, if C<< <foo> >> is C<:=> then C<< <sp> >> is allowed to be empty.

=item *

Otherwise, C<< <sp> >> must be nonempty.

=back

I<TODO.  Some of the above points concerning ":" are outdated and need fixing.>

The secondary function of I<dividing space> is to empower users to format
their code for easier readability through appropriate linebreaks,
indentation, and other kinds of spacing, as they see fit; what they choose
here has no impact on the behavior of the code.

The tertiary function of I<dividing space> is to empower the placement of
code comments or visual dividers almost anywhere, but with the caveat that
comments written this way are not introspectable as comments in the parsed
code, and rather are treated like insignificant whitespace.  This style of
comment defined with backtick-quoted strings should just be used for the
likes of visual dividers or less important comments or for when you want to
quickly "comment out" some source code rather than deleting it.

For more important comments that are introspectable as such, see the
section in this file named L<... TODO ...>.

Examples:

    `This does something.`

=head1 KEYWORDS

Muldis D Entry Notation has a number of keywords, both alphanumeric and
symbolic, which have special meaning in certain contexts.  However, it does
not have any reserved words so users can still define identifiers having
any character string they want.

The keywords use a proper subset of the same syntax otherwise available for
user-defined identifiers.  In any contexts where it would otherwise be
ambiguous as to whether a term is a keyword versus the name of some entity,
the parser will always take the keyword interpretation.  For all such
cases, Muldis D Entry Notation provides syntax options that explicitly
disambiguate in favor of the non-keyword choice.  Since every entity name
C<foo> is allowed to be double-quoted anywhere it appears like C<"foo">,
while all keywords only have a single syntax each which is non-quoted, a
non-quoted C<foo> will always favor the keyword while a quoted C<"foo">
will always favor the entity name.

These are keywords only within a I<parsing unit predicate>:

    Muldis_D
    Entry_Notation
    meta
    script

There are no keywords at all within a I<parsing unit subject>.

These are keyword-like value literals only within a I<parsing unit subject>:

    False
    True

These are used as list/pair separators only within a I<parsing unit subject>:

    ::
    :
    ;
    ,

Finally, the backslash C<\> is used heavily to indicate value literals of
many different kinds, disambiguating them from other things.

Muldis D Entry Notation purposefully keeps its set of keywords small, therefore
giving users the maximum amount of flexibility to effectively define
whatever operator/etc names they want for use as barewords, and the full
complement of system-defined types and operators are defined using the same
tools users have, so if you don't see something in the lists you would
expect to be system-defined, i's likely they're defined in libraries.

=head1 IDENTIFIERS

I<TODO: This section needs to be stripped down.>

Grammar:

    <alphanumeric_name> ::=
        <alpha_char> <alphanumeric_char>*

    <symbolic_name> ::=
        <symbolic_char>+

    <quoted_name> ::=
        <quoted_name_seg> % <sp>

    <quoted_name_seg> ::=
        '"' <qnots_content> '"'

    <qnots_content> ::=
        <qns_nonescaped_content> | <qns_escaped_content>

    <qnots_nonescaped_content> ::=
        [<restricted_inside_char-[\\]> <restricted_inside_char>*]?

    <qnots_escaped_content> ::=
        '\\' [<restricted_inside_char-[\\]> | <escaped_char>]*

    <generic_name> ::=
        <alphanumeric_name> | <quoted_name>

    <fixed_name> ::=
        <alphanumeric_name> | <symbolic_name>

    <attr_name> ::=
        <nonord_attr_name> | <ord_attr_name>

    <nonord_attr_name> ::=
        <generic_name>

    <ord_attr_name> ::=
        <digit_char>+

    <nesting_attr_names> ::=
        <attr_name> % [<sp> '::' <sp>]

    <expr_name> ::=
        <generic_name>

    <var_name> ::=
        <generic_name>

    <stmt_name> ::=
        <generic_name>

    <pkg_entity_name> ::=
          <absolute_name>
        | <relative_name>
        | <floating_name>

    <absolute_name> ::=
        '::' <sp> <floating_name>

    <relative_name> ::=
        <digit_char>+ [<sp> '::' <sp> <floating_name>]?

    <floating_name> ::=
        <generic_name> % [<sp> '::' <sp>]

    <folder_name> ::=
        <absolute_name>

    <material_name> ::=
        <absolute_name>

    <generic_func_name> ::=
        <pkg_entity_name>

    <generic_proc_name> ::=
        <pkg_entity_name>

    <entry_point_rtn_name> ::=
        <absolute_name>

A C<< <generic_name> >> is a I<generic context entity name>, which can be
used in any context that is expecting I<a> Muldis D entity name in the
general sense, without restrictions.  Examples of use are when declaring
any named entity or with general type/routine/etc invocation syntax that
allows any entity of the respective kind, or for attr names.

A C<< <fixed_name> >> is for use within value expressions with certain
common cases of function invocations where an unqualified
operator name appears next to its operands without any parenthesis to group
the operands under the operator.  The I<fixed> name comes from such
invocations being usually qualified as I<prefix> or I<infix> or I<postfix>.

A C<< <pkg_entity_name> >> is for use when either declaring or referencing
package entities (types, singleton type definers, functions, procedures, aliases, etc)
which live within a multi-level namespace.

=head1 OPAQUE LITERAL EXPRESSIONS

Grammar:

    <opaque_literal_expr> ::=
          <Boolean>
        | <Integer>
        | <Fraction>
        | <Bits>
        | <Blob>
        | <Text>
        | <Simple_Excuse>
        | <Attr_Name>
        | <Heading>
        | <Local_Name>

An C<< <opaque_literal_expr> >> is an C<< <expr> >> that denotes a value
literal specific to some system-defined data type that has its own special
Muldis D Entry Notation selector syntax, and this literal syntax explicitly has
no child C<< <expr> >> nodes.  In conventional terms, one is typically for
selecting scalar values, though many cases are also simple collections.

=head2 Boolean Literals

Grammar:

    <Boolean> ::=
        ['\\?' <sp>]? [False | True]

A C<< <Boolean> >> node represents a value of the Muldis D C<Boolean> type,
which is a general purpose 2-valued logic boolean or I<truth value>.  The
C<Boolean> type is a foundational type of the Muldis D type system, and
this is the canonical grammar for them.

Examples:

    False

    True

    \?False

    \?True

=head2 Integer Literals

Grammar:

    <Integer> ::=
        <nonquoted_int> | <quoted_int>

    <nonquoted_int> ::=
        ['\\+' <sp>]? <asigned_int>

    <quoted_int> ::=
        <qu_num_head> <qu_asigned_int> <qu_num_tail>

    <qu_num_head> ::=
        '\\+' <sp> '\''

    <qu_asigned_int> ::=
        <asigned_int> <qu_num_mid>?

    <qu_num_mid> ::=
        <num_seg> % <qu_num_sp>

    <qu_num_sp> ::=
        '\'' <sp> '\''

    <qu_num_tail> ::=
        '\''

    <asigned_int> ::=
        <num_sign>? <nonsigned_int>

    <num_sign> ::=
        '+' | '-'

    <nonsigned_int> ::=
        <num_radix_mark>? <num_seg>

    <num_radix_mark> ::=
        0 <[bodx]>

    <num_seg> ::=
        <num_char>+

    <num_char> ::=
        <nc2> | <nc8> | <nc10> | <nc16>

    <nc2> ::=
        <[ 0..1 _ ]>

    <nc8> ::=
        <[ 0..7 _ ]>

    <nc10> ::=
        <[ 0..9 _ ]>

    <nc16> ::=
        <[ 0..9 A..F _ a..f ]>

An C<< <Integer> >> node represents a value of the Muldis D C<Integer>
type, which is a general purpose exact integral number of any magnitude,
which explicitly does not represent any kind of thing in particular,
neither cardinal nor ordinal nor nominal.  The C<Integer> type is a
foundational type of the Muldis D type system, and this is the canonical
grammar for them.

This grammar supports writing C<Integer> literals in any of the numeric
bases {2,8,10,16} using conventional syntax.  The literal may optionally
contain underscore characters (C<_>), which exist just to help with visual
formatting, such as for C<10_000_000>.

This grammar is subject to the following additional rules:

=over

=item *

If C<< <num_radix_mark> >> is omitted or is C<0d> then every
C<< <num_char> >> must be a C<< <nc10> >>.

=item *

Otherwise, if C<< <num_radix_mark> >> is C<0b> or C<0o> or C<0x> then every
C<< <num_char> >> must be a C<< <nc2> >> or C<< <nc8> >> or C<< <nc16> >>
respectively.

=back

A quoted C<< <Integer> >> may optionally be split into 1..N quoted segments
where each pair of consecutive segments is separated by dividing space;
this segmenting ability is provided to support code that contains very long
numeric literals while still being well formatted (no extra long lines).

Note that the general grammar rules of Muldis D Entry Notation will treat all
nonquoted symbolic characters {-,+,.,/} as I<fixed> operator invocations,
and nonquoted digit sequences as positive integer literals.  However,
nonquoted numeric literals have a special exception for {-,+,.,/} iff they
appear in very specific places, such that those symbolics are treated as
part of a numeric literal instead of an operator call.  This is done so
that all values of the core numeric types can be written in a clean and
concise manner while avoiding any risk of the meanings of the literals
changing depending what Muldis D packages are in scope, which would be the
case if the symbolics were parsed as operator calls.  When writing Muldis D
Entry Notation code with unquoted numeric literals, having dividing space
between any {-,+,.,/} and any C<< <num_char> >> should guarantee their
interpretation as an operator call, while ensuring no dividing space
between them should guarantee interpretation as part of the literal iff the
symbolics are in specific positions expected for the latter.  This special
exception breaks the general grammar rule where symbolics and alphanumerics
are always considered separate tokens regardless of whether or not there is
dividing space between them, however that is considered a lesser surprise.

Examples:

    42

    0

    -3

    \+'-3' '50_897'

    \+81

    0d39

    0xDEADBEEF

    0o644

    0b11001001

=head2 Fraction Literals

Grammar:

    <Fraction> ::=
        <nonquoted_frac> | <quoted_frac>

    <nonquoted_frac> ::=
        <nonquoted_int> <frac_div> <num_seg>

    <quoted_frac> ::=
        <qu_num_head> <qu_asigned_int> <frac_div> <qu_num_mid> <qu_num_tail>

    <frac_div> ::=
        '.' | '/'

A C<< <Fraction> >> node represents a value of the Muldis D C<Fraction>
type, which is a general purpose exact rational number of any magnitude and
precision, expressible as a coprime I<numerator> / I<denominator> pair of
C<Integer> whose I<denominator> is positive, which explicitly does not
represent any kind of thing in particular, neither cardinal nor ordinal nor
nominal.

The C<Fraction> type is not a foundational type of the Muldis D type
system, but rather is a subtype by constraint of the C<Capsule> type, and
all C<Fraction> values can be selected in terms of C<< <Capsule> >> grammar
nodes.  However, C<< <Fraction> >> is the canonical grammar for all
C<Fraction> values.

An entire C<< <Fraction> >> literal has the same numeric base, both the
part before the C<< <frac_div> >> and the part after it.  When the C<<
<frac_div> >> is a C</>, the literal portion on the left is treated as the
integral I<numerator> and the part on the right as the integral
I<denominator>; the literal allows that pair to not be coprime, and it will
be normalized in the derived C<Fraction> value.  When the C<< <frac_div> >>
is a C<.>, the anormal I<numerator> is determined by treating all of the
C<< <num_char> >> as an integral literal as if the C<.> wasn't there, and
the anormal I<denominator> is determined by taking the numeric base to the
power of the number of C<< <num_char> >> on the right side of the C<.>.

Examples:

    3.14159

    0.0

    5/3

    -4.72

    -472/100

    \+29.95

    0xDEADBEEF.FACE

    -0o35/3

    0b1.1

=head2 Bits Literals

Grammar:

    <Bits> ::=
        '\\~?' <sp> [
              [['\'' ['0b' <nc2>* ]? '\''] % <sp>]
            | [['\'' ['0o' <nc8>* ]? '\''] % <sp>]
            | [['\'' ['0x' <nc16>*]? '\''] % <sp>]
        ]

A C<< <Bits> >> node represents a value of the Muldis D C<Bits> type, which
is an arbitrarily-long sequence of I<bits> where each bit is represented by
an C<Integer> in the range 0..1.

The C<Bits> type is not a foundational type of the Muldis D type system,
but rather is a subtype by constraint of the C<Capsule> type, and all
C<Bits> values can be selected in terms of C<< <Capsule> >> grammar nodes.
However, C<< <Bits> >> is the canonical grammar for all C<Bits> values.

This grammar supports writing C<Bits> literals in any of the numeric bases
{2,8,16} using conventional syntax.  The literal may optionally contain
underscore characters (C<_>), which exist just to help with visual
formatting.  A C<< <Bits> >> may optionally be split into 1..N segments
where each pair of consecutive segments is separated by dividing space.

Examples:

    \~?''

    \~?'0b00101110100010'

    \~?'0o644'

    \~?'0xA705E'

=head2 Blob Literals

Grammar:

    <Blob> ::=
        '\\~+' <sp> [
              [['\'' ['0b' <nc2>* ]? '\''] % <sp>]
            | [['\'' ['0x' <nc16>*]? '\''] % <sp>]
        ]

A C<< <Blob> >> node represents a value of the Muldis D C<Blob> type, which
is an arbitrarily-long sequence of I<octets> where each octet is
represented by an C<Integer> in the range 0..255.

The C<Blob> type is not a foundational type of the Muldis D type system,
but rather is a subtype by constraint of the C<Capsule> type, and all
C<Blob> values can be selected in terms of C<< <Capsule> >> grammar nodes.
However, C<< <Blob> >> is the canonical grammar for all C<Blob> values.

This grammar supports writing C<Blob> literals in any of the numeric bases
{2,16} using conventional syntax.  The literal may optionally contain
underscore characters (C<_>), which exist just to help with visual
formatting.  A C<< <Blob> >> may optionally be split into 1..N segments
where each pair of consecutive segments is separated by dividing space.

This grammar is subject to the following additional rules:

=over

=item *

If the C<< <Blob> >> segments are prefixed by C<0b> then the total count of
C<< <nc2> >> in the C<< <Blob> >> excluding C<_> must be an even multiple
of 8.

=item *

Otherwise, if the C<< <Blob> >> segments are prefixed by C<0x> then the
total count of C<< <nc16> >> in the C<< <Blob> >> excluding C<_> must be an
even multiple of 2.

=back

Examples:

    \~+''

    \~+'0xA705E416'

    \~+'0b00101110_10001011'

=head2 Text Literals

Grammar:

    <Text> ::=
        ['\\~' <sp>]? [<Text_seg> % <sp>]

    <Text_seg> ::=
        '\'' <qnots_content> '\''

A C<< <Text> >> node represents a value of the Muldis D C<Text> type, which
is characterized by an arbitrarily-long sequence of Unicode 10.0 standard
I<character codepoints>.

The C<Text> type is not a foundational type of the Muldis D type system,
but rather is a subtype by constraint of the C<Capsule> type, and all
C<Text> values can be selected in terms of C<< <Capsule> >> grammar nodes.
However, C<< <Text> >> is the canonical grammar for all C<Text> values.

A C<< <Text> >> may optionally be split into 1..N segments where each pair
of consecutive segments is separated by dividing space.

Examples:

    'Ceres'

    'サンプル'

    ''

    '\This isn\at not escaped.\n'

    '\\c<0x263A>\c<65>'

    \~'Green'

=head2 Simple Excuse Literals

Grammar:

    <Simple_Excuse> ::=
        '\\!' <sp> <attr_name>

A C<< <Simple_Excuse> >> node represents a value of the Muldis D C<Excuse>
type, and provides a terser alternative syntax to an C<< <Excuse> >> node
for the common special case of C<Excuse> having just the C<0> attribute
where that attribute is valued with an C<Attr_Name>, such as is the case
for all typical Muldis D Foundation defined C<Excuse> subtypes.

Examples:

  \!No_Reason

  \!Before_All_Others

  \!Div_By_Zero

  \!No_Such_Attr_Name

=head2 Attribute Name and Heading Literals

Grammar:

    <Attr_Name> ::=
        '\\' <sp> <attr_name>

    <Heading> ::=
        '\\@' <sp> <delim_attr_name_commalist>

    <delim_attr_name_commalist> ::=
        '(' <sp> <attr_name_commalist> <sp> ')'

    <attr_name_commalist> ::=
        [<attr_name> | <ord_attr_name_range> | ''] % [<sp> ',' <sp>]

    <ord_attr_name_range> ::=
        <min_ord_attr> <sp> '..' <sp> <max_ord_attr>

    <min_ord_attr> ::=
        <ord_attr_name>

    <max_ord_attr> ::=
        <ord_attr_name>

A C<< <Heading> >> node represents a value of the Muldis D
C<Heading> type, which is an arbitrarily-large unordered collection of
attribute names.  An C<< <Attr_Name> >> node represents a value of the Muldis
D C<Attr_Name> type, which is a subtype by constraint of the C<Heading>
type; C<< <Attr_Name> >> provides a terser alternative syntax for the
common special case of C<< <Heading> >> having exactly 1 attribute.

An C<< <ord_attr_name_range> >> is subject to the additional rule that its
integral C<< <min_ord_attr> >> value must be less than or equal to its
integral C<< <max_ord_attr> >> value.

The C<Heading> type is not a foundational type of the Muldis D type
system, but rather is a subtype by constraint of the C<Tuple> type, and all
C<Heading> values can be selected in terms of C<< <Tuple> >> grammar
nodes.  However, C<< <Heading> >> is the canonical grammar for all
C<Heading> values, except for all C<Attr_Name> values, for which
C<< <Attr_Name> >> is the canonical grammar.

Examples:

    `Zero attributes.`
    \@()

    `One named attribute.`
    \sales

    `Same thing.`
    \@(sales)

    `Same thing.`
    \@("sales")

    `One ordered attribute.`
    \0

    `Same thing.`
    \"\\c<0>"

    `Three nonordered attributes.`
    \@(region,revenue,qty)

    `Three ordered attributes.`
    \@(0..2)

    `One of each.`
    \@(1,age)

    `Some attribute names can only appear quoted.`
    \"Street Address"

    `A non-Latin name.`
    \"サンプル"

=head2 Local Name Literals

Grammar:

    <Local_Name> ::=
        '\\@' <sp> <nesting_attr_names>

A C<< <Local_Name> >> node represents a value of the Muldis D C<Local_Name>
type, which is an arbitrarily-long sequence of C<Attr_Name> values.  It
serves as a (fully or partially) qualified identifier for referencing
either a foundation entity, or a package or component of the latter, from
the perspective of an entity in a (possibly same) package using it.

Iff the first/only C<Attr_Name> in the sequence is one of the barewords
C<{foundation,used,package,folder,material,floating}> then it is used
as-is; otherwise the sequence will implicitly have the element C<floating>
prepended to it.  Each of the non-first (post optional prepend) sequence
elements corresponds in order to a level in a multi-level namespace.

The C<Local_Name> type is not a foundational type of the Muldis D type
system, but rather is a subtype by constraint of the C<Array> type, and all
C<Local_Name> values can be selected in terms of C<< <Array> >> grammar
nodes.  However, C<< <Local_Name> >> is the canonical grammar for all
C<Local_Name> values.

Examples:

    `The Muldis D Foundation function Integer_plus, from any perspective.`
    \@foundation::Integer_plus

    `The system-defined "Relation" type, from the perspective of some other
    package that "uses" the "System" package under the local alias "MD".`
    \@used::MD::Relation

    `Some user-defined "main" procedure, from the perspective of the same
    package as that which it is defined in.`
    \@package::main

    `Some entity "foo" that has the same parent folder as the observer.`
    \@folder::foo

    `Some material from its own perspective, such as for self-recursion.`
    \@material

    `Same "Relation" as above iff \@used::MD is among in the declared
    "floating" list of the same observer's package.`
    \@floating::Relation

    `Same thing.`
    \@Relation

=head1 COLLECTION SELECTOR EXPRESSIONS

Grammar:

    <collection_selector_expr> ::=
          <Array>
        | <Set>
        | <Bag>
        | <Tuple>
        | <Tuple_Array>
        | <Relation>
        | <Tuple_Bag>
        | <Capsule>
        | <Excuse>

A C<< <collection_selector_expr> >> is an C<< <expr> >> that denotes a
value literal specific to some system-defined data type that has its own
special Muldis D Entry Notation selector syntax, and this literal syntax
explicitly does have child C<< <expr> >> nodes in the general case, as in
conventional terms it is for selecting values representing collections of
other values.

=head2 Array Selectors

Grammar:

    <Array> ::=
        ['\\~' <sp>]? <ord_member_commalist>

    <ord_member_commalist> ::=
        '[' <sp> <member_commalist> <sp> ']'

An C<< <Array> >> node represents a value of the Muldis D
C<Array> type, which is ...

=head2 Set Selectors

Grammar:

    <Set> ::=
        ['\\?' <sp>]? <nonord_member_commalist>

A C<< <Set> >> node represents a value of the Muldis D
C<Set> type, which is ...

A C<< <Set> >> is subject to the additional rule that, either its C<<
<member_commalist> >> must not have any C<< <multiplied_member> >>
elements, or the C<< <Set> >> must have the C<\?> prefix, so that the C<<
<Set> >> can be distinguished from every possible C<< <Bag> >>.

=head2 Bag Selectors

Grammar:

    <Bag> ::=
        ['\\+' <sp>]? <nonord_member_commalist>

    <nonord_member_commalist> ::=
        '{' <sp> <member_commalist> <sp> '}'

    <member_commalist> ::=
        [<single_member> | <multiplied_member> | ''] % [<sp> ',' <sp>]

    <single_member> ::=
        <member_expr>

    <multiplied_member> ::=
        <member_expr> <sp> ':' <sp> <multiplicity_expr>

    <member_expr> ::=
        <expr>

    <multiplicity_expr> ::=
        <expr>

A C<< <Bag> >> node represents a value of the Muldis D
C<Bag> type, which is ...

A C<< <Bag> >> is subject to the additional rule that, either its C<<
<member_commalist> >> must have at least 1 C<< <multiplied_member> >>
element, or the C<< <Bag> >> must have the C<\+> prefix, so that the C<<
<Bag> >> can be distinguished from every possible C<< <Set> >>.  An
idiomatic way to represent an empty C<Bag> is to have exactly 1 C<<
<multiplied_member> >> whose C<< <multiplicity_expr> >> is zero.

=head2 Tuple Selectors

Grammar:

    <Tuple> ::=
        ['\\%' <sp>]? '(' <sp> <attr_commalist> <sp> ')'

    <attr_commalist> ::=
        [<anon_attr> | <named_attr> | <nested_named_attr> | ''] % [<sp> ',' <sp>]

    <anon_attr> ::=
        <attr_asset_expr>

    <named_attr> ::=
        <attr_name> <sp> ':' <sp> <attr_asset_expr>

    <nested_named_attr> ::=
        <nesting_attr_names> <sp> ':' <sp> <attr_asset_expr>

    <attr_asset_expr> ::=
        <expr>

A C<< <Tuple> >> node represents a value of the Muldis D
C<Tuple> type, which is ...

A C<< <Tuple> >> is subject to the additional rule that, iff its
C<< <attr_commalist> >> has exactly 1 C<< <*_attr> >> element, either that
element must have a leading or trailing comma, or the C<< <Tuple> >> must
have the C<\%> prefix, so that the C<< <Tuple> >> can be distinguished from
every possible C<< <Capsule> >> and C<< <delimiting_expr> >>.

=head2 Tuple-Array Selectors

Grammar:

    <Tuple_Array> ::=
        '\\~%' <sp> [<delim_attr_name_commalist> | <ord_member_commalist>]

A C<< <Tuple_Array> >> node represents a value of the Muldis D
C<Tuple_Array> type, which is ...

A C<< <Tuple_Array> >> with an C<< <ord_member_commalist> >> is subject to
the additional rule that its C<< <member_commalist> >> has at least 1 C<<
<*_member> >> element; otherwise the C<< <Tuple_Array> >> must have a C<<
<delim_attr_name_commalist> >>.

=head2 Relation Selectors

Grammar:

    <Relation> ::=
        '\\?%' <sp> [<delim_attr_name_commalist> | <nonord_member_commalist>]

A C<< <Relation> >> node represents a value of the Muldis D
C<Relation> type, which is ...

A C<< <Relation> >> with a C<< <nonord_member_commalist> >> is subject to
the additional rule that its C<< <member_commalist> >> has at least 1 C<<
<*_member> >> element; otherwise the C<< <Relation> >> must have a C<<
<delim_attr_name_commalist> >>.

=head2 Tuple-Bag Selectors

Grammar:

    <Tuple_Bag> ::=
        '\\+%' <sp> [<delim_attr_name_commalist> | <nonord_member_commalist>]

A C<< <Tuple_Bag> >> node represents a value of the Muldis D
C<Tuple_Bag> type, which is ...

A C<< <Tuple_Bag> >> with a C<< <nonord_member_commalist> >> is subject to
the additional rule that its C<< <member_commalist> >> has at least 1 C<<
<*_member> >> element; otherwise the C<< <Tuple_Bag> >> must have a C<<
<delim_attr_name_commalist> >>.

=head2 Capsule Selectors

Grammar:

    <Capsule> ::=
        ['\\:' <sp>]? '(' <sp> <c_label_expr> <sp> ':' <sp> <c_attrs_expr> <sp> ')'

    <c_label_expr> ::=
        <expr>

    <c_attrs_expr> ::=
        <expr>

A C<< <Capsule> >> node represents a value of the Muldis D
C<Capsule> type, which is ...

Examples:

    (\Fraction : (numerator : 5, denominator : 3))

=head2 Excuse Selectors

Grammar:

    <Excuse> ::=
        '\\!' <sp> '(' <sp> <attr_commalist> <sp> ')'

An C<< <Excuse> >> node represents a value of the Muldis D
C<Excuse> type, which is ...

=head1 LANGUAGE MNEMONICS

Muldis D Entry Notation is designed to respect a variety of mnemonics that
bring it some self-similarity and an association between syntax and
semantics so that it is easier to read and write Muldis D code.  Some of
these mnemonics are more about self-similarity and others are more about
shared traits with other languages.

I<TODO.>

    : - key/asset separator in most pairwise collections
    ? - booleans or sets (and bits and relations) or some predicate eg for existence or non-excuses
    + - numbers or bags (and octets and tuple-bags) or element insertion
    - - numbers or element removal or set/interval exclusion
    ~ - arrays (and text and bits and blob and tuple-arrays)
    | - homogeneous collections of any type (arrays or sets or bags)
    % - heterogeneous collections / tuples or homos of tuples (relations and tuple-bags and tuple-arrays)
    @ - attr names or headings (and chain-identifiers and renamings)
    \ - value literal or selector (or source attr accessor)
    & - variables
    ! - booleans or excuses
    . - collection item accessor or existence test
    = - association of 2 things, either for comparison or binding or assignment

    [] - homogeneous ordered collection of element - arrays/statements/etc - ordinal+universal
    {} - homogeneous nonordered collection of member - bags/sets/etc - universal+ordinal
    () - heterogeneous aordered collection of attr - tuples - nominal+universal

When combining symbols to represent both collection type and element type,
show collection first as master and element next as subservient,
so eg ?% is relation, +% is tuple-bag while ~+ is blob
or ?| is set, +| is bag while ~| is array.

=head1 STRATEGIES FOR PARSING

I<TODO.  Meanwhile see this section in Muldis D Plain Text.>

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::See_Also> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the B<Muldis D Entry Notation>
(B<MDEN>) primary component of the B<Muldis D> language specification.

MDEN is Copyright © 2002-2017, Muldis Data Systems, Inc.

L<http://www.muldis.com/>

MDEN is free documentation for software; you can redistribute it and/or
modify it under the terms of the Artistic License version 2 (AL2) as
published by the Perl Foundation (L<http://www.perlfoundation.org/>).  You
should have received copies of the AL2 as part of the MDEN
distribution, in the file named "LICENSE/artistic-2_0.txt"; if not, see
L<http://www.perlfoundation.org/attachment/legal/artistic-2_0.txt>.

Any versions of MDEN that you modify and distribute must carry prominent
notices stating that you changed the files and the date of any changes, in
addition to preserving this original copyright notice and other credits.

While it is by no means required, the copyright holder of MDEN would
appreciate being informed any time you create a modified version of MDEN
that you are willing to distribute, because that is a practical way of
suggesting improvements to the standard version.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
