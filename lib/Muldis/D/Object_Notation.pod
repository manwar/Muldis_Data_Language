=pod

=encoding utf8

=head1 NAME

Muldis::D::Object_Notation -
Muldis D concrete syntax for source code

=head1 VERSION

This document is Muldis::D::Object_Notation version 0.201.0.-9.

=head1 DESCRIPTION

This document is the human readable authoritative formal specification of
the B<Muldis D Object Notation> (B<MDON>) primary component of the B<Muldis D>
language.  The fully-qualified name of this document and the specification
it contains is C<Muldis_D_Object_Notation 'http://muldis.com' '0.201.0.-9'>.

See also L<Muldis::D> to read the B<Muldis D> language meta-specification.

The B<Muldis D Object Notation> specification defines the grammar of the
smaller of the two official concrete Muldis D language syntaxes that every
non-trivial Muldis D implementation should reasonably support as options.
However, B<Muldis D Object Notation> is the only syntax for which support by
every Muldis D implementation is considered mandatory; this is justified by
the syntax being relatively simple and easy to implement and by its grammar
being much more likely to be stable over time.  B<Muldis D Object Notation>
is intended to be the primary standard format of interchange of both code
and data between all Muldis D implementations.  B<Muldis D Object Notation>
is expressly a proper subset of the B<Muldis D Plain Text> syntax and the
latter is expressly a proper superset of the former.

This document defines the grammar that all non-hosted plain-text Muldis D
source code must conform to when it claims to be written in the
C<Muldis_D Object_Notation 'http://muldis.com' '0.201.0.-9'> (B<MDON>) language.

This grammar is meant to be more illustrative to human readers than
executable, as is typical for standards documents; you wouldn't likely be
able to just hand if off to a parser-generator and expect it to work as is.
But it should still have enough information to derive an executable parser.

Note that the standard filename extension for files with such source code
is C<.mdpt>, though as per standard UNIX conventions, such Muldis D source
code files can in fact have any filename extension when there is other
context to interpret them with.  Filename extensions are more for the
benefit of the operating system or command shell or users than for a Muldis
D implementation, the latter just cares about the content of the file.

The B<Muldis D Object Notation> specification prizes brevity more greatly
than the other components of the B<Muldis D> language meta-specification.
As such, it avoids explaining a lot of things directly, either because they
are implied, or because the B<Muldis D Plain Text> superset specification
can explain those things once for both official grammars; see
L<Muldis::D::Plain_Text> for some further explanation when desired.

=head1 PARSING UNITS

A I<parsing unit> of Muldis D Object Notation source code is composed of two
main parts, the I<parsing unit subject> and the I<parsing unit predicate>,
in this context abbreviated as I<subject> and I<predicate>.

A I<parsing unit subject> is the meat-and-potatoes of Muldis D Object Notation
source code, and generally takes the form in memory of a Muldis D C<Blob>
or C<Text> value I<S>; parsing a well-formed I<S> results in some other
Muldis D value I<N>.  Typically I<N> is a value of the C<Package> type and
thus comprises a Muldis D I<compilation unit>, but it might also be a value
of some other type.

A I<parsing unit predicate> is a guide for I<how> to unambiguously parse
the I<subject>, and generally takes the form in memory of a Muldis D
C<Blob> or C<Text> value; it includes such details as a grammar version
declaration and a text encoding declaration.

When Muldis D Object Notation source code is kept in its own self-describing
file, typically one with the C<.mdpt> standard filename extension, as per
library or project conventions for typical general-purpose programming
languages or structured data files, the entire I<parsing unit> is combined
into the single file, with the I<parsing unit predicate> appearing first as
a file heading, and the I<parsing unit subject> following that.

In this combined-file situation, a primary role of the I<predicate> is to
serve as a "magic number" that identifies the file as being MDON source
code.  Its secondary role is to explicitly state the character encoding and
similar details of the file so that the file can be correctly converted
from octets (a C<Blob>) to character data (a C<Text>) which most of the
MDON grammar assumes it is taking as input; this means the parser does not
have to rely on hueristics or other methods of determining encoding that
could be wrong.  Its tertiary role is to explicitly state what versions of
the MDON grammar the author of the MDON code believes it is known to be
compatible or incompatible with, so that the grammar can be more free to
evolve without that leading to parsers wrongly interpreting code.

When Muldis D Object Notation source code is not kept in its own self-describing
file, typically when a source code repository is in use that provides
context externally to each I<parsing unit subject> on how to interpret it,
then the I<subject> and I<predicate> are typically given to the parser as
separate inputs.  This is particularly likely in situations where the
virtual machine environment running the Muldis D code is a library of some
host language that is feeding in Muldis D code piecemeal (possibly
generated), such as a typical DBMS client application may do.  Such uses
would be served by not having to provide the I<predicate> boilerplate every
time they want to run I<subject> code, which often is very small itself.

The root grammar token for Muldis D Object Notation is C<< <MDON> >>.

The root grammar token for a Muldis D Object Notation self-describing file
is C<< <parsing_unit> >>.

The root grammar token for a Muldis D Object Notation
I<parsing_unit_predicate> in isolation is C<< <parsing_unit_predicate> >>.

The root grammar token for a Muldis D Object Notation
I<parsing_unit_subject> in isolation is C<< <parsing_unit_subject> >>.

Grammar:

    <MDON> ::=
        ^ <parsing_unit> | <parsing_unit_predicate> | <parsing_unit_subject> $

    <parsing_unit> ::=
        <shebang_line>? <sp> <parsing_unit_predicate> <sp> <parsing_unit_subject>

See the sections in this file named L<SHEBANG LINE>,
L<PARSING UNIT PREDICATES>, and L</PARSING UNIT SUBJECTS> for more details.

=head1 SHEBANG LINE

Grammar:

    <shebang_line> ::=
        '#!' <shebang_directive> <shebang_whitespace_break>

    <shebang_directive> ::=
        ...

    <shebang_whitespace_break> ::=
        ...

A C<< <shebang_line> >>, if it exists, must be the first characters of the
text file, and consists of a magic number which expressed as ASCII or UTF-8
is C<#!>, followed by a Unix-like interpreter directive or path to an
executable that can interpret Muldis D Object Notation files.  When a Muldis D
Object Notation file starts with a shebang line, it can be invoked directly as
if it were an executable on a Unix-like system.  The format of
C<< <shebang_directive> >> isn't defined in this document; see the appropriate
external Unix/etc documentation for that; however, the Muldis D Object Notation
file must have at least one line-breaking whitespace character of some kind
following it, which is how we know where the Muldis D code begins.

Examples:

    #!/usr/bin/env muldisdre

=head1 PARSING UNIT PREDICATES

Grammar:

    <parsing_unit_predicate> ::=
        <language_name>
        <sp>
        <script_name>

See the sections in this file named L</LANGUAGE NAME> and L</SCRIPT NAME>
for more details.

=head1 LANGUAGE NAME

Grammar:

    <language_name> ::=
        <ln_family_name>
        <sp>
        <ln_syntax_name>
        <sp>
        <ln_authority>
        <sp>
        <ln_version_number>

    <ln_family_name> ::=
        Muldis_D

    <ln_syntax_name> ::=
        Object_Notation

    <ln_authority> ::=
        <Text_seg>

    <ln_version_number> ::=
        <Text_seg>

As per the VERSIONING section of L<Muldis::D>, every source code or data
expression as Muldis D Object Notation must be accompanied by an explicit
declaration that it is MDON, and specify at least 1 version of the MDON
standard that its author intends that it conforms with; this declaration is
called a fully-qualified I<language name> and serves as a "magic number".

Examples:

    Muldis_D Object_Notation 'http://muldis.com' '0.201.0.-9'

    Muldis_D Object_Notation 'http://example.com' '42'

=head1 SCRIPT NAME

Grammar:

    <script_name> ::=
        meta script <Text_seg>

The C<< <script_name> >> indicates the primary script of the Muldis D code,
meaning is character repertoire and/or character encoding and/or character
normalization.  Under the assumption that a C<Muldis_D Object_Notation> parser
might be reading the source code as binary data or otherwise as
unnormalized character data, declaring the I<script name> makes it completely
unambiguous as to what characters it is to be treating the input as.

For a simple example, a I<script name> of C<ASCII> says every literal source
code character is a 7-bit ASCII character (and representing any non-ASCII
characters is being done with escape sequences), and this is recommended
for any C<Muldis_D Object_Notation> file that doesn't need to be something else.
For various legacy 8-bit formats the I<script name> can tell us if we're using
C<Latin1> or C<CP1252> or C<EBCDIC> etc.  For Unicode the I<script name> would
have multiple parts, such as C<Unicode(10.0,UTF-8,canon)>, indicating
expected repertoire, and encoding (useful more with ones lacking BOMs); but
at the very least it is useful with normalization; if C<compat> is declared
then the source code is folded before it is parsed so possibly distinct
literal characters in the original code are seen as identical character
strings by the main parser, while C<canon> would not do this folding.

A Muldis D parser would possibly scan through the same source code multiple
times filtering by a variety of text encodings until it can read a Muldis D
language name declaring the same encoding that the name is itself written
in, and then from that point it would expect the whole file to be that
declared encoding or it would consider the code invalid.

Examples:

    meta script 'ASCII'

    meta script 'Unicode 10.0 UTF-8 canon'

=head1 PARSING UNIT SUBJECTS

Grammar:

    <parsing_unit_subject> ::=
        <expr>

    <expr> ::=
        <opaque_literal_expr> | <collection_selector_expr>

See the sections in this file named L</OPAQUE LITERAL EXPRESSIONS>
and L</COLLECTION SELECTOR EXPRESSIONS> for more details.

=head1 CHARACTER CLASSES

Grammar:

    <enumerated_char> ::=
          <alphanumeric_char>
        | <quoting_char>
        | <bracketing_char>
        | <symbolic_char>
        | <whitespace_char>
        | <illegal_char>

    <alphanumeric_char> ::=
        <alpha_char> | <digit_char>

    <alpha_char> ::=
        <[ A..Z _ a..z ]>

    <digit_char> ::=
        <[ 0..9 ]>

    <quoting_char> ::=
        <["'`]>

    <bracketing_char> ::=
        '(' | ')' | '[' | ']' | '{' | '}'

    <symbolic_char> ::=
        <special_symbolic_char> | <regular_symbolic_char>

    <special_symbolic_char> ::=
        ',' | ':' | ';' | '\\'

    <regular_symbolic_char> ::=
          '!' | '#' | '$' | '%' | '&' | '*' | '+' | '-' | '.' | '/'
        | '<' | '=' | '>' | '?' | '@' | '^' | '|' | '~'

    <whitespace_char> ::=
        <ws_unrestricted_char> | <ws_restricted_outside_char>

    <ws_unrestricted_char> ::=
        ' '

    <ws_restricted_outside_char> ::=
        '\t' | '\n' | '\r'

    <illegal_char> ::=
        <[ \x<0>..\x<8> \x<B>..\x<C> \x<E>..\x<1F> \x<80>..\x<9F> ]>

    <unrestricted_char> ::=
          <alphanumeric_char>
        | <bracketing_char>
        | <symbolic_char>
        | <ws_unrestricted_char>

    <restricted_outside_char> ::=
        <unrestricted_char> | <ws_restricted_outside_char>

    <restricted_inside_char> ::=
        <-quoting_char -illegal_char -ws_restricted_outside_char>

The Muldis D Object Notation grammar recognizes 7 distinct character codepoint
(hereafter referred to as I<character>) classes,
which are mutually disjoint proper subsets of the character repertoire
identified by the I<script name>: I<alphanumeric>, I<quoting>, I<bracketing>,
I<symbolic>, I<whitespace>, I<illegal>, I<nonenumerated>; the first 6 are
collectively I<enumerated>.

The first 5 I<enumerated> classes (all but I<illegal>) are the more
syntactically interesting ones and are generally what the grammar are
defined in terms of.

Broadly speaking, Muldis D Object Notation code is made up of 2 primary
grammatical contexts which are mutually disjoint and complementary; one of
these is anywhere I<outside> all quoted strings, and its complement is
anywhere I<inside> any quoted string; it is the I<quoting> characters that
mark the transition between these 2 contexts.  Broadly speaking, all of the
I<enumerated> classes (except I<illegal>) represent characters that are
I<unrestricted> and may appear anywhere in Object Notation source code.  In
contrast, I<nonenumerated> characters may only appear literally
inside of a quoted string, and I<illegal> characters may not appear
literally in source code at all.

All characters of the ASCII repertoire are I<enumerated>; loosely speaking,
all printable ASCII characters are I<unrestricted>, as
are the small number of non-printable ASCII characters named in C<<
<whitespace_char> >>; all other (non-printable) ASCII characters are
I<illegal>.

All non-ASCII Unicode characters are I<restricted> to appearing literally
inside of a quoted string, except that non-ASCII Unicode control characters
are I<illegal>.

Regardless of character class, all characters may be logically represented
in terms of character escape sequences, but only inside of a quoted string.

Note that the primary reason most enumerated whitespace characters are
generally restricted from being inside of a quoted string is so that the
Muldis D Object Notation code is resilient to passage through environments that
might have different native line-breaking characters; the restriction
guarantees that executing the code will produce logically identical values
and behaviour for character string literals or quoted identifiers.  In
contrast, changing the line-breaking whitespace outside of string literals
is okay and doesn't change behavior, so code can be formatted with them.

=head1 ESCAPED CHARACTERS

Grammar:

    <escaped_char> ::=
          '\\q' | '\\a' | '\\g'
        | '\\b'
        | '\\t' | '\\n' | '\\r'
        | ['\\c<' <asigned_int> '>']

The meanings of the simple character escape sequences are:

    Esc | Unicode   | Unicode         | Chr | Literal character used
    Seq | Codepoint | Character Name  | Lit | for when not escaped
    ----+-----------+-----------------+-----+------------------------------
    \q  | 0x22      | QUOTATION MARK  | "   | delimit quoted names
    \a  | 0x27      | APOSTROPHE      | '   | delimit Text/opaque literals
    \g  | 0x60      | GRAVE ACCENT    | `   | delimit dividing space comments
    \b  | 0x5C      | REVERSE SOLIDUS | \   | no special meaning in non-escaped
    \t  | 0x9       | CHAR... TAB...  |     | control char horizontal tab
    \n  | 0xA       | LINE FEED (LF)  |     | ctrl char line feed / newline
    \r  | 0xD       | CARR. RET. (CR) |     | control char carriage return

There is currently just one complex escape sequence, of the format C<<
\c<...> >>, that supports specifying characters in terms of their Unicode
abstract codepoint number.  One reason for this feature is to empower more
elegant passing of Unicode-savvy Object_Notation source code through a
communications channel that is more limited, such as to 7-bit ASCII.

Examples:

    \a

    \n

    \c<0x263A>

    \c<65>

Note that Object_Notation eschews built-in support for a C<< \c<...> >> format
that specifies characters in terms of their Unicode character name, for
example C<< \c<LATIN SMALL LETTER OU> >>.  Instead, it is left to the
domain of non-core Muldis D packages to support such a feature.  The main
reason for this is to avoid an unconditionally-mandatory complex dependency
that is the Unicode character database.

=head1 DIVIDING SPACE

Grammar:

    <sp> ::=
        [<whitespace> | <quoted_sp_comment_str>]*

    <whitespace> ::=
        <whitespace_char>+

    <quoted_sp_comment_str> ::=
        '`' <-[`]>* '`'

The primary function of I<dividing space>, represented by C<< <sp> >>, is
to disambiguate the boundaries of otherwise-consecutive grammar tokens.

Once Muldis D Object Notation code is parsed, any dividing space is just
discardable non-semantic metadata for its wider context, but during a parse
its presence is often critical to properly interpret the wider context.

The grammar doesn't specify this explicitly for simplicity, but anywhere a
C<< <sp> >> token appears, it should be interpreted as carrying a number of
look-around assertions regarding adjacent tokens.

In the context of any C<< <foo> <sp> <bar> >>, these syntax rules apply:

=over

=item *

If C<< <foo> >> and C<< <bar> >> are of different character classes
(alphanumeric vs quoting vs bracketing vs symbolic vs whitespace) then C<<
<sp> >> is allowed to be empty.

=item *

Otherwise, if C<< <foo> >> and C<< <bar> >> are both alphanumeric then C<<
<sp> >> must be nonempty.

=item *

Otherwise, if C<< <foo> >> and C<< <bar> >> are both quoting or bracketing
or whitespace then C<< <sp> >> is allowed to be empty.

=item *

Otherwise, C<< <foo> >> and C<< <bar> >> are both symbolic; whether or not
C<< <sp> >> is allowed to be empty or not depends on the specific sequence
of symbolic characters in the original source code, as described by the
subsequent syntax rules.

=item *

If either C<< <foo> >> or C<< <bar> >> or both are either C<,> or C<;> or
C<\> then C<< <sp> >> is allowed to be empty.

=item *

Otherwise, if exactly one of C<< <foo> >> or C<< <bar> >> is C<:> and the
other doesn't have that character then C<< <sp> >> is allowed to be empty.

=item *

Otherwise, C<< <sp> >> must be nonempty.

=back

The secondary function of I<dividing space> is to empower users to format
their code for easier readability through appropriate linebreaks,
indentation, and other kinds of spacing, as they see fit; what they choose
here has no impact on the behavior of the code.

The tertiary function of I<dividing space> is to empower the placement of
code comments or visual dividers almost anywhere, but with the caveat that
comments written this way are not introspectable as comments in the parsed
code, and rather are treated like insignificant whitespace.  This style of
comment defined with backtick-quoted strings should just be used for the
likes of visual dividers or less important comments or for when you want to
quickly "comment out" some source code rather than deleting it.

For more important comments that are introspectable as such, they need to
be written as regular value literals or selectors.

Examples:

    `This does something.`

=head1 OPAQUE LITERAL EXPRESSIONS

Grammar:

    <opaque_literal_expr> ::=
          <Boolean>
        | <Integer>
        | <Fraction>
        | <Bits>
        | <Blob>
        | <Text>
        | <Simple_Excuse>
        | <Attr_Name>
        | <Heading>
        | <Attr_Name_List>

An C<< <opaque_literal_expr> >> is an C<< <expr> >> that denotes a value
literal specific to some system-defined data type that has its own special
Muldis D Object Notation selector syntax, and this literal syntax explicitly has
no child C<< <expr> >> nodes.  In conventional terms, one is typically for
selecting scalar values, though many cases are also simple collections.

=head2 Boolean Literals

Grammar:

    <Boolean> ::=
        ['\\?' <sp>]? [False | True]

A C<< <Boolean> >> node represents a value of the Muldis D C<Boolean> type,
which is a general purpose 2-valued logic boolean or I<truth value>.  The
C<Boolean> type is a foundational type of the Muldis D type system, and
this is the canonical grammar for them.

Examples:

    False

    True

    \?False

    \?True

=head2 Integer Literals

Grammar:

    <Integer> ::=
        <nonquoted_int> | <quoted_int>

    <nonquoted_int> ::=
        ['\\+' <sp>]? <asigned_int>

    <quoted_int> ::=
        <qu_num_head> <qu_asigned_int> <qu_num_tail>

    <qu_num_head> ::=
        '\\+' <sp> '\''

    <qu_asigned_int> ::=
        <asigned_int> <qu_num_mid>?

    <qu_num_mid> ::=
        <num_seg> % <qu_num_sp>

    <qu_num_sp> ::=
        '\'' <sp> '\''

    <qu_num_tail> ::=
        '\''

    <asigned_int> ::=
        <num_sign>? <nonsigned_int>

    <num_sign> ::=
        '+' | '-'

    <nonsigned_int> ::=
        <num_radix_mark>? <num_seg>

    <num_radix_mark> ::=
        0 <[bodx]>

    <num_seg> ::=
        <num_char>+

    <num_char> ::=
        <nc2> | <nc8> | <nc10> | <nc16>

    <nc2> ::=
        <[ 0..1 _ ]>

    <nc8> ::=
        <[ 0..7 _ ]>

    <nc10> ::=
        <[ 0..9 _ ]>

    <nc16> ::=
        <[ 0..9 A..F _ a..f ]>

An C<< <Integer> >> node represents a value of the Muldis D C<Integer>
type, which is a general purpose exact integral number of any magnitude,
which explicitly does not represent any kind of thing in particular,
neither cardinal nor ordinal nor nominal.  The C<Integer> type is a
foundational type of the Muldis D type system, and this is the canonical
grammar for them.

This grammar supports writing C<Integer> literals in any of the numeric
bases {2,8,10,16} using conventional syntax.  The literal may optionally
contain underscore characters (C<_>), which exist just to help with visual
formatting, such as for C<10_000_000>.

This grammar is subject to the following additional rules:

=over

=item *

If C<< <num_radix_mark> >> is omitted or is C<0d> then every
C<< <num_char> >> must be a C<< <nc10> >>.

=item *

Otherwise, if C<< <num_radix_mark> >> is C<0b> or C<0o> or C<0x> then every
C<< <num_char> >> must be a C<< <nc2> >> or C<< <nc8> >> or C<< <nc16> >>
respectively.

=back

A quoted C<< <Integer> >> may optionally be split into 1..N quoted segments
where each pair of consecutive segments is separated by dividing space;
this segmenting ability is provided to support code that contains very long
numeric literals while still being well formatted (no extra long lines).

Note that the general grammar rules of Muldis D Object Notation will treat all
nonquoted symbolic characters {-,+,.,/} as I<fixed> operator invocations,
and nonquoted digit sequences as positive integer literals.  However,
nonquoted numeric literals have a special exception for {-,+,.,/} iff they
appear in very specific places, such that those symbolics are treated as
part of a numeric literal instead of an operator call.  This is done so
that all values of the core numeric types can be written in a clean and
concise manner while avoiding any risk of the meanings of the literals
changing depending what Muldis D packages are in scope, which would be the
case if the symbolics were parsed as operator calls.  When writing Muldis D
Object Notation code with unquoted numeric literals, having dividing space
between any {-,+,.,/} and any C<< <num_char> >> should guarantee their
interpretation as an operator call, while ensuring no dividing space
between them should guarantee interpretation as part of the literal iff the
symbolics are in specific positions expected for the latter.  This special
exception breaks the general grammar rule where symbolics and alphanumerics
are always considered separate tokens regardless of whether or not there is
dividing space between them, however that is considered a lesser surprise.

Examples:

    42

    0

    -3

    \+'-3' '50_897'

    \+81

    0d39

    0xDEADBEEF

    0o644

    0b11001001

=head2 Fraction Literals

Grammar:

    <Fraction> ::=
        <nonquoted_frac> | <quoted_frac>

    <nonquoted_frac> ::=
        <nonquoted_int> <frac_div> <num_seg>

    <quoted_frac> ::=
        <qu_num_head> <qu_asigned_int> <frac_div> <qu_num_mid> <qu_num_tail>

    <frac_div> ::=
        '.' | '/'

A C<< <Fraction> >> node represents a value of the Muldis D C<Fraction>
type, which is a general purpose exact rational number of any magnitude and
precision, expressible as a coprime I<numerator> / I<denominator> pair of
C<Integer> whose I<denominator> is positive, which explicitly does not
represent any kind of thing in particular, neither cardinal nor ordinal nor
nominal.

The C<Fraction> type is not a foundational type of the Muldis D type
system, but rather is a subtype by constraint of the C<Capsule> type, and
all C<Fraction> values can be selected in terms of C<< <Capsule> >> grammar
nodes.  However, C<< <Fraction> >> is the canonical grammar for all
C<Fraction> values.

An entire C<< <Fraction> >> literal has the same numeric base, both the
part before the C<< <frac_div> >> and the part after it.  When the C<<
<frac_div> >> is a C</>, the literal portion on the left is treated as the
integral I<numerator> and the part on the right as the integral
I<denominator>; the literal allows that pair to not be coprime, and it will
be normalized in the derived C<Fraction> value.  When the C<< <frac_div> >>
is a C<.>, the anormal I<numerator> is determined by treating all of the
C<< <num_char> >> as an integral literal as if the C<.> wasn't there, and
the anormal I<denominator> is determined by taking the numeric base to the
power of the number of C<< <num_char> >> on the right side of the C<.>.

Examples:

    3.14159

    0.0

    5/3

    -4.72

    -472/100

    \+29.95

    0xDEADBEEF.FACE

    -0o35/3

    0b1.1

=head2 Bits Literals

Grammar:

    <Bits> ::=
        '\\~?' <sp> [
              [['\'' ['0b' <nc2>* ]? '\''] % <sp>]
            | [['\'' ['0o' <nc8>* ]? '\''] % <sp>]
            | [['\'' ['0x' <nc16>*]? '\''] % <sp>]
        ]

A C<< <Bits> >> node represents a value of the Muldis D C<Bits> type, which
is an arbitrarily-long sequence of I<bits> where each bit is represented by
an C<Integer> in the range 0..1.

The C<Bits> type is not a foundational type of the Muldis D type system,
but rather is a subtype by constraint of the C<Capsule> type, and all
C<Bits> values can be selected in terms of C<< <Capsule> >> grammar nodes.
However, C<< <Bits> >> is the canonical grammar for all C<Bits> values.

This grammar supports writing C<Bits> literals in any of the numeric bases
{2,8,16} using conventional syntax.  The literal may optionally contain
underscore characters (C<_>), which exist just to help with visual
formatting.  A C<< <Bits> >> may optionally be split into 1..N segments
where each pair of consecutive segments is separated by dividing space.

Examples:

    \~?''

    \~?'0b00101110100010'

    \~?'0o644'

    \~?'0xA705E'

=head2 Blob Literals

Grammar:

    <Blob> ::=
        '\\~+' <sp> [
              [['\'' ['0b' <nc2>* ]? '\''] % <sp>]
            | [['\'' ['0x' <nc16>*]? '\''] % <sp>]
        ]

A C<< <Blob> >> node represents a value of the Muldis D C<Blob> type, which
is an arbitrarily-long sequence of I<octets> where each octet is
represented by an C<Integer> in the range 0..255.

The C<Blob> type is not a foundational type of the Muldis D type system,
but rather is a subtype by constraint of the C<Capsule> type, and all
C<Blob> values can be selected in terms of C<< <Capsule> >> grammar nodes.
However, C<< <Blob> >> is the canonical grammar for all C<Blob> values.

This grammar supports writing C<Blob> literals in any of the numeric bases
{2,16} using conventional syntax.  The literal may optionally contain
underscore characters (C<_>), which exist just to help with visual
formatting.  A C<< <Blob> >> may optionally be split into 1..N segments
where each pair of consecutive segments is separated by dividing space.

This grammar is subject to the following additional rules:

=over

=item *

If the C<< <Blob> >> segments are prefixed by C<0b> then the total count of
C<< <nc2> >> in the C<< <Blob> >> excluding C<_> must be an even multiple
of 8.

=item *

Otherwise, if the C<< <Blob> >> segments are prefixed by C<0x> then the
total count of C<< <nc16> >> in the C<< <Blob> >> excluding C<_> must be an
even multiple of 2.

=back

Examples:

    \~+''

    \~+'0xA705E416'

    \~+'0b00101110_10001011'

=head2 Text Literals

Grammar:

    <Text> ::=
        ['\\~' <sp>]? [<Text_seg> % <sp>]

    <Text_seg> ::=
        '\'' <qnots_content> '\''

A C<< <Text> >> node represents a value of the Muldis D C<Text> type, which
is characterized by an arbitrarily-long sequence of Unicode 10.0 standard
I<character codepoints>.

The C<Text> type is not a foundational type of the Muldis D type system,
but rather is a subtype by constraint of the C<Capsule> type, and all
C<Text> values can be selected in terms of C<< <Capsule> >> grammar nodes.
However, C<< <Text> >> is the canonical grammar for all C<Text> values.

A C<< <Text> >> may optionally be split into 1..N segments where each pair
of consecutive segments is separated by dividing space.

Examples:

    'Ceres'

    'サンプル'

    ''

    '\This isn\at not escaped.\n'

    '\\c<0x263A>\c<65>'

    \~'Green'

=head2 Simple Excuse Literals

Grammar:

    <Simple_Excuse> ::=
        '\\!' <sp> <attr_name>

A C<< <Simple_Excuse> >> node represents a value of the Muldis D C<Excuse>
type, and provides a terser alternative syntax to an C<< <Excuse> >> node
for the common special case of C<Excuse> having just the C<0> attribute
where that attribute is valued with an C<Attr_Name>, such as is the case
for all typical Muldis D Foundation defined C<Excuse> subtypes.

Examples:

  \!No_Reason

  \!Before_All_Others

  \!Div_By_Zero

  \!No_Such_Attr_Name

=head2 Attribute Name and Heading Literals

Grammar:

    <Attr_Name> ::=
        '\\' <sp> <attr_name>

    <Heading> ::=
        '\\@' <sp> <delim_attr_name_commalist>

    <delim_attr_name_commalist> ::=
        '(' <sp> <attr_name_commalist> <sp> ')'

    <attr_name_commalist> ::=
        [<attr_name> | <ord_attr_name_range> | ''] % [<sp> ',' <sp>]

    <ord_attr_name_range> ::=
        <min_ord_attr> <sp> '..' <sp> <max_ord_attr>

    <min_ord_attr> ::=
        <ord_attr_name>

    <max_ord_attr> ::=
        <ord_attr_name>

A C<< <Heading> >> node represents a value of the Muldis D
C<Heading> type, which is an arbitrarily-large unordered collection of
attribute names.  An C<< <Attr_Name> >> node represents a value of the Muldis
D C<Attr_Name> type, which is a subtype by constraint of the C<Heading>
type; C<< <Attr_Name> >> provides a terser alternative syntax for the
common special case of C<< <Heading> >> having exactly 1 attribute.

An C<< <ord_attr_name_range> >> is subject to the additional rule that its
integral C<< <min_ord_attr> >> value must be less than or equal to its
integral C<< <max_ord_attr> >> value.

The C<Heading> type is not a foundational type of the Muldis D type
system, but rather is a subtype by constraint of the C<Tuple> type, and all
C<Heading> values can be selected in terms of C<< <Tuple> >> grammar
nodes.  However, C<< <Heading> >> is the canonical grammar for all
C<Heading> values, except for all C<Attr_Name> values, for which
C<< <Attr_Name> >> is the canonical grammar.

Examples:

    `Zero attributes.`
    \@()

    `One named attribute.`
    \sales

    `Same thing.`
    \@(sales)

    `Same thing.`
    \@("sales")

    `One ordered attribute.`
    \0

    `Same thing.`
    \"\\c<0>"

    `Three nonordered attributes.`
    \@(region,revenue,qty)

    `Three ordered attributes.`
    \@(0..2)

    `One of each.`
    \@(1,age)

    `Some attribute names can only appear quoted.`
    \"Street Address"

    `A non-Latin name.`
    \"サンプル"

=head2 Attribute Name List Literals

Grammar:

    <Attr_Name_List> ::=
        '\\@' <sp> <nesting_attr_names>

An C<< <Attr_Name_List> >> node represents a value of the Muldis D C<Attr_Name_List>
type, which is an arbitrarily-long sequence of C<Attr_Name> values.  It
typically serves as a (fully or partially) qualified identifier for referencing
either a foundation entity, or a package or component of the latter, from
the perspective of an entity in a (possibly same) package using it.

The C<Attr_Name_List> type is not a foundational type of the Muldis D type
system, but rather is a subtype by constraint of the C<Array> type, and all
C<Attr_Name_List> values can be selected in terms of C<< <Array> >> grammar
nodes.  However, C<< <Attr_Name_List> >> is the canonical grammar for all
C<Attr_Name_List> values.

Examples (comments refer to their Muldis-D runtime specific interpretation):

    `The Muldis D Foundation function Integer_plus, from any perspective.`
    \@foundation::Integer_plus

    `The system-defined "Relation" type, from the perspective of some other
    package that "uses" the "System" package under the local alias "MD".`
    \@used::MD::Relation

    `Some user-defined "main" procedure, from the perspective of the same
    package as that which it is defined in.`
    \@package::main

    `Some entity "foo" that has the same parent folder as the observer.`
    \@folder::foo

    `Some material from its own perspective, such as for self-recursion.`
    \@material

    `Same "Relation" as above iff \@used::MD is among in the declared
    "floating" list of the same observer's package.`
    \@floating::Relation

    `Same thing, after post-processing.`
    \@Relation

=head1 COLLECTION SELECTOR EXPRESSIONS

Grammar:

    <collection_selector_expr> ::=
          <Array>
        | <Set>
        | <Bag>
        | <Tuple>
        | <Tuple_Array>
        | <Relation>
        | <Tuple_Bag>
        | <Capsule>
        | <Excuse>

A C<< <collection_selector_expr> >> is an C<< <expr> >> that denotes a
value literal specific to some system-defined data type that has its own
special Muldis D Object Notation selector syntax, and this literal syntax
explicitly does have child C<< <expr> >> nodes in the general case, as in
conventional terms it is for selecting values representing collections of
other values.

=head2 Array Selectors

Grammar:

    <Array> ::=
        ['\\~' <sp>]? <ord_member_commalist>

    <ord_member_commalist> ::=
        '[' <sp> <member_commalist> <sp> ']'

An C<< <Array> >> node represents a value of the Muldis D
C<Array> type, which is ...

=head2 Set Selectors

Grammar:

    <Set> ::=
        ['\\?' <sp>]? <nonord_member_commalist>

A C<< <Set> >> node represents a value of the Muldis D
C<Set> type, which is ...

A C<< <Set> >> is subject to the additional rule that, either its C<<
<member_commalist> >> must not have any C<< <multiplied_member> >>
elements, or the C<< <Set> >> must have the C<\?> prefix, so that the C<<
<Set> >> can be distinguished from every possible C<< <Bag> >>.

=head2 Bag Selectors

Grammar:

    <Bag> ::=
        ['\\+' <sp>]? <nonord_member_commalist>

    <nonord_member_commalist> ::=
        '{' <sp> <member_commalist> <sp> '}'

    <member_commalist> ::=
        [<single_member> | <multiplied_member> | ''] % [<sp> ',' <sp>]

    <single_member> ::=
        <member_expr>

    <multiplied_member> ::=
        <member_expr> <sp> ':' <sp> <multiplicity_expr>

    <member_expr> ::=
        <expr>

    <multiplicity_expr> ::=
        <expr>

A C<< <Bag> >> node represents a value of the Muldis D
C<Bag> type, which is ...

A C<< <Bag> >> is subject to the additional rule that, either its C<<
<member_commalist> >> must have at least 1 C<< <multiplied_member> >>
element, or the C<< <Bag> >> must have the C<\+> prefix, so that the C<<
<Bag> >> can be distinguished from every possible C<< <Set> >>.  An
idiomatic way to represent an empty C<Bag> is to have exactly 1 C<<
<multiplied_member> >> whose C<< <multiplicity_expr> >> is zero.

=head2 Tuple Selectors

Grammar:

    <Tuple> ::=
        ['\\%' <sp>]? <delim_attr_commalist>

    <delim_attr_commalist> ::=
        '(' <sp> <attr_commalist> <sp> ')'

    <attr_commalist> ::=
        [<anon_attr> | <named_attr> | <nested_named_attr> | ''] % [<sp> ',' <sp>]

    <anon_attr> ::=
        <attr_asset_expr>

    <named_attr> ::=
        <attr_name> <sp> ':' <sp> <attr_asset_expr>

    <nested_named_attr> ::=
        <nesting_attr_names> <sp> ':' <sp> <attr_asset_expr>

    <attr_asset_expr> ::=
        <expr>

    <attr_name> ::=
        <nonord_attr_name> | <ord_attr_name>

    <nonord_attr_name> ::=
        <generic_name>

    <ord_attr_name> ::=
        <digit_char>+

    <nesting_attr_names> ::=
        <attr_name> % [<sp> '::' <sp>]

    <generic_name> ::=
        <alphanumeric_name> | <quoted_name>

    <alphanumeric_name> ::=
        <alpha_char> <alphanumeric_char>*

    <quoted_name> ::=
        <quoted_name_seg> % <sp>

    <quoted_name_seg> ::=
        '"' <qnots_content> '"'

    <qnots_content> ::=
        <qns_nonescaped_content> | <qns_escaped_content>

    <qnots_nonescaped_content> ::=
        [<restricted_inside_char-[\\]> <restricted_inside_char>*]?

    <qnots_escaped_content> ::=
        '\\' [<restricted_inside_char-[\\]> | <escaped_char>]*

A C<< <Tuple> >> node represents a value of the Muldis D
C<Tuple> type, which is ...

A C<< <Tuple> >> is subject to the additional rule that, iff its
C<< <attr_commalist> >> has exactly 1 C<< <*_attr> >> element, either that
element must have a leading or trailing comma, or the C<< <Tuple> >> must
have the C<\%> prefix, so that the C<< <Tuple> >> can be distinguished from
every possible C<< <Capsule> >> and C<< <delimiting_expr> >>.

=head2 Tuple-Array Selectors

Grammar:

    <Tuple_Array> ::=
        '\\~%' <sp> [<delim_attr_name_commalist> | <ord_member_commalist>]

A C<< <Tuple_Array> >> node represents a value of the Muldis D
C<Tuple_Array> type, which is ...

A C<< <Tuple_Array> >> with an C<< <ord_member_commalist> >> is subject to
the additional rule that its C<< <member_commalist> >> has at least 1 C<<
<*_member> >> element; otherwise the C<< <Tuple_Array> >> must have a C<<
<delim_attr_name_commalist> >>.

=head2 Relation Selectors

Grammar:

    <Relation> ::=
        '\\?%' <sp> [<delim_attr_name_commalist> | <nonord_member_commalist>]

A C<< <Relation> >> node represents a value of the Muldis D
C<Relation> type, which is ...

A C<< <Relation> >> with a C<< <nonord_member_commalist> >> is subject to
the additional rule that its C<< <member_commalist> >> has at least 1 C<<
<*_member> >> element; otherwise the C<< <Relation> >> must have a C<<
<delim_attr_name_commalist> >>.

=head2 Tuple-Bag Selectors

Grammar:

    <Tuple_Bag> ::=
        '\\+%' <sp> [<delim_attr_name_commalist> | <nonord_member_commalist>]

A C<< <Tuple_Bag> >> node represents a value of the Muldis D
C<Tuple_Bag> type, which is ...

A C<< <Tuple_Bag> >> with a C<< <nonord_member_commalist> >> is subject to
the additional rule that its C<< <member_commalist> >> has at least 1 C<<
<*_member> >> element; otherwise the C<< <Tuple_Bag> >> must have a C<<
<delim_attr_name_commalist> >>.

=head2 Capsule Selectors

Grammar:

    <Capsule> ::=
        ['\\:' <sp>]? '(' <sp> <c_label_expr> <sp> ':' <sp> <c_attrs_expr> <sp> ')'

    <c_label_expr> ::=
        <expr>

    <c_attrs_expr> ::=
        <expr>

A C<< <Capsule> >> node represents a value of the Muldis D
C<Capsule> type, which is ...

Examples:

    (\Fraction : (numerator : 5, denominator : 3))

=head2 Excuse Selectors

Grammar:

    <Excuse> ::=
        '\\!' <sp> <delim_attr_commalist>

An C<< <Excuse> >> node represents a value of the Muldis D
C<Excuse> type, which is ...

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::See_Also> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the B<Muldis D Object Notation>
(B<MDON>) primary component of the B<Muldis D> language specification.

MDON is Copyright © 2002-2017, Muldis Data Systems, Inc.

L<http://www.muldis.com/>

MDON is free documentation for software; you can redistribute it and/or
modify it under the terms of the Artistic License version 2 (AL2) as
published by the Perl Foundation (L<http://www.perlfoundation.org/>).  You
should have received copies of the AL2 as part of the MDON
distribution, in the file named "LICENSE/artistic-2_0.txt"; if not, see
L<http://www.perlfoundation.org/attachment/legal/artistic-2_0.txt>.

Any versions of MDON that you modify and distribute must carry prominent
notices stating that you changed the files and the date of any changes, in
addition to preserving this original copyright notice and other credits.

While it is by no means required, the copyright holder of MDON would
appreciate being informed any time you create a modified version of MDON
that you are willing to distribute, because that is a practical way of
suggesting improvements to the standard version.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
