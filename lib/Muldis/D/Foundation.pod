=pod

=encoding utf8

=head1 NAME

Muldis::D::Foundation -
Fundamental low-level data types and operators of Muldis D

=head1 VERSION

This document is Muldis::D::Foundation version 0.201.0.-9.

=head1 DESCRIPTION

This document is the human readable authoritative formal specification of
the B<Muldis D Foundation> (B<MDF>) primary component of the B<Muldis D>
language.  The fully-qualified name of this document and the specification
it contains is C<Muldis_D:Foundation:"http://muldis.com":"0.201.0.-9">.

See also L<Muldis::D> to read the B<Muldis D> language meta-specification.

I<TODO, overhaul/refactor this document.>

=head1 FUNDAMENTAL CONCEPTS

The most fundamental concepts of Muldis D are I<values>, I<variables>,
I<functions>, and I<procedures>.

A I<value> is an individual constant that is not fixed in time or space.
Every value is unique, eternal, and immutable; it has no address and can
not be updated.  It does not make sense to say that you are creating or
destroying or copying or mutating a I<value>, but it does make sense to say
you are I<selecting> one.  So when one appears to be testing 2 values for
equality, they are actually testing whether 2 value appearances are in fact
the same value.  Every conceivable distinct concept can be represented by a
value, whether it is a simple number or an arbitrarily complex collection.
For every value there exists at least one I<selector> by means of which
that value may manifest within a program; each selector takes the form of
either a function or a value literal syntax.

A I<variable> is a container for an appearance of a value.  It is neither
unique nor eternal nor immutable in the typical case; it does have an
address and in the typical case can be updated, meaning that over time a
variable may hold appearances of different values.  A variable can be
created, destroyed, copied, and mutated.

A I<function> is a set of instructions for mapping a set of values to a set
of values in a pure and deterministic manner.

A I<procedure> is a set of instructions for either enacting possibly
non-deterministic change over time in a set of variables or for reading
from or writing to the external environment of the application, including
its users or various external systems.

All other Muldis D concepts relate directly to or are defined in terms of
those 4, including I<types>, I<contracts>, I<packages>, I<constants>,
I<databases>, I<expressions>, I<statements>, and so on.

=head1 ENVIRONMENT

The Muldis D DBMS / virtual machine, which by definition is the environment
in which Muldis D executes, conceptually resembles a hardware PC, having
command processors (CPUs), standard user input and output channels,
persistent read-only memory (ROM), volatile read-write memory (RAM), and
persistent read-write disk or network storage.

The virtual machine effectively has multiple concurrent processes, where
each process effectively handles just one (possibly complex) command at a
time (a command being realized as a "statement"), and executes each
separately and in the order received; any results or side-effects of each
command provide a context for the next command, both in the current process
and, where applicable, in other processes.

The normal context of a command is a single process.  Within a process is
where a routine call chain exists, where statements execute, where program
variables exist, where the scope of "atomic" operations and transactions
lie, and so on.  However, some commands could cause other processes to
start or end, and some could send messages to or receive messages from
other processes, either individuals or groups of processes.  When a Muldis
D virtual machine first starts up, there is an initial root process which
in turn starts any others and which is the last to end on shutdown.  Each
concurrent user connection or autonomous transaction is represented by its
own process.

=head1 DATA TYPES

Muldis D has a formal type system, at least in intent, which works
conceptually in the following manner.

A I<data type>, typically abbreviated I<type>, is fundamentally an
unordered set (or just I<set>) of values, nothing more and nothing less.
If and only if 2 sets of values are the same unordered set, they are the
same type.  Analogous to how values are conceived, every type is unique,
eternal, immutable, has no address and can not be updated.  Note that the
concept of a I<type> as an unordered set of values in Muldis D is distinct
from the concept of a I<value> which is an unordered set of values; no type
I<is> a value, even though a set value is indeed isomorphic to a type.

The I<universal type> is the only type that consists of all values which
can possibly exist, and is an infinite set; it is the maximal data type of
the entire type system.  The I<empty type> is the only type that consists
of exactly zero values, and is the empty set; it is the minimal data type.
Every other type has at least 1 value and lacks at least 1 value.

Take 2 arbitrary but not necessarily distinct data types, I<T1> and I<T2>.
Iff the value set of I<T1> is a superset of that of I<T2>, then I<T1> is a
I<supertype> of I<T2>, and I<T2> is a I<subtype> of I<T1>.  If additionally
the 2 types are mutually distinct, meaning I<T1> has at least 1 value that
I<T2> lacks, then I<T1> is additionally a I<proper supertype> of I<T2>, and
I<T2> is additionally a I<proper subtype> of I<T1>.  Given those last
examples, I<T1> is a I<more general> type, and I<T2> is a I<more specific>
type.  In this way, the I<universal type> is a proper supertype of all
other types, and the I<empty type> is a proper subtype of all other types.

Iff 2 data types have no values in common, they are said to be I<disjoint>.
Iff a data type I<T1> has all of the values of two data types I<T2> and
I<T3> and I<T1> has no values that are not also members of I<T2> or I<T3>,
then I<T1> is a I<union type> with respect to I<T2> and I<T3>.  Iff instead
I<T1> has only but all of the values that I<T2> and I<T3> have in common,
then I<T1> is an I<intersection type> with respect to I<T2> and I<T3>.  Iff
2 data types, I<T1> and I<T2>, are disjoint and every value of the a third
data type I<T3> is a member of one of them, then I<T1> and I<T2> are
I<complementary types> with respect to I<T3>.  In this way, the I<universal
type> is a union type of all other types, and the I<empty type> is the
intersection of all others; the two are both disjoint and complementary.
A I<singleton type> is a type that consists of exactly 1 value.

Subtyping in Muldis D, as in any B<D> language, fundamentally takes the
form of I<specialization by constraint>, not I<specialization by
extension>.  (A consequence is that every Muldis D function is covariant.)

So conceptually speaking, a "circle" value is an "ellipse" value, but a
"coloured circle" is neither a "circle" value nor a "colour" value; the
type "circle" is a subtype of "ellipse", and "coloured circle" is neither a
subtype of "circle" nor of "colour".  Rather, for example, a "coloured
circle" is a multi-component type which has components of type "circle" and
"colour", but composition like this does not a subtype make.

A I<finite type> is a data type whose cardinality (count of member values)
is known to be finite, and this cardinality can be deterministically
computed; moreover, every value of a finite type can be represented somehow
using a finite amount of memory.  This doesn't exclude the possibility that
either the cardinality or individual values are larger than present-day
computing hardware can handle, but even if so, they could be handled by
sufficiently larger but finite resources.  An I<infinite type> is a data
type that is not a finite type; its cardinality is either known to be
infinity, or it is unknown.  The universal type is an infinite type and the
empty type is a finite type.

Data types in Muldis D are fundamentally unordered sets of values, and so
in the general case, it does not make sense to use them in a context that
requires some conception of values being mutually ordered.  However,
potentially any type can externally have ordering algorithms (as defined by
functions) applied to it in particular contexts, and so fake the type being
ordered, in either one or multiple ways.  Moreover, many of the common use
cases here have system-defined functionality to support them.

=head2 Contracts

A I<contract> is an association with a I<data type> of various metadata
which can be applied where that contract is used.  The most common such
metadata are an explicit name or alias for the type, or a default value
(not valid for the I<empty type>).

Every I<contract> is of exactly 1 of 2 kinds based on how it is declared;
it is either a I<selection contract> or an I<interface contract>; these
two declaration methods are polar opposites of each other.

Each given I<selection contract>, I<R1>, explicitly declares for itself
what its associated type / value set is.  The form this takes in the
general case is a set of
(typically exactly one) other contracts' names, I<S1>, plus a predicate
expression, I<P1>.  The type of I<R1> is defined as taking the union of the
types of I<S1> as source values and then applying I<P1> as a filter; the
type of I<R1> consists of just the values for which I<P1> results in
I<true>.  Having a I<S1> is optional; the value source of an I<R1> without
a I<S1> is implicitly the universal type.  Having a I<P1> is also optional;
for an I<R1> without a I<P1>, its implicit predicate is unconditionally
I<true>.  The canonical way to associate an I<R1> with the universal type
is to omit both its I<S1> and I<P1>; the canonical way to associate with
the empty type is to have an explicit empty I<S1> and omit I<P1>.

A selection contract associated with a I<singleton type> is
idiomatically declared in a different way, by declaring a I<constant> whose
value is the type's only value.  For any context in Muldis D where a
reference to or a definition of a selection contract is allowed, a
reference to or a definition of a constant is allowed in its place.  A
given constant for value I<V1> is semantically identical for such uses as a
general form selection contract with an omitted I<S1>, a I<P1> that tests
its actual argument for equality with I<V1>, and a default value of I<V1>.

Each given I<interface contract>, I<I1>, explicitly does I<not> declare its
associated type.  Instead, I<I1> relies on other contracts, I<S1>, to
explicitly declare that they I<compose> I<I1>, and that therefore I<I1> is
a type union that includes all of the values of I<S1>.

Each given contract, with the sole exception of one associating with the
empty type, must have exactly 1 associated I<default value>.  Any
selection contract, I<R1>, may explicitly declare this value for itself;
if I<R1> does not do this, then the default value of its immediate sources
is implicitly inherited as its own; if the set of default values of the
direct sources of I<R1>, after being filtered by the predicate of I<R1>, is
not a singleton, this is an error.  Any interface contract I<I1> must have
exactly 1 composing contract I<S1> that also explicitly declares that it
provides the default value of I<I1>; that is, the default value of I<S1> is
also the default value of I<I1>.

Any kind of contract may compose an I<interface contract>, and so the
latter may be chained, but ultimately each end composer must be a
I<selection contract> as only they can originate default values.  For
example, one may have 2 interface contracts and a selection contract to
represent, respectively, a general numeric type, a rational numeric type,
and a 64-bit ratio type; these ordered from most general to most specific.

Each interface contract I<I1> declares a set of zero or more virtual
routine (function or procedure) names I<N1>.  For each name of I<N1> there
must exist a virtual routine I<R1> of that name which takes at least 1
conceptual argument I<A1> of the type associated with I<I1>.  For each
given composing type I<S1> of I<I1>, for each virtual routine I<R1>, there
must exist a (possibly virtual) routine I<R2> which explicitly declares
that it I<implements> I<R1>, where the conceptual argument I<A2>
corresponding to I<A1> is of the type associated with I<S1>.  That is, any
contract composing an interface contract must implement the latter's
required interface; failing to do so is an error.

And so, regardless of whether types are manifested in a program by way of a
a selection contract or an interface contract, users can be confident
that if some code declares acceptance of a particular supertype, they
should be able to easily predict the manners and circumstances where they
may use all of its subtypes interchangeably, with more general code,
regardless of how the various subtypes are implemented.

Note that a non-virtual routine I<R2> defined over subtype I<T2> is also
allowed to I<implement> a non-virtual routine I<R1> defined over supertype
I<T1>, in which case I<R2> is declaring itself to be a more optimal
implementation for its specific subtype than is the more general
implementation of I<R1>.

An interface contract which declares zero required virtual routines is also
called a I<semantic contract>.  A semantic contract just exists for
providing a semantic label to the contracts that compose it, and doesn't
otherwise imply anything about their API.  Examples of semantic contracts
are ones that declare a number is either ordinal or cardinal or nominal.
In contrast, an interface contract which declares at least one required
virtual routine exists mainly to aid generic code reuse, but may optionally
provide a semantic label as well.

The primary determinant for whether you would declare a contract as a
selection contract or an interface contract is whether you want the
contract's definition to be closed, or open, respectively.  If you use a
selection contract, then assuming you have control over all the types it
unions (or they are system-defined), you are fairly guaranteed that your
contract will remain static and continue to contain exactly the same values
indefinitely, or in other words that the type will continue to mean exactly
what you intended no matter what anyone else does with types outside your
control.  If you use an interface contract, in contrast, you are expressly
empowering others to alter the meaning of that type by adding new values to
it from their own new contracts, and so your contract is flexible to
accommodate new uses automatically, at the cost that you can't always
assume when you ask for a value of that type that you'll know in advance
all the possible values you might get.  A particularly important use of
interface contracts is doing operator overloading between disjoint types,
which would be considerably more difficult without them.

One might say that Muldis D is using I<progressive nominal typing>; or at
least Larry Wall made up that term on the spot in reference to how Muldis D
was perceived to work, L<http://irclog.perlgeek.de/perl6/2010-05-06/text>.
Users can choose to select values before or without at all declaring the
types of (that is, contracts for) those values, and not just after; the
values alternately do or don't belong to named types/contracts; values can
often include a declaration of a nominal type in their composition,
regardless of whether such a type/contract exists at the time.

=head2 Type Safety

Muldis D should qualify as a I<type-safe> language by many, if not all,
definitions of the term I<type-safe>.

The Muldis D type system is used to prevent certain erroneous or
undesirable program behaviour.  Type errors are usually those that result
from attempts to perform an operation on some values that is not
appropriate to their data types; or any contravention of the programmer's
intent (as communicated via contract annotations) are erroneous and to be
prevented by the system.

Every value is of a type.  Every literal, expression, function result,
routine parameter, type component, and variable has a declared type by way
of a contract; the system ensures that a variable will only ever hold a
value of its declared type, that a routine parameter will only take an
argument of its declared type, and a function will only ever result in a
value of its declared type.  There are no implicit type conversions, only
explicit type mapping.  For example, it is invalid for a numeric value to
appear where a character string value is expected, or vice-versa, but an
expression or function that explicitly maps a numeric to a string is valid
to use there.  Muldis D follows the I<principle of cautious design>.

Muldis D is a hybrid dynamic and static language, and where on the spectrum
it is varies by implementation.  At the very least, all imminent type
errors would be prevented by the system at run time.  But the more
potential type errors are caught at compile time, the better for users.

Fundamentally, Muldis D is a dynamic language, associating type information
with values at run time and consulting them as needed to detect imminent
errors; the system prevents run time imminent type errors by throwing an
exception.  However, it is possible in many cases for Muldis D to be
treated as a static language, where type errors are found and prevented at
compile time, such that the compilation process throws an exception.
Ideally, all type errors would be found at compile time, and more
intelligent compilers will be closer to that goal, but in the general case
it is not possible to go all the way.  In order to increase type error
detection at compile time, a wider scope needs to be analysed than
otherwise; in practice, the widest practical scope is to analyse the entire
I<package> that would contain the code being compiled, as well as any other
currently available packages that may use or be used by it.

I<TODO: Other related notes.>

Generally speaking, there are two categories of type errors.  The first is
where the system simply can't function in a reasonable or deterministic
manner if they are violated; this is the kind that must always be detected
and prevented by the system.  The second is where the type error is more
just an error concerning the programmer's intent, and this is not fatal by
any means; the system will still produce a reasonable and deterministic
result if those were not treated as errors and be allowed to resume.  An
example of the first is divide by zero with the system standard integer and
rational types.  An example of the second is an identity/equality
comparison between 2 values from variables of different declared types; it
is valid to compare an integer to a character string for equality; the
result would always be false, but it is still logical; however the user
might want the system to detect such occurrences.

Therefore, Muldis D officially defines for now that the latter category is
not fatal and would just generate a warning by default.  Warnings can be
either enabled as warnings, disabled to not display, or be promoted to
fatal errors automatically, using a compile-time option or lexically scoped
pragma or something.

All warnings are issued at compile-time only, which includes any time when
a package is being registered.

Generally speaking, a Muldis D implementation can not expect at run time to
remember matters related to declared types of contexts that values are
coming from.  Rather, only the most specific type of the value itself can
be known or computable at runtime in order to enforce say the constraint
from the declared type of a variable it is being assigned to.  However, the
declared type of a variable used as an argument to a subject-to-update
parameter I<would> be known at runtime, if it is more specific than the
declared type of the parameter.

The declared type of an operator argument's source generally can not be
seen or used by a logical decision in the routine, so for example, if a
generic operator is going to return the default value of its argument's
declared type and not the default value of its corresponding parameter's
declared type, then this can't be done.  What must happen is for the
operator to take an extra argument where the name of the type whose default
we want is spelled out, or alternately just the default value itself.

=head1 FUNCTIONS

A I<function> (also known as a I<read-only operator>) is a set of
instructions for mapping a set of values to a set of values in a pure and
deterministic manner.

A Muldis D function is isomorphic to a mathematical function.  A function
call/invocation takes exactly 1 input I<actual argument> aka I<topic> value
and gives exactly 1 output I<result> value.  The result value of a function
call is determined entirely by its actual argument value, and a function is
guaranteed to give exactly the same single result value for every call with
the same actual argument value.  Multiple distinct actual arguments may
yield the same result, but multiple calls with the same actual argument
never give different results.

When implementing a mapping that conceptually wants to take multiple
argument values, which is likely more common than not, the typical practice
is for the single actual argument to be a collection-typed value whose
elements are the conceptual arguments.  Similarly, when multiple result
values are conceptually desired (relatively uncommon), they would be member
elements of a single actual result value.  An example with multiple
conceptual arguments and results is the common whole division operation; it
takes a dividend plus a divisor and gives a quotient plus a remainder.

Note that for brevity the Muldis D language specification will only use the
unqualified term I<argument> in the context of a function whose actual
argument is I<FDN__Tuple> typed, the latter being the case for most
functions.  In that context, an I<argument> is a conceptual argument of the
function that is actually an attribute of said actual argument.  Regardless
of its type, the term I<topic> will always refer to a function's entire
actual argument.  As an exception, in some contexts the unqualified
I<argument> could mean either an actual or a conceptual argument.

A Muldis D function is composed fundamentally of one or more arbitrarily
complex value expressions, and the former is essentially just a wrapper for
the latter.  Complementary to this, a function can only be invoked as part
of a value expression, such that its result value is the value of the
expression, and similarly, the function call's actual argument must be
defined by a value expression.  The ultimate roots of value expression call
chains are typically procedure statements.

A function has no lexical variables at all, although they can be faked for
code factoring purposes by giving explicit names to its component
sub-expressions, the current value for each of which is defined/set once
within a function call but referenceable multiple times.  Value expressions
are also conceptually lazy and can be gated to only be evaluated
conditionally.

A function call, like any value expression evaluation in general, is an
implicitly atomic operation.  From the perspective of Muldis D code or its
users, there is no discrete instant within its host process at which a
function/expression has partially evaluated or that any involved variables
are in a partly-changed state; at one instant there is the system state
just prior to the outermost function/expression of the call chain being
evaluated, and at the subsequent instant that outermost has terminated.

A function can not read from any dynamic portion of the wider environment
such as program variables or user input or disk or network or a system
clock or a system number generator; a function can not see anything that
could possibly make its results differ between calls, with the sole
exception of its arguments.

That being said, a function call I<is> allowed to have some kinds of
side-effects in the form of writing messages to side channels, such as for
purposes of auditing activity or debugging or providing runtime
optimization hints; such activities are write-only to functions, so their
use doesn't make the function non-deterministic with its result, and no
determinism is guaranteed with side channel messages.

Normal function termination is to give a result, but one may instead
terminate abnormally by throwing an exception.  While exceptions may be
thrown due to bad arguments, such as an attempt to divide by zero,
potentially any function may throw an exception non-deterministically due
to environmental conditions at the time, such as due to a lack of
sufficient system memory.  A function or expression may not catch a thrown
exception, so one will unwind the call stack up to some invoking procedure.
If one wants to effectively trap failures within a function, then its
expressions or called functions must explicitly return excuse-indicating
values among their possible results, such as IEEE NaN values, rather than
throw exceptions; as far as Muldis D is concerned, all explicit results,
even the likes of NaN, are considered to be normal termination.

For any context in Muldis D where a reference to or a definition of a
function is allowed, a reference to or a definition of a contract is
allowed in its place.  An invocation as if it were a function of a given
contract for type I<T1> where the actual argument is value I<V1> is
semantically identical to (and is idiomatic for) testing if I<V1> is a
member of the type I<T1>; the result is I<true> if so and I<false> otherwise.

I<TODO: Other related notes.  Especially the parts of a function definition.>

=head2 Constants

A I<constant> is similar to a I<function> but that it takes no actual
argument at all and it always gives the same result.  A constant may be
invoked anywhere that a function may be, and a constant may invoke functions.
The single value a constant denotes may be arbitrarily complex, and
repeated portions may be factored under their own names, like in a function.

A primary use of a Muldis D I<constant> is for code factoring, so that
multiple routines or dependent packages may share a common named constant.

In Muldis D, an additional idiomatic purpose of a I<constant> is to support
representing the current value of any arbitrary database (or data dump) in
the form of Muldis D source code, where it is a named entity in a package.
Such a form allows one to bundle up all the type definitions the database
depends on, or factor repeated database content values, within a common
package, or cite external definition or content dependencies of such, with
all the same flexibility and power as with ordinary source code.  In this
context, all kinds of database updates, both I<data definition> and I<data
manipulation>, occur using the same basic tools, updating Muldis D package
source-code-as-data, at runtime.

Normally, when Muldis D source code is parsed, the details of its actual
user-written syntax are preserved as data, so that it is possible to
losslessly round trip the source code to a form identical to what the users
wrote.  However, in the case of constants used to represent a database,
especially one previously created or changed at runtime as ordinary user
data values, there is no benefit to maintaining that syntax meta-data when
parsing such constants, and it takes up a lot of extra space.  For a given
I<constant>, since the Muldis D parser can never otherwise know for sure of
its source code's origin or purpose, the constant can explicitly declare
that it is I<folded>, in which case the parser can throw away any syntax
meta-data and just store the constant's result value.  It is idiomatic for
a constant that is produced with a database dump to be declared I<folded>
while a constant hand-written by a user to not be declared so.

A third idiomatic purpose of a I<constant> is to provide a terse alternate
means to define a selection contract associated with a singleton type;
as such a reference to a constant can be used both where a contract or a
value is expected.

For any context in Muldis D where a reference to or a definition of a
constant is allowed, a reference to or a definition of a contract is
allowed in its place.  An invocation as if it were a constant of a given
contract is semantically identical to (and is idiomatic for) selecting the
default value of the contract.

=head1 EXPRESSIONS

I<TODO.>

=head1 PROCEDURES

A I<procedure> (a special case of which is known as an I<update operator>)
is a set of instructions for either enacting possibly non-deterministic
change over time in a set of variables or for reading from or writing to
the external environment of the application, including its users or various
external systems.

I<TODO.>

=head1 STATEMENTS

I<TODO.>

=head1 STIMULUS-RESPONSE RULES

Muldis D natively supports the concept of I<stimulus-response rules>,
otherwise known as I<triggered routines>.  The concept involves the
automatic execution of a procedure in response to a particular
defined stimulus.  This is in contrast with the normal way to execute a
routine which is in response to an explicit invocation in code.

I<TODO: Other related notes.>

=head1 TODO - SECTIONS ON NAMESPACES, PACKAGES, AND OTHER THINGS

I<TODO.  Also say what 'using','floating' etc do.>

=head1 EXTERNAL TYPES AND ROUTINES

I<TODO.  Meanwhile see 'same' and 'EXTERNAL DATA TYPES' in Core.pod.>

=head2 FOUNDATION

This document defines the fundamental data types and operators of Muldis D,
collectively referred to as the I<Muldis D Foundation>; these are the
mandatory minimal core set of system-defined and eternally available
entities that all Muldis D implementations, at least those that claim to
support the C<Muldis_D:Plain_Text:"http://muldis.com":"0.201.0.-9"> language,
need to provide.

The official Muldis D language is canonically stratified into 2
main layers implementation-wise, I<low-level> and I<high-level>.

High-level Muldis D provides the system-defined types and operators and
other features that regular users of the language would employ directly in
their applications and schemas.  High-level Muldis D is formally defined
using the exact same methods available to users for writing their own
types/operators/etc, including choices of syntax and features.  It is
canonically written as regular Muldis D packages / code libraries just like
user code is; users can introspect it or write their own alternatives for
parts or the whole of it that look and function as it does.  See
L<Muldis::D::Package::Core> for the details of high-level Muldis D.

The I<Muldis D Foundation> defines low-level Muldis D, which is the
system-defined types and operators and other features which are canonically
written in one or more third-party languages which are I<hosting> Muldis D,
whether for purposes of bootstrapping Muldis D or for purposes of
integrating the languages in a common user development environment.

The Muldis D Foundation encompases fundamental types and operators that
best practice would deem each host should be taking care of their
implementation details itself and that implementing such higher up would
not be a pragmatic use of resources or would be inappropriate reinventing
the wheel.  Moreover, that is about the level of abstraction where hosts
would tend to strongly diverge from each other in implementation details in
matters that strongly effect performance or that differentiate themselves,
not the least of which is functional vs procedural or distributed vs not,
or static vs dynamic, or other matters of algorithms and integration.

Low-level Muldis D is a polar opposite of high-level; its API is not
defined or invokable or introspectable in the same way as normal Muldis D
code, and users can not define their own substitutes that have the exact
same user syntax as they have.  The purpose of low-level is to provide the
basis for writing the system-defined high level language, and users should
not normally be invoking low-level directly, although they do in fact have
all of the same freedom to do so if the situation warrants.

Canonically speaking, any system-defined entities defined as part of
high-level Muldis D can just be written once and be shared by all host
implementations as is, and so porting Muldis D to a new host can be done
with fairly little work in order for it to run at all.  The Muldis D
Foundation is minimized to the reasonable bare bones on purpose in order
largely to aid this (and largely to increase user substitutability).  That
being said, each host implementation is free to override the
implementations of any Muldis D code, whether part of high-level Muldis D
or part of a user's own code, with host-native implementations in order to
boost performance.  It is in fact assumed that such overrides will be
common, with simple hosts doing little of it and sophisticated industrial
strength hosts doing it a lot.  As long as the actual semantics as seen by
the user is unchanged, this is all fair game.  The design of Muldis D is
also meant to help hosts do this more reliably and with fewer errors.

Formally speaking, all low-level data types are anonymous, and this
documentation refers to them italicized like I<foo>; any I<foo> is for
human reference and that name doesn't physically exist as part of the
low-level API as a type or contract name.  In contrast, all low-level
operators/routines are named, and the documentation refers to them like
C<foo> as they do physically exist as part of the low-level API.

The high-level API gives more user-friendly physical C<foo> names to all of
the above in its own contract/routine wrappers for the low-level entities,
but those names won't be used in this Muldis D Foundation document.

The low-level entity names given here, whether anonymous or not, are
purposefully given different names than their high-level wrappers have,
to help easily distinguish them; mainly they have C<FDN__> prefixes.

=head1 FOUNDATION TYPES

I<TODO.>

=head2 FDN__Any

The I<FDN__Any> type is the infinite I<universal type>, which is the
maximal data type of the entire Muldis D type system and consists of all
values which can possibly exist.  It is a union type over just these 7
low-level types, all of the latter being mutually disjoint:
I<FDN__Boolean>, I<FDN__Integer>, I<FDN__Array>,
I<FDN__Bag>, I<FDN__Tuple>, I<FDN__Capsule>, I<FDN__External>.

=head2 FDN__Boolean

The I<FDN__Boolean> type is finite.  A I<FDN__Boolean> value is a general
purpose 2-valued logic boolean or I<truth value>, or specifically it is one
of the 2 values I<false> and I<true>.

=head2 FDN__Integer

The I<FDN__Integer> type is infinite.  A I<FDN__Integer> value is a
general purpose exact integral number of any magnitude, which explicitly
does not represent any kind of thing in particular, neither cardinal nor
ordinal nor nominal.

=head2 FDN__Array

I<TODO.>

=head2 FDN__Bag

I<TODO.>

=head2 FDN__Tuple

I<TODO.>

=head2 FDN__Capsule

I<TODO.>

=head2 FDN__External

The I<FDN__External> type is infinite.  A I<FDN__External> value is an
opaque and transient reference to an entity that is defined and managed
externally to the Muldis D language environment, either internally to the
Muldis D host implementation or in some peer language that it mediates.

=head1 FOUNDATION SUBTYPES FOR DEFINING SOURCE CODE

I<TODO.>

=head2 ...

I<TODO.>

=head1 FOUNDATION CONSTANTS

I<TODO.>

=head2 FDN__False

The Foundation constant C<FDN__False> represents the I<FDN__Boolean>
value I<false>.

=head2 FDN__True

The Foundation constant C<FDN__True> represents the I<FDN__Boolean>
value I<true>.

=head2 FDN__Neg_One

The Foundation constant C<FDN__Neg_One> represents the I<FDN__Integer>
value negative-one.

=head2 FDN__Zero

The Foundation constant C<FDN__Zero> represents the I<FDN__Integer>
value zero.

=head2 FDN__Pos_One

The Foundation constant C<FDN__Pos_One> represents the I<FDN__Integer>
value positive-one.

=head2 FDN__default_External

The Foundation constant C<FDN__default_External> represents the default
value of the I<FDN__External> type, which exists soley that said type has a
defined default value; the actual value of this is implementation-dependent.

=head1 FOUNDATION FUNCTIONS

I<TODO.>

Every low-level routine takes a topic of just the I<FDN__Any> type, so
any value expression will bind to it; any further input requirements will
be defined in their bodies and fail with thrown exceptions.

=head2 FDN__is_a_Boolean

The function C<FDN__is_a_Boolean> results in the I<FDN__Boolean> value
I<true> iff its topic is a member of the I<FDN__Boolean> type, and
results in the I<FDN__Boolean> value I<false> otherwise.

=head2 FDN__is_a_Integer

The function C<FDN__is_a_Integer> results in the I<FDN__Boolean> value
I<true> iff its topic is a member of the I<FDN__Integer> type, and
results in the I<FDN__Boolean> value I<false> otherwise.

=head2 FDN__is_a_Array

The function C<FDN__is_a_Array> results in the I<FDN__Boolean> value
I<true> iff its topic is a member of the I<FDN__Array> type, and
results in the I<FDN__Boolean> value I<false> otherwise.

=head2 FDN__is_a_Bag

The function C<FDN__is_a_Bag> results in the I<FDN__Boolean> value
I<true> iff its topic is a member of the I<FDN__Bag> type, and
results in the I<FDN__Boolean> value I<false> otherwise.

=head2 FDN__is_a_Tuple

The function C<FDN__is_a_Tuple> results in the I<FDN__Boolean> value
I<true> iff its topic is a member of the I<FDN__Tuple> type, and
results in the I<FDN__Boolean> value I<false> otherwise.

=head2 FDN__is_a_Capsule

The function C<FDN__is_a_Capsule> results in the I<FDN__Boolean> value
I<true> iff its topic is a member of the I<FDN__Capsule> type, and
results in the I<FDN__Boolean> value I<false> otherwise.

=head2 FDN__is_a_External

The function C<FDN__is_a_External> results in the I<FDN__Boolean> value
I<true> iff its topic is a member of the I<FDN__External> type, and
results in the I<FDN__Boolean> value I<false> otherwise.

=head2 FDN__same

The function C<FDN__same> requires its topic to be a I<FDN__Tuple>
value with just 2 attributes/arguments named C<0> and C<1>.  This function
results in the I<FDN__Boolean> value I<true> iff its 2 arguments C<0> and
C<1> are exactly the same value, and results in the I<FDN__Boolean> value
I<false> otherwise.  This function is commutative.

=head2 FDN__Integer_in_order

The function C<FDN__Integer_in_order> requires its topic to be a
I<FDN__Tuple> value with just 2 attributes/arguments named C<0> and
C<1>, where each argument is a I<FDN__Integer> value.  This function
results in the I<FDN__Boolean> value I<true> iff either its 2 arguments
C<0> and C<1> are exactly the same value or the C<0> argument is closer to
negative infinity than its C<1> argument; it results in the I<FDN__Boolean>
value I<false> otherwise.  This function is commutative.

=head2 FDN__Integer_opposite

The function C<FDN__Integer_opposite> requires its topic to be a
I<FDN__Tuple> value with just 1 attribute/argument named C<0>, where
that argument is a I<FDN__Integer> value.  This function results in the
I<FDN__Integer> value that is the I<opposite> of its C<0> argument.

=head2 FDN__Integer_modulus

The function C<FDN__Integer_modulus> requires its topic to be a
I<FDN__Tuple> value with just 1 attribute/argument named C<0>, where
that argument is a I<FDN__Integer> value.  This function results in the
non-negative I<FDN__Integer> value that is the I<absolute value> of its
C<0> argument.

=head2 FDN__Integer_plus

The function C<FDN__Integer_plus> requires its topic to be a
I<FDN__Tuple> value with just 2 attributes/arguments named C<0> and
C<1>, where each argument is a I<FDN__Integer> value.  This function
results in the I<FDN__Integer> I<sum> from performing I<addition> of
its 2 I<summand> arguments C<0> (I<augend>) and C<1> (I<addend>).  This
function is both associative and commutative; its identity value is the
I<FDN__Integer> zero; C<FDN__Integer_times> is its repeater function.

=head2 FDN__Integer_minus

The function C<FDN__Integer_minus> requires its topic to be a
I<FDN__Tuple> value with just 2 attributes/arguments named C<0> and
C<1>, where each argument is a I<FDN__Integer> value.  This function
results in the I<FDN__Integer> I<difference> from performing
I<subtraction> of its 2 arguments C<0> (I<minuend>) and C<1>
(I<subtrahend>).

=head2 FDN__Integer_times

The function C<FDN__Integer_times> requires its topic to be a
I<FDN__Tuple> value with just 2 attributes/arguments named C<0> and
C<1>, where each argument is a I<FDN__Integer> value.  This function
results in the I<FDN__Integer> I<product> from performing
I<multiplication> of its 2 I<factor> arguments C<0> (I<multiplier>) and
C<1> (I<multiplicand>).  This function is both associative and commutative;
its identity value is the I<FDN__Integer> positive one;
C<FDN__Integer_nn_power> is its repeater function.

=head2 FDN__Integer_multiple_of

The function C<FDN__Integer_multiple_of> requires its topic to be a
I<FDN__Tuple> value with just 2 attributes/arguments named C<0> and
C<1>, where each argument is a I<FDN__Integer> value and C<1> must also
be nonzero.  This function results in the I<FDN__Boolean> value I<true> iff
its C<0> argument is an even multiple of its C<1> argument (that is, the
former is evenly divisible by the latter); it results in the
I<FDN__Boolean> value I<false> otherwise.

=head2 FDN__Integer_divided_by_rtz

The function C<FDN__Integer_divided_by_rtz> requires its topic to be a
I<FDN__Tuple> value with just 2 attributes/arguments named C<0> and
C<1>, where each argument is a I<FDN__Integer> value and C<1> must also
be nonzero.  This function results in the I<FDN__Integer> I<quotient>
from performing I<division> of its 2 arguments C<0> (I<dividend> or
I<numerator>) and C<1> (I<divisor> or I<denominator>) using the semantics
of real number division, whereupon the real number result is rounded to the
same or nearest-towards-zero integral number.

=head2 FDN__Integer_nn_power

The function C<FDN__Integer_nn_power> requires its topic to be a
I<FDN__Tuple> value with just 2 attributes/arguments named C<0> and
C<1>, where each argument is a I<FDN__Integer> value and at least one
of those must also be nonzero and C<1> must also be non-negative.  This
function results in the I<FDN__Integer> value from performing
I<exponentiation> of its 2 arguments C<0> (I<base>) and C<1> (I<exponent>
or I<power>).

=head2 FDN__Integer_factorial

The function C<FDN__Integer_factorial> requires its topic to be a
I<FDN__Tuple> value with just 1 attribute/argument named C<0>, where
that argument is a non-negative I<FDN__Integer> value.  This function
results in the positive I<FDN__Integer> value that is the I<factorial>
of its C<0> argument.

=head2 FDN__Array_count

I<TODO.>

=head2 FDN__Array_elem

I<TODO.>

=head2 FDN__Array_has_index

I<TODO.>

=head2 FDN__Array_has

I<TODO.>

=head2 FDN__Array_nest

I<TODO.>

=head2 FDN__Array_unnest

I<TODO.>

=head2 FDN__Array_any

I<TODO.>

=head2 FDN__Array_where

I<TODO.>

=head2 FDN__Array_map

I<TODO.>

=head2 FDN__Array_reduce

I<TODO.>

=head2 FDN__Array_slice

I<TODO.>

=head2 FDN__Array_catenate

I<TODO.>

=head2 FDN__Array_index_succ_all_matches

I<TODO.>

=head2 FDN__Bag_count

I<TODO.>

=head2 FDN__Bag_has

I<TODO.>

=head2 FDN__Bag_nest

I<TODO.>

=head2 FDN__Bag_unnest

I<TODO.>

=head2 FDN__Bag_any

I<TODO.>

=head2 FDN__Bag_where

I<TODO.>

=head2 FDN__Bag_map

I<TODO.>

=head2 FDN__Bag_reduce);

I<TODO.>

=head2 FDN__Tuple_degree

I<TODO.>

=head2 FDN__Tuple_attr

I<TODO.>

=head2 FDN__Tuple_has_attr

I<TODO.>

=head2 FDN__Tuple_on

I<TODO.>

=head2 FDN__Tuple_but

I<TODO.>

=head2 FDN__Tuple_extend

I<TODO.>

=head2 FDN__Tuple_any_attrs

I<TODO.>

=head2 FDN__Tuple_attrs_where

I<TODO.>

=head2 FDN__Tuple_attrs_map

I<TODO.>

=head2 FDN__Tuple_attrs_reduce

I<TODO.>

=head2 FDN__Capsule_wrap

I<TODO.>

=head2 FDN__Capsule_wrapper

I<TODO.>

=head2 FDN__Capsule_unwrap

I<TODO.>

=head2 FDN__External_call_function

The Foundation function C<FDN__External_call_function> is a proxy for
invoking a function that is defined and managed externally to the Muldis D
language environment.  Its topic and result type are both I<FDN__Any>.

=head1 FOUNDATION PROCEDURES

I<TODO.>

=head2 ...

I<TODO.>

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::See_Also> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright © 2002-2015, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
