=pod

=encoding utf8

=head1 NAME

Muldis::D::Package::Core -
Muldis D core data types and operators

=head1 VERSION

This document is Muldis::D::Package::Core version 0.201.0.-9.

=head1 SYNOPSIS

    Muldis_D:Plain_Text:"http://muldis.com":"0.201.0.-9";
    script Unicode:8.0:UTF-8;
    package
    {
        identity My_App ::= My_App:"http://mycorp.com":"0";
        foundation "http://muldis.com":"0.201.0.-9";
        uses MD ::= Core:"http://muldis.com":"0.201.0.-9";
        floating {::My_App, ::MD, ::MD::Unicode_Aliases};
        `TODO: Put example routines etc here.`
    };

=head1 DESCRIPTION

This document defines the Muldis D package
C<Core:"http://muldis.com":"0.201.0.-9"> which provides the common core
system-defined data types and operators that regular users of the language
would employ directly in their applications and schemas.

See also L<Muldis::D::Standard_Library> to read about the B<Muldis D
Standard Library> specification, of which this document is a part.

=head1 PACKAGE

    Muldis_D:Plain_Text:"http://muldis.com":"0.201.0.-9";
    script Unicode:8.0:UTF-8;
    package
    {
        identity MD ::= Core:"http://muldis.com":"0.201.0.-9";
        foundation "http://muldis.com":"0.201.0.-9";
        floating {::MD, ::MD::Round_Meth, ::MD::Capsule, ::MD::Source_Code};
        ...
    };

=head1 MAXIMAL AND MINIMAL DATA TYPES

=head2 Any

    ::MD::Any ::= selection default (False);

The selection contract C<Any> represents the infinite
I<universal type>, which is the maximal data type of the entire Muldis D
type system and consists of all values which can possibly exist.  It also
represents the infinite Muldis D Foundation type I<FDN__Any>.  Its
default value is C<False>.  Other programming languages may name their
corresponding types I<Object> or I<Universal>.

=head2 None

    ::MD::None ::= selection of {};

The selection contract C<None> represents the finite I<empty type>,
which is the minimal data type of the entire Muldis D type system and
consists of exactly zero values.  It can not have any default value.

=head2 same =

    ::MD::same ::= function --> Boolean <-- (Any, Any)
        is commutative
        : (topic -->^ FDN__same);

    ::MD::"=" ::= alias of same;

The function C<same> aka C<=> results in C<True> iff its 2 arguments C<0>
and C<1> are exactly the same value, and C<False> otherwise.  Other
programming languages may name their corresponding operators I<==> or
I<===> or I<eq>.

Note that C<same> is guaranteed to result in C<False> when exactly one of
its 2 arguments is an C<External> value but beyond that its behavior when
both of its arguments are C<External> values is implementation defined, in
that implementations are expected to make it completely deterministic
according to appropriate rules of value distinctness for the external
environment in question; for example, if the external entity referenced by
an C<External> value is considered a mutable container, then 2 C<External>
should only be considered I<same> if they both point to the same container,
and not if two distinct containers have the same content.

=head2 not_same != ≠

    ::MD::not_same ::= function negates same
        is commutative;

    ::MD::"!=" ::= alias of not_same;

    ::MD::Unicode_Aliases::"≠" ::= alias of not_same;

The function C<not_same> aka C<!=> aka C<≠> results in C<False> iff its 2
arguments C<0> and C<1> are exactly the same value, and C<True> otherwise.
Other programming languages may name their corresponding operators
I<< <> >> or I<!===> or or I<~=> or I<^=> or I<ne>.

=head2 is_a

    ::MD::is_a ::= function --> Boolean <-- (Any, Reference)
        : (\.0 --> \.1);

The function C<is_a> results in C<True> iff its C<0> argument is a
member of the type specified by its C<1> argument, and C<False> otherwise.

=head2 not_is_a

    ::MD::not_is_a ::= function negates is_a;

The function C<not_is_a> results in C<False> iff its C<0> argument is a
member of the type specified by its C<1> argument, and C<True> otherwise.

=head2 default

    ::MD::default ::= function --> Any <-- (Reference)
        : (--> \.0);

The function C<default> results in the default value of the not-empty type
specified by its C<0> argument.

=head1 EXCUSE DATA TYPES

=head2 Excuse

    ::MD::Excuse::"" ::= interface;

The semantic contract C<Excuse> is infinite.  An C<Excuse> value is an
explicitly stated reason for why, given some particular problem domain, a
value is not being used that is ordinary for that domain.  For example, the
typical integer division operation is not defined to give an integer result
when the divisor is zero, and so a Muldis D function for integer division
could be defined to result in an C<Excuse> value rather than throw an
exception in that case.  For another example, an C<Excuse> value could be
used to declare that the information we are storing about a person is
missing certain details and why those are missing, such as because the
person left the birthdate field blank on their application form.  Its
default value is C<Excuse::No_Reason>.  An C<Excuse> is isomorphic to an
C<Exception> but that use of the former is not meant to terminate execution
of code early unlike the latter which is.  Other programming languages that
have typed exceptions are analogous.

=head2 Excuse::No_Reason

    ::MD::Excuse::No_Reason ::= constant (\@0)
        composes Excuse and_provides_its_default;

The constant C<Excuse::No_Reason> represents the C<Excuse> value which
simply says that an ordinary value for any given domain is missing and that
there is simply no excuse that has been given for this; in other words,
something has gone wrong without the slightest hint of an explanation.
This is conceptually the most generic C<Excuse> value there is and it can
be used by lazy programmers as a fallback for when they don't have even a
semblance of a better explanation for why an ordinary value is missing.
Other programming languages may name their corresponding values or
quasi-values I<null> or I<nil> or I<none> or I<nothing> or I<undef> or
I<unknown>; but unlike some of those languages, C<No_Reason> equals itself.

=head2 or_else coalesce

    ::MD::or_else ::= function --> Any <-- (Any, Any)
        is {associative,idempotent}
        : (\.0 --> \@Excuse ?? \.1 !! \.0);

    ::MD::coalesce ::= alias of or_else;

The function C<or_else> aka C<coalesce> results in its C<0>
argument iff the latter is not an C<Excuse>, and results in its C<1>
argument otherwise.  This function is designed to be chained for any number
of sequenced values in order to pick the first non-C<Excuse> in a list.
Other programming languages may name their corresponding operators
I<??> or I<//>.

=head2 and_then

    ::MD::and_then ::= function --> Any <-- (Any, Any)
        is {associative,idempotent}
        : (\.0 --> \@Excuse ?? \.0 !! \.1);

The function C<and_then> results in its C<0> argument iff the latter is an
C<Excuse>, and results in its C<1> argument otherwise.  This function is
designed to be chained for any number of sequenced values in order to pick
the first C<Excuse> in a list.

=head1 ORDERABLE DATA TYPES

=head2 Orderable

    ::MD::Orderable ::= interface
        requires_implements in_order;

The interface contract C<Orderable> is infinite.  An C<Orderable> value has
all of the traditional comparison operators defined for it such that values
of its type I<T> can be deterministically sorted by Muldis D into a
canonical total order.  But I<T> otherwise does not necessarily have
conceptually a total order in the normal sense or that order is different
than what the provided comparison operators give you.  An C<Orderable> type
is a type for which one can take all of its values and place them on a line
such that each value is definitively considered I<before> all of the values
one one side and I<after> all of the values on the other side.  Other
programming languages may name their corresponding types I<IComparable> or
I<Ord> or I<ordered> or I<ordinal>.

The default value of C<Orderable> is the C<Integer> value C<0>.  The
minimum and maximum values of C<Orderable> are C<Neg_Inf> and C<Pos_Inf>,
respectively; these 2 C<Excuse> values are canonically considered to be
before and after, respectively, I<every> other value of the Muldis D type
system, regardless of whether those values are members a type for which an
C<Orderable>-composing contract exists.  The primary reason for having
these values C<Neg_Inf> and C<Pos_Inf> is so Muldis D has an easy
consistent way to define an C<Interval> that is partially or completely
unbounded, and to use as identity values for chained order-comparisons.

C<Orderable> is composed, directly or indirectly, by: C<Neg_Inf>,
C<Pos_Inf>, C<Bicessable>, C<Boolean>, C<Integral>, C<Integer>,
C<Fractional>, C<Fraction>, C<Stringy>, C<Bits>, C<Blob>, C<Textual>,
C<Text>, C<Positional>, C<Array>, C<String>.

=head2 Neg_Inf -∞

    ::MD::Neg_Inf ::= constant (\@0) composes {Orderable, Excuse};

    ::MD::Unicode_Aliases::"-∞" ::= alias of Neg_Inf;

The constant C<Neg_Inf> aka C<-∞> represents the type-agnostic concept of
negative infinity, an C<Orderable> value that sorts I<before> all other
values in the Muldis D type system.  This value is also an C<Excuse> that
says the result of some operation is infinite in the negative direction.
Note that IEEE floating-point standards define a negative infinity value.

=head2 Pos_Inf +∞

    ::MD::Pos_Inf ::= constant (\@0) composes {Orderable, Excuse};

    ::MD::Unicode_Aliases::"+∞" ::= alias of Pos_Inf;

The constant C<Pos_Inf> aka C<-∞> represents the type-agnostic concept of
positive infinity, an C<Orderable> value that sorts I<after> all other
values in the Muldis D type system.  This value is also an C<Excuse> that
says the result of some operation is infinite in the positive direction.
Note that IEEE floating-point standards define a positive infinity value.

=head2 in_order

    ::MD::in_order::"" ::= function virtual
        --> Boolean <-- (Orderable, Orderable);

The virtual function C<in_order> results in C<True> iff its 2 arguments are
considered to already be I<in order> as given to the function, meaning that
either both arguments are exactly the same value or otherwise that the C<0>
argument value is definitively considered I<before> the C<1> argument
value; if C<0> is considered I<after> C<1> then C<in_order> results in
C<False>.  The primary reason for C<in_order> is to underlie all
order-determination or value sorting operations in an easy consistent way;
an C<Orderable>-composing contract only has to implement C<in_order> and
then values of its type can be compared, sorted on, and have intervals
defined in terms of them.

Other programming languages may instead typically use a three-way
comparison operator for this role, where its possible result values are
I<before>, I<same>, and I<after>, and those 3 are typically represented by
either the integers {-1,0,1} or a special 3-valued enumeration type.  Said
operators may be named I<< <=> >> or I<cmp> or I<compare> or I<CompareTo>
or I<memcmp> or I<strcmp>.  But Muldis D uses a C<Boolean> result instead
partly to keep its core type system simpler (it would have gone the
enumeration route) and partly because the logic for doing sorting or
comparisons or validation is typically much simpler with this foundation.

=head2 in_order (Neg_Inf, Pos_Inf)

    ::MD::in_order::Neg_Inf_L ::= function --> Boolean <-- (Neg_Inf, Orderable)
        implements 2::""
        : (True);

    ::MD::in_order::Neg_Inf_R ::= function --> Boolean <-- (Orderable, Neg_Inf)
        implements 2::""
        : (topic --> \@same);

    ::MD::in_order::Pos_Inf_L ::= function --> Boolean <-- (Pos_Inf, Orderable)
        implements 2::""
        : (topic --> \@same);

    ::MD::in_order::Pos_Inf_R ::= function --> Boolean <-- (Orderable, Pos_Inf)
        implements 2::""
        : (True);

The 4 functions {C<in_order::Neg_Inf_L>, C<in_order::Neg_Inf_R>,
C<in_order::Pos_Inf_L>, C<in_order::Pos_Inf_R>} implement the C<Orderable>
virtual function C<in_order> for the composing types C<Neg_Inf> and
C<Pos_Inf>, specifically for comparing either value with any C<Orderable>.

=head2 before <

    ::MD::before ::= function commutes after;

    ::MD::"<" ::= alias of before;

The function C<before> aka C<< < >> results in C<True> iff its C<0>
argument is I<before> its C<1> argument; otherwise it results in C<False>.
Other programming languages may name this operator I<lt>.

=head2 after >

    ::MD::after ::= function negates before_or_same;

    ::MD::">" ::= alias of after;

The function C<after> aka C<< > >> results in C<True> iff its C<0>
argument is I<after> its C<1> argument; otherwise it results in C<False>.
Other programming languages may name this operator I<gt>.

=head2 before_or_same <= ≤

    ::MD::before_or_same ::= alias of in_order;

    ::MD::"<=" ::= alias of before_or_same;

    ::MD::Unicode_Aliases::"≤" ::= alias of before_or_same;

The function C<before_or_same> aka C<< <= >> aka C<≤> results in C<True>
iff its C<0> argument is I<before> its C<1> argument or they are the same
value; otherwise it results in C<False>.  Other programming languages may
name this operator I<le>.

=head2 after_or_same >= ≥

    ::MD::after_or_same ::= function commutes before_or_same;

    ::MD::">=" ::= alias of after_or_same;

    ::MD::Unicode_Aliases::"≥" ::= alias of after_or_same;

The function C<after_or_same> aka C<< >= >> aka C<≥> results in C<True>
iff its C<0> argument is I<after> its C<1> argument or they are the same
value; otherwise it results in C<False>.  Other programming languages may
name this operator I<ge>.

=head2 min

    ::MD::min ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity (Pos_Inf())
        : (topic --> \@in_order ?? \.0 !! \.1);

The function C<min> results in whichever of its 2 arguments is first when
the 2 are sorted I<in order>.  This function is designed to be chained for
any number of values in order to pick the one that sorts
I<before> all of the others.

=head2 max

    ::MD::max ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity (Neg_Inf())
        : (topic --> \@in_order ?? \.1 !! \.0);

The function C<max> results in whichever of its 2 arguments is last when
the 2 are sorted I<in order>.  This function is designed to be chained for
any number of values in order to pick the one that sorts
I<after> all of the others.

=head2 minmax

    ::MD::minmax ::= function
        --> (Orderable, Orderable) <-- (Orderable, Orderable)
        is commutative
        : (topic --> \@in_order ?? topic !! \%(\.1, \.0));

The function C<minmax> results in a binary C<Tuple> containing its 2
arguments sorted I<in order>; the function's result is the same as its
topic when the arguments are already in order, and the reverse of that
otherwise, meaning the values of C<0> and C<1> are swapped.

=head1 SUCCESSABLE DATA TYPES

=head2 Successable

    ::MD::Successable ::= interface
        requires_implements {asset,succ};

The interface contract C<Successable> is infinite.  A C<Successable> value
is a member of a conceptually noncontiguous totally ordered type; it has a
definitive I<successor> value of that type, at least where the given value
isn't the last value.

The primary reason for C<Successable> is to provide an easy consistent and
terse API for a generator of arbitrary sequences of values of any type.  In
this context, a C<Successable> value defines a complete self-contained
I<state> for a sequence generator, which is everything the generator needs
to know to both emit a I<current> value, which we call the I<asset>, as
well as determine all subsequent values of the sequence without any further
input.  To keep the fundamental general case API simple, there is just the
a monadic function to derive the next state from the current one, and a
monadic function to extract the asset from the current state, so actually
reading a sequence of values requires 2 function calls per value in the
general case.  For some trivial cases of C<Successable>, the I<state> and
I<asset> are one and the same, so just 1 function call per value is needed.
Keep in mind that asset values may repeat in a sequence, so it is not them
but rather the state values that have the total order property.  Other
programming languages may name their corresponding types I<sequence> or
I<iterator> or I<enumerator>.

C<Successable> is a less rigorous analogy to C<Bicessable>, where the
latter also requires the ability to produce the I<predecessor> value of the
given value, as well as the ability to determine if 2 arbitrary values are
in order.  While conceptually a C<Successable> has those features, formally
it is not required to because for some types it may be onerous or
unnecessary for its mandate to support those features; for example,
producing a successor state may disgard information otherwise needed to
recall any of its predecessors.

The default and minimum and maximum values of C<Successable> are the same
as those of C<Orderable>.  C<Successable> is composed, directly or
indirectly, by: C<Bicessable>, C<Boolean>, C<Integral>, C<Integer>,
C<Positional>, C<Array>, C<Interval>.

C<Successable> is intended to be a generalized tool for performing I<list
comprehension> or I<set comprehension>.  The typically idiomatic and more
efficient way to do many kinds of such I<comprehensions> is to use the
features of various C<Homogeneous> types to map an existing list or set to
another using generic member mapping and filtering functions, such as a
list of even integers less than a hundred.  With those cases, the
map/filter approach can permit processing members in any order or in
parallel, and avoiding unnecessary intermediate values.  In contrast, the
primary intended uses of C<Successable> is when either you want to produce
or process a potentially infinite-sized list (lazily) or especially produce
a sequence with uneven step sizes, such as an arbitrary number of
Fibonacci.  This is for cases where it may be necessary to calculate all
the intermediate values in order to arrive at a desired nth one, and doing
them out of sequence or in parallel may not be an option.

=head2 asset

    ::MD::asset::"" ::= function virtual --> Any <-- (Successable);

The virtual function C<asset> results in the I<asset> of its C<0> argument,
which for trivial cases may simply be that same argument.

=head2 succ

    ::MD::succ::"" ::= function virtual
        --> {Successable, Pos_Inf} <-- (Successable);

The virtual function C<succ> results in the I<successor> value of its
C<0> argument, or in C<Pos_Inf> if there is none.  Other programming
languages may name their corresponding operators I<next>.

=head2 nth_succ

    ::MD::nth_succ ::= function
        --> {Successable, Pos_Inf} <-- (Successable, Integer_NN)
    : (
        if !?\.1 then
            \.0
        else
            if (s ::= succ \.0) --> \@Excuse then
                s
            else
                s nth_succ --\.1
    );

The function C<nth_succ> results in the Nth I<successor> value of its C<0>
argument, where N is its C<1> argument, or in C<Pos_Inf> if there is none.

=head1 BICESSABLE DATA TYPES

=head2 Bicessable

    ::MD::Bicessable ::= interface
        composes {Orderable and_provides_its_default,
            Successable and_provides_its_default}
        requires_implements {in_order,asset,pred,succ};

The interface contract C<Bicessable> is infinite.  A C<Bicessable> value
is an C<Orderable> value for which, using the same canonical total order
for its type, there exists definitive I<predecessor> and I<successor>
values, at least where the given value isn't the first or last value on the
line respectively.  Similarly, one can take any two values of a
C<Bicessable> type and produce an ordered list of all of that type's values
which are on the line between those two values.  A primary quality of a
type that is C<Orderable> but not C<Bicessable> is that you can take any
two values of that type and then find a third value of that type which lies
between the first two on the line; by definition for a C<Bicessable> type,
there is no third value between one of its values and that value's
predecessor or successor value.  Other programming languages may name their
corresponding types I<ordinal> or categorically as I<enum>.  Note that
while a generic rational numeric type may qualify as an ordinal type by
some definitions of I<ordinal>, since it is possible to count all the
rationals if arranged a particular way, these types would not qualify as
C<Bicessable> here when that ordering is not the same as the one used for
the same type's C<Orderable> comparisons.  The default and minimum and
maximum values of C<Bicessable> are the same as those of C<Orderable>.
C<Bicessable> is composed, directly or indirectly, by: C<Boolean>,
C<Integral>, C<Integer>.

For some C<Bicessable> types, there is the concept of a I<quantum> or
I<step size>, where every consecutive pair of values on that type's value
line are conceptually spaced apart at equal distances; this distance would
be the quantum, and all steps along the value line are at exact multiples
of that quantum.  However, C<Bicessable> types in general don't need to be
like this, and there can be different amounts of conceivable distance
between consecutive values; a C<Bicessable> type is just required to know
where all the values are.  For example, C<Integer> has a quantum while a
type consisting just of prime integers does not.

Note that while mathematics formally defines I<predecessor> and
I<successor> for non-negative integers only, and some other programming
languages extend this concept to real numbers with the meaning I<minus one>
and I<plus one> respectively, Muldis D only formally associates these terms
with the quantum of I<one> for types specifically representing integers;
for C<Bicessable> types in general, the terms just mean prior or next
values and should not be conceptualized as mathematical operations.

=head2 pred

    ::MD::pred::"" ::= function virtual
        --> {Bicessable, Neg_Inf} <-- (Bicessable);

The virtual function C<pred> results in the I<predecessor> value of its
C<0> argument, or in C<Neg_Inf> if there is none.  Other programming
languages may name their corresponding operators I<prior> or I<previous>.

=head2 nth_pred

    ::MD::nth_pred ::= function
        --> {Bicessable, Neg_Inf} <-- (Bicessable, Integer_NN)
    : (
        if !?\.1 then
            \.0
        else
            if (s ::= pred \.0) --> \@Excuse then
                s
            else
                s nth_pred --\.1
    );

The function C<nth_pred> results in the Nth I<predecessor> value of its C<0>
argument, where N is its C<1> argument, or in C<Neg_Inf> if there is none.

=head1 BOOLABLE DATA TYPES

=head2 Boolable

    ::MD::Boolable ::= interface requires_implements so;

The interface contract C<Boolable> is infinite.  A C<Boolable> value has a
canonical way of being cast to a C<Boolean> value in a context-free manner,
as the answer to the non-specific question "Is that so?" on the value taken
in isolation, whatever that would conceivably mean for the value's type.
The idiomatic predicate being asked has to do with whether or not something
exists; for composing numeric types it is asking whether the number is
nonzero; for composing collection types it is asking whether the collection
has any members.  The primary reason for C<Boolable> is to provide an easy
consistent and terse way to ask a common predicate question such as this.
The default value of C<Boolable> is C<False>.  Other programming languages
often have the concept of particular values from a wide variety of types as
being conceptually either I<false> or I<true>, and C<Boolable> is the
formalization of that concept for Muldis D, allowing program code to be
written in a similar style but with more type safety as any treatment of a
value as a C<Boolean> must be made explicit.

C<Boolable> is composed, directly or indirectly, by: C<Boolean>,
C<Numerical>, C<Integral>, C<Integer>, C<Fractional>, C<Fraction>,
C<Emptyable>, C<Stringy>, C<Bits>, C<Blob>, C<Textual>, C<Text>,
C<Homogeneous>, C<Discrete>, C<Positional>, C<Array>, C<String>, C<Setty>,
C<Set>, C<Bag>, C<Relational>, C<Relation>, C<Tuple_Bag>, C<Interval>.

While conceivably C<Boolable> could also be composed by C<Attributive>, and
hence C<Tuple>, it isn't because that would set up a semantic conflict for
C<Relation> and C<Tuple_Bag> which are collections across 2 dimensions, and
it was decided for those latter types that C<Boolable> would apply to them
explicitly in their C<Homogeneous> dimension (by way of C<Emptyable>) and
not in their C<Attributive> dimension.  As such, the C<Attributive> functions
C<has_any_attrs> and C<is_nullary> are provided as that dimension's direct
analogies to the C<Homogeneous> dimension's C<Boolable>-implementing
C<has_any_members> (C<so>) and C<is_empty> (C<not_so>) functions.

=head2 so ? to_Boolean

    ::MD::so::"" ::= function virtual --> Boolean <-- (Boolable);

    ::MD::"?"        ::= alias of so;
    ::MD::to_Boolean ::= alias of so;

The virtual function C<so> aka C<?> aka C<to_Boolean> results in C<True>
typically when its C<0> argument is a nonzero number or a nonempty
collection; otherwise it results in C<False>.

=head2 not_so !?

    ::MD::not_so ::= function negates so;

    ::MD::"!?" ::= alias of not_so;

The function C<not_so> aka C<!?> results in C<True> typically when
its C<0> argument is a number zero or an empty collection; otherwise
it results in C<False>.

=head1 BOOLEAN DATA TYPES

=head2 Boolean Bool

    ::MD::Boolean ::= selection where (topic -->^ FDN__is_a_Boolean)
        default (False)
        composes {Bicessable, Boolable and_provides_its_default};

    ::MD::Bool ::= alias of Boolean;

The selection contract C<Boolean> aka C<Bool> represents the finite Muldis
D Foundation type I<FDN__Boolean>.  A C<Boolean> value is a general purpose
2-valued logic boolean or I<truth value>, or specifically it is one of the
2 values C<False> and C<True>.  Its default value is C<False>.  C<Boolean>
is both C<Orderable> and C<Bicessable>; its minimum value is C<False> and
its maximum value is C<True>.  Other programming languages frequently don't
have a dedicated boolean type but rather consider values of other types,
typically integer types, to be I<false> or I<true>.

=head2 False ⊥

    ::MD::False ::= constant (False);

    ::MD::Unicode_Aliases::"⊥" ::= alias of False;

The constant C<False> aka C<⊥> represents the boolean logical truth value
I<false> aka I<contradiction>.  Other programming languages frequently use
the integer 0 to represent I<false>.

=head2 True ⊤

    ::MD::True ::= constant (True);

    ::MD::Unicode_Aliases::"⊤" ::= alias of True;

The constant C<True> aka C<⊤> represents the boolean logical truth value
I<true> aka I<tautology>.  Other programming languages frequently use the
integer 1 to represent I<true>.

=head2 in_order (Boolean)

    ::MD::in_order::Boolean ::= function --> Boolean <-- (Boolean, Boolean)
        implements 2::""
        : (!\.0 or \.1);

The function C<in_order::Boolean> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Boolean>.

=head2 asset (Boolean)

    ::MD::asset::Boolean ::= function --> Boolean <-- (Boolean)
        implements 2::""
        : (\.0);

The function C<asset::Boolean> simply results in its C<0> argument.
This function implements the C<Successable> virtual function C<asset> for
the composing type C<Boolean>.

=head2 pred (Boolean)

    ::MD::pred::Boolean ::= function --> {False, Neg_Inf} <-- (Boolean)
        implements 2::""
        : (\.0 ?? False !! Neg_Inf());

The function C<pred::Boolean> implements the C<Bicessable> virtual
function C<pred> for the composing type C<Boolean>.

=head2 succ (Boolean)

    ::MD::succ::Boolean ::= function --> {True, Pos_Inf} <-- (Boolean)
        implements 2::""
        : (!\.0 ?? True !! Pos_Inf());

The function C<succ::Boolean> implements the C<Successable> virtual
function C<succ> for the composing type C<Boolean>.

=head2 so (Boolean)

    ::MD::so::Boolean ::= function --> Boolean <-- (Boolean)
        implements 2::""
        : (\.0);

The function C<so::Boolean> performs a logical I<proposition>; it simply
results in its C<0> argument.  This function implements the C<Boolable>
virtual function C<so> aka C<?> aka C<to_Boolean> for the composing type
C<Boolean>.

=head2 not ! ¬

    ::MD::not ::= function negates so::Boolean;

    ::MD::"!" ::= alias of not;

    ::MD::Unicode_Aliases::"¬" ::= alias of not;

The function C<not> aka C<!> aka C<¬> performs a logical I<negation> or
I<logical complement>; it results in C<True> iff its C<0> argument is
C<False> and vice-versa.  Other programming languages may name their
corresponding operators I<~> or I<^> or I<N>.

=head2 and ∧

    ::MD::and ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity (True)
        : (\.0 ?? \.1 !! False);

    ::MD::Unicode_Aliases::"∧" ::= alias of and;

The function C<and> aka C<∧> performs a logical I<conjunction>; it results
in C<True> iff its 2 arguments C<0> and C<1> are both C<True>, and C<False>
otherwise.  Other programming languages may name their corresponding
operators I<&> or I<&&> or I<K>.

=head2 nand not_and ⊼ ↑

    ::MD::nand ::= function negates and
        is commutative;

    ::MD::not_and ::= alias of nand;

    ::MD::Unicode_Aliases::"⊼" ::= alias of nand;
    ::MD::Unicode_Aliases::"↑" ::= alias of nand;

The function C<nand> aka C<not_and> aka C<⊼> aka C<↑> performs a logical
I<alternative denial>; it results in C<False> iff its 2 arguments C<0> and
C<1> are both C<True>, and C<True> otherwise.

=head2 or ∨

    ::MD::or ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity (False)
        : (\.0 ?? True !! \.1);

    ::MD::Unicode_Aliases::"∨" ::= alias of or;

The function C<or> aka C<∨> performs a logical I<disjunction>; it results
in C<True> iff at least one of its 2 arguments C<0> and C<1> is C<True>,
and C<False> otherwise.  Other programming languages may name their
corresponding operators I<|> or I<||> or I<A>.

=head2 nor not_or ⊽ ↓

    ::MD::nor ::= function negates or
        is commutative;

    ::MD::not_or ::= alias of nor;

    ::MD::Unicode_Aliases::"⊽" ::= alias of nor;
    ::MD::Unicode_Aliases::"↓" ::= alias of nor;

The function C<nor> aka C<not_or> aka C<⊽> aka C<↓> performs a logical
I<joint denial>; it results in C<False> iff at least one of its 2 arguments
C<0> and C<1> is C<True>, and C<True> otherwise.

=head2 xnor iff ↔

    ::MD::xnor ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative} identity (True)
        : (topic --> \@same);

    ::MD::iff ::= alias of xnor;

    ::MD::Unicode_Aliases::"↔" ::= alias of xnor;

The function C<xnor> aka C<iff> aka C<↔> performs a logical
I<biconditional> or I<material equivalence> or I<even parity>; it results
in C<True> iff its 2 arguments C<0> and C<1> are exactly the same value,
and C<False> otherwise.  This function is effectively a C<Boolean>-specific
alias of the function C<same> aka C<=>.  Other programming languages may
name their corresponding operators I<E>.

=head2 xor ⊻ ↮

    ::MD::xor ::= function negates xnor
        is {associative,commutative} identity (False);

    ::MD::Unicode_Aliases::"⊻" ::= alias of xor;
    ::MD::Unicode_Aliases::"↮" ::= alias of xor;

The function C<xor> aka C<⊻> aka C<↮> performs a logical I<exclusive
disjunction> or I<odd parity>; it results in C<False> iff its 2 arguments
C<0> and C<1> are exactly the same value, and C<True> otherwise.  This
function is effectively a C<Boolean>-specific alias of the function
C<not_same> aka C<!=> aka C<≠>.  Other programming languages may name their
corresponding operators I<^>.

=head2 imp implies →

    ::MD::imp ::= function --> Boolean <-- (Boolean, Boolean)
        : (\.0 ?? \.1 !! True);

    ::MD::implies ::= alias of imp;

    ::MD::Unicode_Aliases::"→" ::= alias of imp;

The function C<imp> aka C<implies> aka C<→> performs a logical I<material
implication>; it results in C<False> when its C<0> argument is C<True> and
its C<1> argument is C<False>, and C<True> otherwise.

=head2 nimp not_implies ↛

    ::MD::nimp ::= function negates imp;

    ::MD::not_implies ::= alias of nimp;

    ::MD::Unicode_Aliases::"↛" ::= alias of nimp;

The function C<nimp> aka C<not_implies> aka C<↛> performs a logical
I<material nonimplication>; it results in C<True> when its C<0> argument is
C<True> and its C<1> argument is C<False>, and C<False> otherwise.

=head2 if ←

    ::MD::if ::= function commutes imp;

    ::MD::Unicode_Aliases::"←" ::= alias of if;

The function C<if> aka C<←> performs a logical I<converse implication> or
I<reverse material implication>; it results in C<False> when its C<0>
argument is C<False> and its C<1> argument is C<True>, and C<True>
otherwise.

=head2 nif not_if ↚

    ::MD::nif ::= function commutes nimp;

    ::MD::not_if ::= alias of nif;

    ::MD::Unicode_Aliases::"↚" ::= alias of nif;

The function C<nif> aka C<not_if> aka C<↚> performs a logical I<converse
nonimplication>; it results in C<True> when its C<0> argument is C<False>
and its C<1> argument is C<True>, and C<False> otherwise.

=head1 ROUNDING INSTRUCTION DATA TYPES

=head2 Round_Meth

    ::MD::Round_Meth::"" ::= selection
        union {2::Down,2::Up,2::To_Zero,2::To_Inf
            ,2::Half_Down,2::Half_Up,2::Half_To_Zero,2::Half_To_Inf
            ,2::Half_Even,2::Half_Odd}
        default (2::To_Zero());

    ::MD::Round_Meth::Down         ::= constant (\@0);
    ::MD::Round_Meth::Up           ::= constant (\@0);
    ::MD::Round_Meth::To_Zero      ::= constant (\@0);
    ::MD::Round_Meth::To_Inf       ::= constant (\@0);
    ::MD::Round_Meth::Half_Down    ::= constant (\@0);
    ::MD::Round_Meth::Half_Up      ::= constant (\@0);
    ::MD::Round_Meth::Half_To_Zero ::= constant (\@0);
    ::MD::Round_Meth::Half_To_Inf  ::= constant (\@0);
    ::MD::Round_Meth::Half_Even    ::= constant (\@0);
    ::MD::Round_Meth::Half_Odd     ::= constant (\@0);

The selection contract C<Round_Meth> is finite.  When a value of some
C<Orderable> type needs to be mapped into a proper subtype that doesn't
contain that value, such as when mapping an arbitrary number to one with
less precision, some rounding method is applied to determine which value of
the subtype is to be mapped to while most accurately reflecting the
original value.  The C<Round_Meth> type enumerates the rounding methods
that Muldis D operators can typically apply.

With C<Down> (aka I<floor>), C<Up> (aka I<ceiling>), C<To_Zero> (aka
I<truncate>), and C<To_Inf>, the original value will always be mapped to
the single nearest value that is lower than it, or higher than it, or
towards "zero" from it, or towards the nearer infinity from it,
respectively.  With C<Half_Down>, C<Half_Up>, C<Half_To_Zero>,
C<Half_To_Inf>, C<Half_Even> (aka I<unbiased rounding>, I<convergent
rounding>, I<statistician's rounding>, or I<bankers' rounding>), and
C<Half_Odd> the original value will be mapped to the single target value
that it is nearest to, if there is one; otherwise, if it is exactly
half-way between 2 adjacent target values, then C<Half_Down> will round
towards negative infinity, C<Half_Up> will round towards positive infinity,
C<Half_To_Zero> will round towards "zero", C<Half_To_Inf> will round
towards the nearer infinity, while C<Half_Even> and C<Half_Odd> will round
towards the nearest "even" or "odd" target respectively.

The default value of C<Round_Meth> is C<To_Zero>, which is the simplest.
Other programming languages may name their corresponding types
I<RoundingMode> (Java) or I<MidpointRounding> (C#).

=head1 NUMERICAL DATA TYPES

=head2 Numerical

    ::MD::Numerical ::= interface
        composes Boolable
        requires_implements {so
            ,zero,opposite,reciprocal,modulus
            ,plus,minus,times,multiple_of
            ,fractional_divided_by,integral_divided_by
            ,integral_power,integral_nn_power};

The interface contract C<Numerical> is infinite.  A C<Numerical> value
either is a simple number of some kind or is something that can act as a
simple number.  A I<simple number> means, typically speaking, any rational
real number, those numbers that can be derived simply by multiplying or
dividing integers.  All operators defined by the C<Core> package
for C<Numerical> are expect to be closed over the real rational numbers,
and consist mainly of addition, subtraction, multiplication, and division
of any rationals, plus exponentiation of any rationals to integer powers
only.  Idiomatically a C<Numerical> is a pure number which does not
represent any kind of thing in particular, neither cardinal nor ordinal nor
nominal; however some types which do represent such a particular kind of
thing may choose to compose C<Numerical> because it makes sense to provide
its operators.  The default value of C<Numerical> is the C<Integer> value
C<0>.  A C<Numerical> in the general case is not C<Orderable>, but often a
type that is numeric is also orderable.  Other programming languages may
name their corresponding types I<Numeric>.

C<Numerical> is composed, directly or indirectly, by: C<Integral>,
C<Integer>, C<Fractional>, C<Fraction>, C<Quantity>.  It is also composed
by a lot of additional contracts defined by other Muldis D packages such as
L<Core::Math|Muldis::D::Package::Core::Math>; these include types for
irrational or algebraic or complex numbers or quaternions or rational types
with a fixed precision or scale or floating-point types and so on.

=head2 Excuse::Div_By_Zero

    ::MD::Excuse::Div_By_Zero ::= constant (\@0) composes Excuse;

The constant C<Excuse::Div_By_Zero> represents the I<undefined> result of
attempting to divide a simple number by a simple, unsigned, number zero.
Note that IEEE floating-point standards define a negative or positive
infinity result value when dividing by an explicitly signed (negative or
positive) zero, but the Muldis D C<Core> package lacks those concepts.

=head2 Excuse::Zero_To_The_Zero

    ::MD::Excuse::Zero_To_The_Zero ::= constant (\@0) composes Excuse;

The constant C<Excuse::Zero_To_The_Zero> represents the I<undefined> result
of attempting to exponentiate a number zero to the power of a number zero.

=head2 so (Numerical)

    ::MD::so::Numerical ::= function virtual --> Boolean <-- (Numerical)
        implements 2::"";

The virtual function C<so::Numerical> results in C<True> when its C<0>
argument is a nonzero number; otherwise it results in C<False>.  This
function implements the C<Boolable> virtual function C<so> aka C<?> aka
C<to_Boolean> for the composing type C<Numerical>.

=head2 is_zero

    ::MD::is_zero ::= function negates so::Numerical;

The function C<is_zero> results in C<True> when its C<0> argument is a
number zero; otherwise it results in C<False>.

=head2 zero

    ::MD::zero::"" ::= function virtual --> Numerical <-- (Numerical);

The virtual function C<zero> results in the number zero of its C<0>
argument's numerical type, assuming that every type composing C<Numerical>
has one.

=head2 opposite

    ::MD::opposite::"" ::= function virtual --> Numerical <-- (Numerical);

    ::MD::additive_inverse ::= alias of opposite;

The virtual function C<opposite> aka C<additive_inverse> aka unary C<-> aka
unary C<−> results in the numeric I<opposite> or I<negation> or I<additive
inverse> or I<unary minus> of its C<0> argument, and is a shorthand for
either multiplying that argument by negative one or subtracting it from
zero.  By definition, the sum of a number and its opposite is zero.

=head2 reciprocal

    ::MD::reciprocal::"" ::= function virtual
        --> {Numerical, Excuse::Div_By_Zero} <-- (Numerical);

    ::MD::multiplicative_inverse ::= alias of reciprocal;

The virtual function C<reciprocal> aka C<multiplicative_inverse> results in
the numeric I<reciprocal> or I<multiplicative inverse> of its nonzero C<0>
argument, and is a shorthand for dividing one by that argument.  By
definition, the product of a number and its reciprocal is one.  The result
is always C<Fractional> for both C<Integral> and C<Fractional> arguments.
The result is only I<defined> when the argument is a nonzero number; it is
an C<Excuse> otherwise.

=head2 modulus abs

    ::MD::modulus::"" ::= function virtual --> Numerical <-- (Numerical);

    ::MD::abs ::= alias of modulus;

The virtual function C<modulus> aka C<abs> results in the numeric
I<modulus> or I<absolute value> of its C<0> argument, which is the
(non-negative) distance between that argument and zero.  Note that typical
mathematical notion writes this operator in circumfix like I<|n|>.

=head2 plus +

    ::MD::plus::"" ::= function virtual
        --> Numerical <-- (Numerical, Numerical)
        is {associative,commutative}
        repeater times;

    ::MD::"+" ::= alias of plus;

The virtual function C<plus> aka C<+> results in the numeric I<sum> from
performing I<addition> of its 2 I<summand> arguments C<0> (I<augend>) and
C<1> (I<addend>).  This operation has an identity value of a number zero.

=head2 minus

    ::MD::minus::"" ::= function virtual
        --> Numerical <-- (Numerical, Numerical);

The virtual function C<minus> aka binary C<-> aka binary C<−> results in
the numeric I<difference> from performing I<subtraction> of its 2 arguments
C<0> (I<minuend>) and C<1> (I<subtrahend>).

=head2 - −

    ::MD::"-" ::= function
        --> Numerical <-- {(Numerical), (Numerical, Numerical)}
        : (topic --> (degree(topic) = 1 ?? \@opposite !! \@minus));

    ::MD::Unicode_Aliases::"−" ::= alias of "-";

The function C<-> aka C<−> is a proxy for either of the virtual functions
unary C<opposite> and binary C<minus>, depending on how many arguments it
was invoked with.

=head2 modulus_minus abs_minus |-| |−|

    ::MD::modulus_minus ::= function
        --> Numerical <-- (Numerical, Numerical)
        is commutative
        : (modulus topic --> \@minus);

    ::MD::abs_minus ::= alias of modulus_minus;
    ::MD::"|-|"     ::= alias of modulus_minus;

    ::MD::Unicode_Aliases::"|−|" ::= alias of modulus_minus;

The function C<modulus_minus> aka C<abs_minus> aka C<|-|> aka C<|−|>
results in the numeric I<absolute difference> of its 2 arguments C<0> and
C<1>, which is the (non-negative) distance between those arguments.

=head2 times * ×

    ::MD::times::"" ::= function virtual
        --> Numerical <-- (Numerical, Numerical)
        is {associative,commutative}
        repeater integral_nn_power;

    ::MD::"*" ::= alias of times;

    ::MD::Unicode_Aliases::"×" ::= alias of times;

The virtual function C<times> aka C<*> aka C<×> results in the numeric
I<product> from performing I<multiplication> of its 2 I<factor> arguments
C<0> (I<multiplier>) and C<1> (I<multiplicand>).  This operation has an
identity value of a number positive one.

=head2 multiple_of

    ::MD::multiple_of::"" ::= function virtual
        --> {Boolean, Excuse::Div_By_Zero} <-- (Numerical, Numerical);

The virtual function C<multiple_of> results in C<True> iff its C<0>
argument is an even multiple of its C<1> argument (that is, the former is
evenly divisible by the latter), and C<False> otherwise.  The result is
only I<defined> when the C<1> argument is a nonzero number; it is an
C<Excuse> otherwise.  Other programming languages may name their
corresponding operators I<%%>.

=head2 nearest_multiple_of round

    ::MD::nearest_multiple_of ::= function
        --> {Numerical, Excuse::Div_By_Zero}
        <-- (Numerical, Numerical, Round_Meth)
        : (if \.1->is_zero then Excuse::Div_By_Zero()
            else \.1 * topic --> \@div);

    ::MD::round ::= alias of nearest_multiple_of;

The function C<nearest_multiple_of> aka C<round> results in the same or
nearest number to its C<0> argument that is an even multiple of its C<1>
argument (that is, the result is evenly divisible by the latter), where the
nearest is determined by the rounding method specified by the C<2>
argument.  For the common case of rounding to the nearest integer, use a
C<1> argument of positive one.  The result is C<Integral> for C<Integral>
arguments and is C<Fractional> for C<Fractional> arguments.  The result is
only I<defined> when the C<1> argument is a nonzero number; it is an
C<Excuse> otherwise.  Other programming languages may name their
corresponding operators I<truncate> or I<int> or I<floor> or I<ceil> or
other things, some of which would always round to a multiple of one.

=head2 fractional_divided_by / ÷ ∕

    ::MD::fractional_divided_by::"" ::= function virtual
        --> {Numerical, Excuse::Div_By_Zero} <-- (Numerical, Numerical);

    ::MD::"/" ::= alias of fractional_divided_by;

    ::MD::Unicode_Aliases::"÷" ::= alias of fractional_divided_by;
    ::MD::Unicode_Aliases::"∕" ::= alias of fractional_divided_by;

The virtual function C<fractional_divided_by> aka C</> aka C<÷> aka C<∕>
results in the typically-fractional numeric I<quotient> from performing
I<division> of its 2 arguments C<0> (I<dividend> or I<numerator>) and C<1>
(I<divisor> or I<denominator>) using the semantics of real number division.
The result is always C<Fractional> for both C<Integral> and C<Fractional>
arguments; as such, C<fractional_divided_by> is the idiomatic way to select
any C<Fraction> values in terms of C<Integer> values.  The result is only
I<defined> when the C<1> argument is a nonzero number; it is an C<Excuse>
otherwise.

=head2 integral_divided_by div

    ::MD::integral_divided_by::"" ::= function virtual
        --> {Numerical, Excuse::Div_By_Zero}
        <-- (Numerical, Numerical, Round_Meth);

    ::MD::div ::= alias of integral_divided_by;

The virtual function C<integral_divided_by> aka C<div> results in the
integral numeric I<quotient> from performing I<division> of its 2 arguments
C<0> (I<dividend> or I<numerator>) and C<1> (I<divisor> or I<denominator>)
using the semantics of real number division, whereupon the real number
result is rounded to the same or nearest integral number, where the nearest
is determined by the rounding method specified by the C<2> argument.  The
result is C<Integral> for C<Integral> arguments and is C<Fractional> with a
I<denominator> of one for C<Fractional> arguments.  The result is only
I<defined> when the C<1> argument is a nonzero number; it is an C<Excuse>
otherwise.

=head2 modulo mod

    ::MD::modulo ::= function
        --> {Numerical, Excuse::Div_By_Zero}
        <-- (Numerical, Numerical, Round_Meth)
        : (if \.1->is_zero then Excuse::Div_By_Zero()
            else \.0 - topic --> \@nearest_multiple_of);

    ::MD::mod ::= alias of modulo;

The function C<modulo> aka C<mod> results in the possibly-fractional
numeric I<remainder> from performing same I<division> operation as
C<integral_divided_by> does with all of the same arguments; to be specific,
C<modulo> preserves the identity C<x mod y = x - y * (x div y)>.  The
result is C<Integral> for C<Integral> arguments and is C<Fractional> for
C<Fractional> arguments.  The result is only I<defined> when the C<1>
argument is a nonzero number; it is an C<Excuse> otherwise.  Other
programming languages may name their corresponding operators I<%> or I<//>
or I<\\> or I<div> or I<rem> or I<remainder> or various other things.

=head2 divided_by_and_modulo

    ::MD::divided_by_and_modulo::"" ::= function
        --> ({Numerical, Excuse::Div_By_Zero}, {Numerical, Excuse::Div_By_Zero})
        <-- (Numerical, Numerical, Round_Meth)
        : (\%(topic --> \@div, topic --> \@mod));

The function C<divided_by_and_modulo> results in a binary tuple whose C<0>
and C<1> attributes have the exact same values that C<integral_divided_by>
and C<modulo> would result in, respectively, when each is given all of the
same arguments.  This function is a shorthand for invoking the other two.

=head2 integral_power **

    ::MD::integral_power::"" ::= function virtual
        --> {Numerical, Excuse::Zero_To_The_Zero} <-- (Numerical, Integral);

    ::MD::"**" ::= alias of integral_power;

The virtual function C<integral_power> aka C<**> results in a
typically-fractional number from performing I<exponentiation> of its 2
arguments C<0> (I<base>) and C<1> (I<exponent> or I<power>).  The result is
always C<Fractional> for both an C<Integral> and a C<Fractional> C<0>
argument.  The result is only I<defined> when the C<0> and C<1> arguments
are both nonzero numbers; it is an C<Excuse> otherwise.  Other programming
languages may name their corresponding operators I<exp> or I<^>.

=head2 integral_nn_power power

    ::MD::integral_nn_power::"" ::= function virtual
        --> {Numerical, Excuse::Zero_To_The_Zero} <-- (Numerical, Integral_NN);

    ::MD::power ::= alias of integral_nn_power;

The virtual function C<integral_nn_power> aka C<power> results in a
possibly-fractional number from performing I<exponentiation> of its 2
arguments C<0> (I<base>) and C<1> (I<exponent> or I<power>).  The result is
C<Integral> for an C<Integral> C<0> argument and is C<Fractional> for a
C<Fractional> C<0> argument.  The result is only I<defined> when the C<0>
and C<1> arguments are both nonzero numbers; it is an C<Excuse> otherwise.

=head1 INTEGRAL DATA TYPES

=head2 Integral

    ::MD::Integral ::= interface
        composes {Bicessable and_provides_its_default,
            Numerical and_provides_its_default}
        requires_implements {in_order,asset,pred,succ
            ,so
            ,zero,opposite,reciprocal,modulus
            ,plus,minus,times,multiple_of
            ,fractional_divided_by,integral_divided_by
            ,integral_power,integral_nn_power
            ,to_Integer,factorial};

The interface contract C<Integral> is infinite.  An C<Integral> value
either is an exact integral number of some kind or is something that can
act as such.  Idiomatically an C<Integral> is a pure integer which does not
represent any kind of thing in particular, neither cardinal nor ordinal nor
nominal; however some types which do represent such a particular kind of
thing may choose to compose C<Integral> because it makes sense to provide
its operators.  The default value of C<Integral> is the C<Integer> value
C<0>.  C<Integral> is both C<Orderable> and C<Bicessable>.  For each type
composing C<Integral>, a value closer to negative infinity is ordered
before a value closer to positive infinity, and the definition of
I<predecessor> and I<successor> is exactly equal to subtracting or adding
an integer positive-one respectively, while other C<Bicessable> don't
generally mean that.  In the general case, C<Integral> has no minimum or
maximum value, but often a type that is C<Integral> will have them.
C<Integral> is composed by C<Integer>.

=head2 Integral_NN

    ::MD::Integral_NN ::= selection of Integral
        where (topic >= zero(topic));

The selection contract C<Integral_NN> represents the infinite type
consisting just of the C<Integral> values that are non-negative.  Its
default and minmum value is C<0>; it has no maximum value.

=head2 Integral_P

    ::MD::Integral_P ::= selection of Integral_NN
        where (topic > zero(topic)) default (succ(Integral()));

The selection contract C<Integral_P> represents the infinite type
consisting just of the C<Integral_NN> values that are positive.  Its
default and minmum value is C<1>; it has no maximum value.

=head2 pred (Integral)

    ::MD::pred::Integral ::= function virtual --> Integral <-- (Integral)
        implements 2::"";

    ::MD::"--" ::= alias of pred::Integral;

The virtual function C<pred::Integral> aka C<--> implements the
C<Bicessable> virtual function C<pred> for the composing type C<Integral>.
Other programming languages may name their corresponding operators
I<decrement>.

=head2 succ (Integral)

    ::MD::succ::Integral ::= function virtual --> Integral <-- (Integral)
        implements 2::"";

    ::MD::"++" ::= alias of succ::Integral;

The virtual function C<succ::Integral> aka C<++> implements the
C<Successable> virtual function C<succ> for the composing type C<Integral>.
Other programming languages may name their corresponding operators
I<increment>.

=head2 to_Integer

    ::MD::to_Integer::"" ::= function virtual --> Integer <-- (Integral);

The virtual function C<to_Integer> results in the C<Integer> value that
represents the same integer value as its C<0> argument.  The purpose of
C<to_Integer> is to canonicalize C<Integral> values so they can be compared
abstractly as integers, or so that it is easier to do exact math with
integers without running afoul of possible range limits of fixed-size
C<Integral> types, just dealing with the latter for storage.

=head2 factorial

    ::MD::factorial::"" ::= function virtual --> Integral_P <-- (Integral_NN);

The virtual function C<factorial> results in the integral numeric
I<factorial> of its C<0> argument, and is a shorthand for the product of
every integer between 1 and that argument; the factorial of zero is defined
to result in positive one.  Note that typical mathematical notion writes
this operator in postfix like I<n!>.

=head2 gcd greatest_common_divisor

    ::MD::gcd ::= function --> Integral_P <-- (Integral_NN, Integral_NN)
        is {commutative,associative,idempotent}
        : ((if \.1->is_zero then \.0 else 0::(\.1, mod(\.0, \.1, To_Zero())))
            ::?= 'Calculate using the Euclidean algorithm.');

    ::MD::greatest_common_divisor ::= alias of gcd;

The function C<gcd> aka C<greatest_common_divisor> results in the integral
numeric I<greatest common divisor> of its 2 arguments C<0> and C<1>, which
is the largest integer that will divide both arguments evenly.
I<TODO: Look into generalizing it to take negative integer arguments too.>

=head2 lcm least_common_multiple

    ::MD::lcm ::= function --> Integral_NN <-- (Integral_NN, Integral_NN)
        is {commutative,associative,idempotent}
        : (if \.0->is_zero or \.1->is_zero then \.0->zero
            else div(\.0 * \.1, \.0 gcd \.1, To_Zero()));

    ::MD::least_common_multiple ::= alias of lcm;

The function C<lcm> aka C<least_common_multiple> results in the integral
numeric I<least common multiple> of its 2 arguments C<0> and C<1>, which
is the smallest integer that is an even multiple of both arguments.
I<TODO: Look into generalizing it to take negative integer arguments too.>

=head2 coprime

    ::MD::coprime ::= function --> Boolean <-- (Integral, Integral)
        : ((abs(\.0) gcd abs(\.1)) = (\.0->zero->succ));

The function C<coprime> results in C<True> iff its 2 arguments C<0> and
C<1> are coprime (their I<greatest common divisor> is 1), and C<False>
otherwise.

=head1 INTEGER DATA TYPES

=head2 Integer

    ::MD::Integer ::= selection where (topic -->^ FDN__is_a_Integer)
        default (0)
        composes Integral and_provides_its_default;

The selection contract C<Integer> represents
the infinite Muldis D Foundation type I<FDN__Integer>.  An C<Integer>
value is a general purpose exact integral number of any magnitude, which
explicitly does not represent any kind of thing in particular, neither
cardinal nor ordinal nor nominal.  Its default value is C<0>.  C<Integer>
is both C<Orderable> and C<Bicessable>; it has no minimum or maximum value.
Other programming languages may name their corresponding types I<BigInt>.

=head2 Integer_NN

    ::MD::Integer_NN ::= selection of Integer where (topic >= 0);

The selection contract C<Integer_NN> represents the infinite type
consisting just of the C<Integer> values that are non-negative.  Its
default and minmum value is C<0>; it has no maximum value.

=head2 Integer_P

    ::MD::Integer_P ::= selection of Integer_NN where (topic > 0) default (1);

The selection contract C<Integer_P> represents the infinite type consisting
just of the C<Integer_NN> values that are positive.  Its default and minmum
value is C<1>; it has no maximum value.

=head2 in_order (Integer)

    ::MD::in_order::Integer ::= function --> Boolean <-- (Integer, Integer)
        implements 2::""
        : (topic -->^ FDN__Integer_in_order);

The function C<in_order::Integer> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Integer>.

=head2 asset (Integer)

    ::MD::asset::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (\.0);

The function C<asset::Integer> simply results in its C<0> argument.
This function implements the C<Successable> virtual function C<asset> for
the composing type C<Integer>.

=head2 pred (Integer)

    ::MD::pred::Integer ::= function --> Integer <-- (Integer)
        implements 2::Integral
        : (\.0 - 1);

The function C<pred::Integer> implements the C<Bicessable>/C<Integral>
virtual function C<pred> aka C<--> for the composing type C<Integer>.

=head2 succ (Integer)

    ::MD::succ::Integer ::= function --> Integer <-- (Integer)
        implements 2::Integral
        repeater plus::Integer
        : (\.0 + 1);

The function C<succ::Integer> implements the C<Successable>/C<Integral>
virtual function C<succ> aka C<++> for the composing type C<Integer>.

=head2 so (Integer)

    ::MD::so::Integer ::= function --> Boolean <-- (Integer)
        implements 2::""
        : (\.0 != 0);

The function C<so::Integer> results in C<True> iff its C<0> argument is not
C<0>, and in C<False> if it is C<0>.  This function implements the
C<Boolable> virtual function C<so> aka C<?> aka C<to_Boolean> for the
composing type C<Integer>.

=head2 zero (Integer)

    ::MD::zero::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (0);

The function C<zero::Integer> simply results in C<0>.  This function
implements the C<Numerical> virtual function C<zero> for the composing type
C<Integer>.

=head2 opposite (Integer)

    ::MD::opposite::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (topic -->^ FDN__Integer_opposite);

The function C<opposite::Integer> implements the C<Numerical> virtual
function C<opposite> aka C<additive_inverse> aka unary C<-> aka unary C<−>
for the composing type C<Integer>.

=head2 reciprocal (Integer)

    ::MD::reciprocal::Integer ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Integer)
        implements 2::""
        : (1 / \.0);

The function C<reciprocal::Integer> implements the C<Numerical> virtual
function C<reciprocal> aka C<multiplicative_inverse> for the composing type
C<Integer>.

=head2 modulus (Integer)

    ::MD::modulus::Integer ::= function --> Integer_NN <-- (Integer)
        implements 2::""
        : (topic -->^ FDN__Integer_modulus);

The function C<modulus::Integer> implements the C<Numerical>
virtual function C<modulus> aka C<abs> for the composing type C<Integer>.

=head2 plus (Integer)

    ::MD::plus::Integer ::= function --> Integer <-- (Integer, Integer)
        implements 2::""
        is {associative,commutative} identity (0)
        repeater times::Integer
        : (topic -->^ FDN__Integer_plus);

The function C<plus::Integer> implements the C<Numerical>
virtual function C<plus> aka C<+> for the composing type C<Integer>.

=head2 minus (Integer)

    ::MD::minus::Integer ::= function --> Integer <-- (Integer, Integer)
        implements 2::""
        : (topic -->^ FDN__Integer_minus);

The function C<minus::Integer> implements the C<Numerical> virtual function
C<minus> aka binary C<-> aka binary C<−> for the composing type C<Integer>.

=head2 times (Integer)

    ::MD::times::Integer ::= function --> Integer <-- (Integer, Integer)
        implements 2::""
        is {associative,commutative} identity (1)
        repeater integral_nn_power::Integer
        : (topic -->^ FDN__Integer_times);

The function C<times::Integer> implements the C<Numerical> virtual function
C<times> aka C<*> aka C<×> for the composing type C<Integer>.

=head2 multiple_of (Integer)

    ::MD::multiple_of::Integer ::= function
        --> {Boolean, Excuse::Div_By_Zero} <-- (Integer, Integer)
        implements 2::""
        : (if \.1 = 0 then Excuse::Div_By_Zero()
            else topic -->^ FDN__Integer_multiple_of);

The function C<multiple_of::Integer> implements the C<Numerical>
virtual function C<multiple_of> for the composing type C<Integer>.

=head2 fractional_divided_by (Integer)

    ::MD::fractional_divided_by::Integer ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Integer, Integer)
        implements 2::""
    : (
        n ::= \.0;
        d ::= \.1;

        <-- if d = 0 then Excuse::Div_By_Zero() else q;

        q ::= (\Fraction wrap \%(
            numerator   : div((d > 0 ?? n !! -n), gcd, To_Zero()),
            denominator : div((d > 0 ?? d !! -d), gcd, To_Zero()),
        ));

        gcd ::= gcd(abs(n), abs(d));
    );

The function C<fractional_divided_by::Integer> implements the C<Numerical>
virtual function C<fractional_divided_by> aka C</> aka C<÷> aka C<∕> for
the composing type C<Integer>.

=head2 integral_divided_by (Integer)

    ::MD::integral_divided_by::Integer ::= function
        --> {Integer, Excuse::Div_By_Zero}
        <-- (Integer, Integer, Round_Meth)
        implements 2::""
    : (
        dividend   ::= \.0;
        divisor    ::= \.1;
        round_meth ::= \.2;

        <-- if divisor = 0 then Excuse::Div_By_Zero() else e1;

        e1 ::?= 'This is the case where we are dividing by a non-zero.';

        e1 ::= (
               dividend = 0       ?? 0
            !! divisor  = 1       ?? dividend
            !! dividend = divisor ?? 1
            !! divisor  = -1      ?? -dividend
            !!                       e2
        );

        e2 ::?= 'This is the case where the divisor and dividend do not'
            ' equal each other and neither of them is a zero or a one.';

        e2 ::= (
            real_q_is_neg ::= (dividend < 0 xor divisor < 0);
            rtz_quotient  ::= (FDN__Integer_divided_by_rtz
                ^<-- \%(dividend, divisor));
            rtz_remainder ::= (dividend - (divisor * rtz_quotient));

            <-- rtz_remainder = 0 ?? rtz_quotient !! e3;
        );

        e3 ::?= 'This is the case where the divisor does not divide the'
            ' dividend evenly and the real number division result would'
            ' have a fractional part, so we decide how to round that.';

        e3 ::= (
            rti_quotient ::= (rtz_quotient + (real_q_is_neg ?? -1 !! 1));
            rdn_quotient ::= (rtz_quotient + (real_q_is_neg ?? -1 !! 0));
            rup_quotient ::= (rtz_quotient + (real_q_is_neg ??  0 !! 1));

            <-- round_meth ??? {
                Down()    : rdn_quotient,
                Up()      : rup_quotient,
                To_Zero() : rtz_quotient,
                To_Inf()  : rti_quotient,
            } !!!
                   (2 * abs(rtz_remainder)) < abs(divisor) ?? rtz_quotient
                !! (2 * abs(rtz_remainder)) > abs(divisor) ?? rti_quotient
                !! e4
            ;
        );

        e4 ::?= 'This is the case where real division remainder is'
            ' exactly one-half so we decide how to round that.';

        e4 ::= (
            q ::= (FDN__Integer_divided_by_rtz ^<-- \%(abs(rtz_quotient),2))
            r ::= (abs(rtz_quotient) - (2 * q));
            rtz_quotient_is_even ::= (r = 0);

            <-- round_meth ??? {
                Half_Down()    : rdn_quotient,
                Half_Up()      : rup_quotient,
                Half_To_Zero() : rtz_quotient,
                Half_To_Inf()  : rti_quotient,
                Half_Even()    :
                  (rtz_quotient_is_even ?? rtz_quotient !! rti_quotient),
                Half_Odd()     :
                  (rtz_quotient_is_even ?? rti_quotient !! rtz_quotient),
            } !!! fail  `oops, an unhandled case`
        );
    );

The function C<integral_divided_by::Integer> implements the C<Numerical>
virtual function C<integral_divided_by> aka C<div> for the composing type
C<Integer>.

=head2 integral_power (Integer)

    ::MD::integral_power::Integer ::= function
        --> {Fraction, Excuse::Zero_To_The_Zero} <-- (Integer, Integer)
        implements 2::""
        : (if \.0 = 0 and \.1 = 0 then Excuse::Zero_To_The_Zero()
            else \.0 / 1 ** \.1);

The function C<integral_power::Integer> implements the C<Numerical> virtual
function C<integral_power> aka C<**> for the composing type C<Integer>.

=head2 integral_nn_power (Integer)

    ::MD::integral_nn_power::Integer ::= function
        --> {Integer, Excuse::Zero_To_The_Zero} <-- (Integer, Integer_NN)
        implements 2::""
        : (if \.0 = 0 and \.1 = 0 then Excuse::Zero_To_The_Zero()
            else topic -->^ FDN__Integer_nn_power);

The function C<integral_nn_power::Integer> implements the C<Numerical>
virtual function C<integral_nn_power> aka C<power> for the composing type
C<Integer>.

=head2 to_Integer (Integer)

    ::MD::to_Integer::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (\.0);

The function C<to_Integer::Integer> simply results in its C<0> argument.
This function implements the C<Integral> virtual function C<to_Integer> for
the composing type C<Integer>.

=head2 factorial (Integer)

    ::MD::factorial::Integer ::= function --> Integer_P <-- (Integer_NN)
        implements 2::""
        : (topic -->^ FDN__Integer_factorial);

The function C<factorial::Integer> implements the C<Integral> virtual
function C<factorial> for the composing type C<Integer>.

=head1 FRACTIONAL DATA TYPES

=head2 Fractional

    ::MD::Fractional ::= interface
        composes {Orderable and_provides_its_default,
            Numerical and_provides_its_default}
        requires_implements {in_order
            ,so
            ,zero,opposite,reciprocal,modulus
            ,plus,minus,times,multiple_of
            ,fractional_divided_by,integral_divided_by
            ,integral_power,integral_nn_power
            ,to_Fraction,numerator,denominator};

The interface contract C<Fractional> is infinite.  A C<Fractional> value
either is a rational exact numeric of some kind, expressible as a coprime
I<numerator> / I<denominator> pair of C<Integral> whose I<denominator> is
positive, or is something that can act as such.  Idiomatically a
C<Fractional> is a pure rational number which does not represent any kind
of thing in particular, neither cardinal nor ordinal nor nominal; however
some types which do represent such a particular kind of thing may choose to
compose C<Fractional> because it makes sense to provide its operators.  The
default value of C<Fractional> is the C<Fraction> value C<0.0>.
C<Fractional> is C<Orderable>; for each type composing C<Fractional>, a
value closer to negative infinity is ordered before a value closer to
positive infinity.  In the general case it is not C<Bicessable> nor does it
have a minimum or maximum value, but sometimes a type that is C<Fractional>
will have either of those.  C<Fractional> is composed by C<Fraction>.

=head2 Fractional_NN

    ::MD::Fractional_NN ::= selection of Fractional
        where (topic >= zero(topic));

The selection contract C<Fractional_NN> represents the infinite type
consisting just of the C<Fractional> values that are non-negative.  Its
default and minmum value is C<0.0>; it has no maximum value.

=head2 to_Fraction

    ::MD::to_Fraction::"" ::= function virtual --> Fraction <-- (Fractional);

The virtual function C<to_Fraction> results in the C<Fraction> value that
represents the same rational value as its C<0> argument.  The purpose of
C<to_Fraction> is to canonicalize C<Fractional> values so they can be
compared abstractly as rationals, or so that it is easier to do exact math
with rationals without running afoul of possible range limits of fixed-size
C<Fractional> types, just dealing with the latter for storage.

=head2 numerator

    ::MD::numerator::"" ::= function virtual --> Integral <-- (Fractional);

The virtual function C<numerator> results in the I<numerator> of its
C<0> argument, when the latter is expressed as a coprime I<numerator> /
I<denominator> pair of C<Integral> whose I<denominator> is positive.

=head2 denominator

    ::MD::denominator::"" ::= function virtual --> Integral_P <-- (Fractional);

The virtual function C<denominator> results in the I<denominator> of its
C<0> argument, when the latter is expressed as a coprime I<numerator> /
I<denominator> pair of C<Integral> whose I<denominator> is positive.

=head1 FRACTION DATA TYPES

=head2 Fraction

    ::MD::Fraction ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped( topic, \Fraction, \@1::_Asset ))
            default (0.0)
            composes Fractional and_provides_its_default;

        _Asset ::= selection of Tuple where
        (
            if
                topic ^?= \%(
                    numerator : \@Integer,
                    denominator : \@Integer_P,
                )
            then
                \.numerator coprime \.denominator
            else
                False
        );
    };

The selection contract C<Fraction> is infinite.  A
C<Fraction> value is a general purpose exact rational number of any
magnitude and precision, expressible as a coprime
I<numerator> / I<denominator> pair of C<Integer> whose I<denominator> is
positive, which explicitly does not represent any kind of thing in
particular, neither cardinal nor ordinal nor nominal.  Its default value is
C<0.0>.  C<Fraction> is C<Orderable>; it has no minimum or maximum value.
Other programming languages may name their corresponding types I<BigRat>.

=head2 Fraction_NN

    ::MD::Fraction_NN ::= selection of Fraction where (topic >= 0.0);

The selection contract C<Fraction_NN> represents the infinite type
consisting just of the C<Fraction> values that are non-negative.  Its
default and minmum value is C<0.0>; it has no maximum value.

=head2 in_order (Fraction)

    ::MD::in_order::Fraction ::= function --> Boolean <-- (Fraction, Fraction)
        implements 2::""
    : (
        <-- (\.0->denominator) = (\.1->denominator)
            ?? in_order(\.0->numerator, \.1->numerator)
         !!
          (
            common_d ::= lcm(\.0->denominator, \.1->denominator);
            <-- in_order(
                (\.0->numerator) * div(common_d, \.0->denominator, To_Zero()),
                (\.1->numerator) * div(common_d, \.1->denominator, To_Zero()),
            );
          )
    );

The function C<in_order::Fraction> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Fraction>.

=head2 so (Fraction)

    ::MD::so::Fraction ::= function --> Boolean <-- (Fraction)
        implements 2::""
        : (\.0 != 0.0);

The function C<so::Fraction> results in C<True> iff its C<0> argument is
not C<0.0>, and in C<False> if it is C<0.0>.  This function implements the
C<Boolable> virtual function C<so> aka C<?> aka C<to_Boolean> for the
composing type C<Fraction>.

=head2 zero (Fraction)

    ::MD::zero::Fraction ::= function --> Fraction <-- (Fraction)
        implements 2::""
        : (0.0);

The function C<zero::Fraction> simply results in C<0.0>.  This function
implements the C<Numerical> virtual function C<zero> for the composing type
C<Fraction>.

=head2 opposite (Fraction)

    ::MD::opposite::Fraction ::= function --> Fraction <-- (Fraction)
        implements 2::""
        : (-(\.0->numerator) / (\.0->denominator));

The function C<opposite::Fraction> implements the C<Numerical> virtual
function C<opposite> aka C<additive_inverse> aka unary C<-> aka unary C<−>
for the composing type C<Fraction>.

=head2 reciprocal (Fraction)

    ::MD::reciprocal::Fraction ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Fraction)
        implements 2::""
        : (if \.0 = 0.0 then Excuse::Div_By_Zero()
            else (\.0->denominator) / (\.0->numerator));

The function C<reciprocal::Fraction> implements the C<Numerical> virtual
function C<reciprocal> aka C<multiplicative_inverse> for the composing type
C<Fraction>.

=head2 modulus (Fraction)

    ::MD::modulus::Fraction ::= function --> Fraction_NN <-- (Fraction)
        implements 2::""
        : (abs(\.0->numerator) / (\.0->denominator));

The function C<modulus::Fraction> implements the C<Numerical>
virtual function C<modulus> aka C<abs> for the composing type C<Fraction>.

=head2 plus (Fraction)

    ::MD::plus::Fraction ::= function --> Fraction <-- (Fraction, Fraction)
        implements 2::""
        is {associative,commutative} identity (0.0)
        repeater times::Fraction_Integer
    : (
        <-- (\.0->denominator) = (\.1->denominator)
            ?? (\.0->numerator) + (\.1->numerator) / (\.0->denominator)
         !!
          (
            common_d ::= lcm(\.0->denominator, \.1->denominator);
            <-- ((\.0->numerator) * div(common_d, \.0->denominator, To_Zero()))
                + ((\.1->numerator) * div(common_d, \.1->denominator, To_Zero()))
                / common_d;
          )
    );

The function C<plus::Fraction> implements the C<Numerical>
virtual function C<plus> aka C<+> for the composing type C<Fraction>.

=head2 minus (Fraction)

    ::MD::minus::Fraction ::= function --> Fraction <-- (Fraction, Fraction)
        implements 2::""
        : (\.0 + (-\.1));

The function C<minus::Fraction> implements the C<Numerical> virtual function
C<minus> aka binary C<-> aka binary C<−> for the composing type C<Fraction>.

=head2 times (Fraction)

    ::MD::times::Fraction ::= function --> Fraction <-- (Fraction, Fraction)
        implements 2::""
        is {associative,commutative} identity (1.0)
        repeater integral_nn_power::Fraction
        : (((\.0->numerator) * (\.1->numerator))
            / ((\.0->denominator) * (\.1->denominator)));

The function C<times::Fraction> implements the C<Numerical> virtual function
C<times> aka C<*> aka C<×> for the composing type C<Fraction>.

=head2 times (Fraction, Integer)

    ::MD::times::Fraction_Integer ::= function
        --> Fraction <-- (Fraction, Integer)
        implements 2::""
        : (((\.0->numerator) * \.1) / (\.0->denominator));

The function C<times::Fraction_Integer> implements the C<Numerical> virtual
function C<times> aka C<*> aka C<×> for the composing type C<Fraction>,
specifically for multiplying one by an C<Integer>.

=head2 multiple_of (Fraction)

    ::MD::multiple_of::Fraction ::= function
        --> {Boolean, Excuse::Div_By_Zero} <-- (Fraction, Fraction)
        implements 2::""
        : (if \.1 = 0.0 then Excuse::Div_By_Zero()
            else \@mod <-- topic = 0.0);

The function C<multiple_of::Fraction> implements the C<Numerical>
virtual function C<multiple_of> for the composing type C<Fraction>.

=head2 fractional_divided_by (Fraction)

    ::MD::fractional_divided_by::Fraction ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Fraction, Fraction)
        implements 2::""
        : (if \.1 = 0.0 then Excuse::Div_By_Zero()
            else \.0 * reciprocal(\.1));

The function C<fractional_divided_by::Fraction> implements the C<Numerical>
virtual function C<fractional_divided_by> aka C</> aka C<÷> aka C<∕> for
the composing type C<Fraction>.

=head2 integral_divided_by (Fraction)

    ::MD::integral_divided_by::Fraction ::= function
        --> {Fraction, Excuse::Div_By_Zero}
        <-- (Fraction, Fraction, Round_Meth)
        implements 2::""
    : (
        d ::= lcm(\.0->denominator, \.1->denominator);
        n0 ::= ((\.0->numerator) * div(d, \.0->denominator, To_Zero()));
        n1 ::= ((\.1->numerator) * div(d, \.1->denominator, To_Zero()));
        <-- if \.1 = 0.0 then Excuse::Div_By_Zero()
            else div(n0 * d, n1 * d, \.2) / 1;
    );

The function C<integral_divided_by::Fraction> implements the C<Numerical>
virtual function C<integral_divided_by> aka C<div> for the composing type
C<Fraction>.

=head2 integral_power (Fraction)

    ::MD::integral_power::Fraction ::= function
        --> {Fraction, Excuse::Zero_To_The_Zero} <-- (Fraction, Integer)
        implements 2::""
        : (\@integral_nn_power
            <-- \.1 >= 0 ?? topic !! \%(reciprocal(\.0), -\.1));

The function C<integral_power::Fraction> implements the C<Numerical> virtual
function C<integral_power> aka C<**> for the composing type C<Fraction>.

=head2 integral_nn_power (Fraction)

    ::MD::integral_nn_power::Fraction ::= function
        --> {Fraction, Excuse::Zero_To_The_Zero} <-- (Fraction, Integer_NN)
        implements 2::""
        : (if \.0 = 0.0 and \.1 = 0 then Excuse::Zero_To_The_Zero()
            else ((\.0->numerator) ** \.1) / ((\.0->denominator) ** \.1));

The function C<integral_nn_power::Fraction> implements the C<Numerical>
virtual function C<integral_nn_power> aka C<power> for the composing type
C<Fraction>.

=head2 to_Fraction (Fraction)

    ::MD::to_Fraction::Fraction ::= function --> Fraction <-- (Fraction)
        implements 2::""
        : (\.0);

The function C<to_Fraction::Fraction> simply results in its C<0> argument.
This function implements the C<Fractional> virtual function C<to_Fraction>
for the composing type C<Fraction>.

=head2 numerator (Fraction)

    ::MD::numerator::Fraction ::= function --> Integer <-- (Fraction)
        : (unwrap(\.0).\numerator);

The function C<numerator::Fraction> implements the C<Fractional> virtual
function C<numerator> for the composing type C<Fraction>.

=head2 denominator (Fraction)

    ::MD::denominator::Fraction ::= function --> Integer_P <-- (Fraction)
        : (unwrap(\.0).\denominator);

The function C<denominator::Fraction> implements the C<Fractional> virtual
function C<denominator> for the composing type C<Fraction>.

=head1 EMPTYABLE DATA TYPES

=head2 Emptyable

    ::MD::Emptyable ::= interface
        composes Boolable
        requires_implements {so,empty};

The interface contract C<Emptyable> is infinite.  An C<Emptyable> value is
an aggregate C<Boolable> value that can have either zero or more than zero
components.  The primary reason for C<Emptyable> is to provide easy
consistent and terse ways to ask if an aggregate has any values, or to ask
for the value with no members of the same type as a given aggregate value.
The default value of C<Emptyable> is the C<Bits> value with zero members.

C<Emptyable> is composed, directly or indirectly, by: C<Stringy>, C<Bits>,
C<Blob>, C<Textual>, C<Text>, C<Homogeneous>, C<Discrete>, C<Positional>,
C<Array>, C<String>, C<Setty>, C<Set>, C<Bag>, C<Relational>, C<Relation>,
C<Tuple_Bag>, C<Interval>.

=head2 so (Emptyable) has_any_members

    ::MD::so::Emptyable ::= function virtual --> Boolean <-- (Emptyable)
        implements 2::"";

    ::MD::has_any_members ::= alias of so::Homogeneous;

The virtual function C<so::Emptyable> aka C<has_any_members> results in
C<True> iff its C<0> argument has any members, and in C<False> iff it has
no members.  This function implements the C<Boolable> virtual function
C<so> aka C<?> aka C<to_Boolean> for the composing type C<Emptyable>.

=head2 is_empty ∅?

    ::MD::is_empty ::= function negates so::Emptyable;

    ::MD::Unicode_Aliases::"∅?" ::= alias of is_empty;

The function C<is_empty> aka C<∅?> results in C<True> iff its C<0> argument
has no members, and in C<False> iff it has any members.

=head2 empty ∅

    ::MD::empty::"" ::= function virtual --> Emptyable <-- (Emptyable);

    ::MD::Unicode_Aliases::"∅" ::= alias of empty;

The virtual function C<empty> aka C<∅> results in the value of its C<0>
argument's collection type that has zero members.  For most such types like
C<Text> or C<Set>, this is a constant value, but for a C<Relation> or
C<Tuple_Bag>, there is a distinct result for each distinct I<heading>.
Other programming languages may name their corresponding operators I<clear>.

=head1 STRINGY DATA TYPES

=head2 Stringy

    ::MD::Stringy ::= interface
        composes {Orderable, Emptyable and_provides_its_default}
        requires_implements {in_order,so,empty
            ,substring_of,overlaps_string,disjoint_string
            ,catenate,replicate};

The interface contract C<Stringy> is infinite.  A C<Stringy> value is a
homogeneous ordered aggregate of other values such that there may not
necessarily be any single best interpretation of where each component value
begins or ends, and as such the only generic interpretation of a C<Stringy>
value is that it is a sequence of smaller C<Stringy> values of the same
type.  Idiomatically a C<Stringy> type has opaque values that each
represent something specific, such as a sequence of bits or of octets or of
characters of some repertoire; that being said, by way of C<Positional>,
some C<Stringy> types are in fact generic collections whose elements don't
represent something specific.  The general case of a C<Stringy> type has
operators for catenating or splitting C<Stringy> values, but it has no
generic concept of counting or addressing individual members of the
aggregate, with the lone special case exception that a count of zero can be
distinguished from a count of more than zero.  Addressing or counting
individual members can only be done properly in a composing type-specific
way, and often a single composing type may provide multiple ways, such as
character string types offering both codepoint and grapheme
representations.  The default value of C<Stringy> is the C<Bits> value with
zero members.  C<Stringy> expects every one of its composing types to be
orderable (but that some C<Positional> are only conditionally so), and
idiomatically that is done by some kind of pairwise comparison of members.

C<Stringy> is composed, directly or indirectly, by: C<Bits>, C<Blob>,
C<Textual>, C<Text>, C<Positional>, C<Array>, C<String>.

=head2 substring_of

    ::MD::substring_of::"" ::= function virtual
        --> Boolean <-- (Stringy, Stringy);

The virtual function C<substring_of> results in C<True> iff the sequence of
members of its C<0> argument is a substring of the sequence of members of
its C<1> argument; otherwise it results in C<False>.  Other programming
languages may name their corresponding operators I<in>.

=head2 superstring_of

    ::MD::superstring_of ::= function commutes substring_of;

The function C<superstring_of> results in C<True> iff the sequence of
members of its C<0> argument is a superstring of the sequence of members of
its C<1> argument; otherwise it results in C<False>.  Other programming
languages may name their corresponding operators I<contains> or
I<include?>; some of them instead provide more generalized pattern
searching operators such as I<like> or I<~~> or I<=~>; some of them also
provide operators that result in an ordinal position or nonmatch indicator
rather than a boolean.

=head2 proper_substring_or_superstring

    ::MD::proper_substring_or_superstring ::= function
        --> Boolean <-- (String, String)
        is commutative
        : (topic --> \@not_same and topic --> \@substring_or_superstring);

The function C<proper_substring_or_superstring> results in C<True> iff the
sequence of members of one of its 2 arguments C<0> and C<1> is a proper
substring of the sequence of members of its other argument; otherwise it
results in C<False>.

=head2 substring_or_superstring

    ::MD::substring_or_superstring ::= function
        --> Boolean <-- (String, String)
        is commutative
        : (topic --> \@substring_of or topic --> \@superstring_of);

The function C<substring_or_superstring> results in C<True> iff the
sequence of members of one of its 2 arguments C<0> and C<1> is a substring
of the sequence of members of its other argument; otherwise it results in
C<False>.

=head2 overlaps_string

    ::MD::overlaps_string::"" ::= function virtual
        --> Boolean <-- (String, String)
        is commutative;

The virtual function C<overlaps_string> results in C<True> iff, given I<X>
as the sequence of members of its argument C<0> and I<Y> as the sequence of
members of its argument C<1>, when I<X> and I<Y> are overlapped to the
greatest possible extent such that every corresponding member pair has 2 of
the same value, the overlap of I<X> and I<Y> has at least 1 member, and
each of I<X> and I<Y> has at least 1 member that is not overlapped;
otherwise it results in C<False>.

=head2 disjoint_string

    ::MD::disjoint_string::"" ::= function virtual
        --> Boolean <-- (String, String)
        is commutative;

The virtual function C<disjoint_string> results in C<True> iff the sequence
of members of its C<0> argument can not be overlapped with the sequence of
members of its C<1> argument by at least 1 member such that every
corresponding member pair has 2 of the same value; otherwise it results in
C<False>.

=head2 catenate ~

    ::MD::catenate::"" ::= function virtual
        --> Stringy <-- (Stringy, Stringy)
        is associative
        repeater replicate;

    ::MD::"~" ::= alias of catenate;

The virtual function C<catenate> aka C<~> results in the catenation of its
2 arguments C<0> and C<1> such that the result starts with the members of
C<0> and ends with the members of C<1>, the members from both in the same
order as in their respective arguments.  This operation has an identity
value of a collection with zero members.  Other programming languages may
name their corresponding operators I<concat> or I<||> or I<+> or I<.> or
I<strcat> or I<join>; some of them also have string interpolation syntax
which logically does the same thing without an explicit operator.

=head2 replicate ~#

    ::MD::replicate::"" ::= function virtual
        --> Stringy <-- (Stringy, Integer_NN);

    ::MD::"~#" ::= alias of replicate;

The virtual function C<replicate> aka C<~#> results in the catenation of N
instances of its C<0> argument where N is defined by its C<1> argument.  If
the C<1> argument is zero then the result is the value of the C<0>
argument's collection type that has zero members.  Other programming
languages may name their corresponding operators I<x>.

=head1 BITS DATA TYPES

=head2 Bits

    ::MD::Bits ::= ::= selection of Capsule
        where (has_wrapped( topic, \Bits, \@String::Bits ))
        default (\~?'')
        composes {Stringy and_provides_its_default};

The selection contract C<Bits> is infinite.  A C<Bits> value is an
arbitrarily-long sequence of I<bits> where each bit is represented by
an C<Integer> in the range 0..1.  The default value of C<Bits> is
C<\~?''> (the empty bit string).  C<Bits> is C<Orderable>; its minimum
value is the same C<\~?''> as its default value; it has no maximum value;
its ordering algorithm corresponds directly to that of C<String>, pairwise
as integer sequences.  Other programming languages may name their
corresponding types I<bit> or I<bit varying>.

=head2 String::Bits

    ::MD::String::Bits ::= selection of String
        where (topic all (function : (topic in 0..1)));

The selection contract C<String::Bits> represents the infinite type
consisting just of the C<String> values for which every one of their member
integers is in the range 0..1 inclusive.

=head2 in_order (Bits)

    ::MD::in_order::Bits ::= function --> Boolean <-- (Bits, Bits)
        implements 2::""
        : ((\.0->Bits_to_String_Bits) in_order (\.1->Bits_to_String_Bits));

The function C<in_order::Bits> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Bits>.

=head2 so (Bits)

    ::MD::so::Bits ::= function --> Boolean <-- (Bits)
        implements 2::""
        : (\.0 != \~?'');

The function C<so::Bits> results in C<True> iff its C<0> argument is not
C<\~?''>, and in C<False> if it is C<\~?''>.  This function implements the
C<Boolable> virtual function C<so> aka C<?> aka C<to_Boolean> for the
composing type C<Bits>.

=head2 empty (Bits)

    ::MD::empty::Bits ::= function --> Bits <-- (Bits)
        implements 2::""
        : (\~?'');

The function C<empty::Bits> simply results in C<\~?''>.  This function
implements the C<Emptyable> virtual function C<empty> for the composing
type C<Bits>.

=head2 substring_of (Bits)

    ::MD::substring_of::Bits ::= function --> Boolean <-- (Bits, Bits)
        implements 2::""
        : ((\.0->Bits_to_String_Bits) substring_of (\.1->Bits_to_String_Bits));

The function C<substring_of::Bits> implements the C<Stringy> virtual
function C<substring_of> for the composing type C<Bits>.

=head2 overlaps_string (Bits)

    ::MD::overlaps_string::Bits ::= function --> Boolean <-- (Bits, Bits)
        implements 2::""
        is commutative
        : ((\.0->Bits_to_String_Bits)
            overlaps_string (\.1->Bits_to_String_Bits));

The function C<overlaps_string::Bits> implements the C<Stringy> virtual
function C<overlaps_string> for the composing type C<Bits>.

=head2 disjoint_string (Bits)

    ::MD::disjoint_string::Bits ::= function --> Boolean <-- (Bits, Bits)
        implements 2::""
        is commutative
        : ((\.0->Bits_to_String_Bits)
            disjoint_string (\.1->Bits_to_String_Bits));

The function C<disjoint_string::Bits> implements the C<Stringy> virtual
function C<disjoint_string> for the composing type C<Bits>.

=head2 catenate (Bits)

    ::MD::catenate::Bits ::= function --> Bits <-- (Bits, Bits)
        implements 2::""
        is associative identity (\~?'')
        repeater replicate::Bits
        : (Bits_from_String_Bits((\.0->Bits_to_String_Bits)
            ~ (\.1->Bits_to_String_Bits)));

The function C<catenate::Bits> implements the C<Stringy> virtual function
C<catenate> aka C<~> for the composing type C<Bits>.

=head2 replicate (Bits)

    ::MD::replicate::Bits ::= function --> Bits <-- (Bits, Integer_NN)
        implements 2::""
        : (Bits_from_String_Bits((\.0->Bits_to_String_Bits) ~# \.1));

The function C<replicate::Bits> implements the C<Stringy> virtual function
C<replicate> aka C<~#> for the composing type C<Bits>.

=head2 Bits_from_String_Bits

    ::MD::Bits_from_String_Bits ::= function --> Bits <-- (String::Bits)
        : (\Bits wrap \.0);

The function C<Bits_from_String_Bits> results in the C<Bits> value selected
in terms of the integer sequence of its C<0> argument.

=head2 Bits_to_String_Bits

    ::MD::Bits_to_String_Bits ::= function --> String::Bits <-- (Bits)
        : (\.0->unwrap);

The function C<Bits_to_String_Bits> results in an integer sequence defining
the bits of its C<Bits>-typed C<0> argument.

=head1 BLOB DATA TYPES

=head2 Blob

    ::MD::Blob::"" ::= selection of Capsule
        where (has_wrapped( topic, \Blob, \@String::Octets ))
        default (\~+'')
        composes Stringy;

The selection contract C<Blob> is infinite.  A C<Blob> value is an
arbitrarily-long sequence of I<octets> where each octet is represented by
an C<Integer> in the range 0..255.  The default value of C<Blob> is
C<\~+''> (the empty octet string).  C<Blob> is C<Orderable>; its minimum
value is the same C<\~+''> as its default value; it has no maximum value;
its ordering algorithm corresponds directly to that of C<String>, pairwise
as integer sequences.  Other programming languages may name their
corresponding types I<Buf> or I<byte[]> or I<bytea>.

=head2 String::Octets

    ::MD::String::Octets ::= selection of String
        where (topic all (function : (topic in 0..255)));

The selection contract C<String::Octets> represents the infinite type
consisting just of the C<String> values for which every one of their member
integers is in the range 0..255 inclusive.

=head2 in_order (Blob)

    ::MD::in_order::Blob ::= function --> Boolean <-- (Blob, Blob)
        implements 2::""
        : ((\.0->Blob_to_Octets) in_order (\.1->Blob_to_Octets));

The function C<in_order::Blob> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Blob>.

=head2 so (Blob)

    ::MD::so::Blob ::= function --> Boolean <-- (Blob)
        implements 2::""
        : (\.0 != \~+'');

The function C<so::Blob> results in C<True> iff its C<0> argument is not
C<\~+''>, and in C<False> if it is C<\~+''>.  This function implements the
C<Boolable> virtual function C<so> aka C<?> aka C<to_Boolean> for the
composing type C<Blob>.

=head2 empty (Blob)

    ::MD::empty::Blob ::= function --> Blob <-- (Blob)
        implements 2::""
        : (\~+'');

The function C<empty::Blob> simply results in C<\~+''>.  This function
implements the C<Emptyable> virtual function C<empty> for the composing
type C<Blob>.

=head2 substring_of (Blob)

    ::MD::substring_of::Blob ::= function --> Boolean <-- (Blob, Blob)
        implements 2::""
        : ((\.0->Blob_to_Octets) substring_of (\.1->Blob_to_Octets));

The function C<substring_of::Blob> implements the C<Stringy> virtual
function C<substring_of> for the composing type C<Blob>.

=head2 overlaps_string (Blob)

    ::MD::overlaps_string::Blob ::= function --> Boolean <-- (Blob, Blob)
        implements 2::""
        is commutative
        : ((\.0->Blob_to_Octets) overlaps_string (\.1->Blob_to_Octets));

The function C<overlaps_string::Blob> implements the C<Stringy> virtual
function C<overlaps_string> for the composing type C<Blob>.

=head2 disjoint_string (Blob)

    ::MD::disjoint_string::Blob ::= function --> Boolean <-- (Blob, Blob)
        implements 2::""
        is commutative
        : ((\.0->Blob_to_Octets) disjoint_string (\.1->Blob_to_Octets));

The function C<disjoint_string::Blob> implements the C<Stringy> virtual
function C<disjoint_string> for the composing type C<Blob>.

=head2 catenate (Blob)

    ::MD::catenate::Blob ::= function --> Blob <-- (Blob, Blob)
        implements 2::""
        is associative identity (\~+'')
        repeater replicate::Blob
        : (Blob_from_Octets((\.0->Blob_to_Octets) ~ (\.1->Blob_to_Octets)));

The function C<catenate::Blob> implements the C<Stringy> virtual function
C<catenate> aka C<~> for the composing type C<Blob>.

=head2 replicate (Blob)

    ::MD::replicate::Blob ::= function --> Blob <-- (Blob, Integer_NN)
        implements 2::""
        : (Blob_from_Octets((\.0->Blob_to_Octets) ~# \.1));

The function C<replicate::Blob> implements the C<Stringy> virtual function
C<replicate> aka C<~#> for the composing type C<Blob>.

=head2 Blob_from_Octets

    ::MD::Blob_from_Octets ::= function --> Blob <-- (String::Octets)
        : (\Blob wrap \.0);

The function C<Blob_from_Octets> results in the C<Blob> value selected in
terms of the integer sequence of its C<0> argument.

=head2 Blob_to_Octets

    ::MD::Blob_to_Octets ::= function --> String::Octets <-- (Blob)
        : (\.0->unwrap);

The function C<Blob_to_Octets> results in an integer sequence defining the
octets of its C<Blob>-typed C<0> argument.

=head1 TEXTUAL DATA TYPES

=head2 Textual

    ::MD::Textual ::= interface
        composes Stringy
        requires_implements {in_order,so,empty
            ,substring_of,overlaps_string,disjoint_string
            ,catenate,replicate
            ,to_Text};

The interface contract C<Textual> is infinite.  A C<Textual> value is a
C<Stringy> value which is explicitly a sequence of characters of some
repertoire, typically Unicode or a subset thereof such as ASCII.  Note that
the C<Core> package has no concept of a I<single character> value in the
abstract sense that some programming languages do; the closest analogy is a
C<Stringy> value that just contains either one codepoint or grapheme or
similar concept; this is something in common with the Perl 6 language.

C<Textual> is composed by C<Text>, which implements C<Orderable> using the
simple culture-agnostic method of ordering codepoints numerically.
Idiomatically each culture-specific text collation method will have its own
distinct C<Textual>-composing type that implements C<Orderable> in its own
way, so the latter's operators will just work like users expect.

The C<Core> package excludes the majority of useful operators specific to
working with character strings; see instead other Muldis D packages such as
L<Core::Text|Muldis::D::Package::Core::Text> for these things.  Such tasks
include like case folding, pattern matching, whitespace trimming, Unicode
normalization, encoding to and decoding from most binary formats, and so on.

Muldis D is designed expressly to avoid mandatory external dependencies of
large complexity, such as most of the details of Unicode, in contrast with
a lot of the more modern languages of its time.  The Muldis D Foundation
and C<Core> package are strictly limited in their knowledge of Unicode;
they know that a codepoint of the Unicode repertoire is just in the integer
range C<0..0x10FFFF>, and that the leading subset C<0..127> is also 7-bit
ASCII, and they know how to read and write the fairly simple and stable
C<UTF-8> binary encoding for Unicode text, which is a proper superset of
7-bit ASCII encoding and is CPU endian-agnostic.  In contrast, anything to
do with knowing what abstract characters exist, and their various
properties (upper or lowercase, combining or not, etc), anything to do with
normalization or folding or pattern matching, and anything to do with other
binary encodings or character repertoires especially endian-specific, this
is all expressly I<not> part of the language core.  A
Muldis D implementation can choose whether or not to support them, allowing
for a lower barrier to entry.  Unicode in particular requires a vast
knowledge base to work properly with that is regularly updated, and Muldis
D has a principle that it is better to have multiple specialized components
that do their jobs well, such as handle Unicode intricacies, while the core
language can focus on other core competencies that don't involve complex
externally-defined moving targets.  The C<Core> package loosely just
considers a character string to be a sequence of generic integers and
doesn't ascribe very many distinct semantics to particular ones, while
non-C<Core> code is empowered to do that instead.

=head2 to_Text

    ::MD::to_Text::"" ::= function virtual --> Text <-- (Textual);

The virtual function C<to_Text> results in the C<Text> value that
represents the same character string value as its C<0> argument.  The
purpose of C<to_Text> is to canonicalize C<Textual> values so they can be
compared or worked with as character strings in a manner agnostic to things
like national collations or fixed-size types.

=head1 TEXT DATA TYPES

=head2 Text

    ::MD::Text::"" ::= selection of Capsule
        where (has_wrapped( topic, \Text, \@String::Maximal_Chars ))
        default ('')
        composes {Textual and_provides_its_default};

The selection contract C<Text> is infinite.  A C<Text> value is an
arbitrarily-long sequence of abstract I<characters> where each character is
a member of an infinite-size proprietary abstract character repertoire
named I<maximal>.  A C<Text> value is canonically defined in terms of a
C<String> value named C<Maximal_Chars>, where each member C<Integer> of the
latter represents an abstract character I<codepoint>, with each unique
integer corresponding to a unique character.  The default value of C<Text>
is C<''> (the empty character string).  C<Text> is C<Orderable>; its
minimum value is the same C<''> as its default value; it has no maximum
value; its ordering algorithm corresponds directly to that of C<String>,
pairwise as integer sequences.  Other programming languages may name their
corresponding types I<Str> or I<string> or I<varchar> or I<char>.

There are many defined character sets in the computing world that map
agreed upon sets of symbols to integers, and Muldis D is designed to be
implicitly compatible with all of them.  Officially speaking, C<Text>
values are just sequences of integers and any mapping between these
integers and commonly well-understood symbols is done externally to the
C<Text> type.  While the canonical C<Maximal_Chars> representation does
formally map symbols to integers in a well-defined way, this mapping is
proprietary, intended only for internal usage, and is subject to change
with different Muldis D versions.  All normal user interaction with the
internals of a C<Text> should just be done in terms of explicit mappings
with well-known public character sets such as 7-bit ASCII or Unicode.  As
it happens, C<Maximal_Chars> is formally a proper superset of Unicode 8.0,
itself a proper superset of 7-bit ASCII, so their corresponding codepoints
are identical, but for other character sets such as ISO Latin 1 or EBCDIC
or ISO/IEC 2022 or Mojikyo or HKSCS or others, they may not be.

=head2 String::Maximal_Chars

    ::MD::String::Maximal_Chars ::= alias of String;

The selection contract C<String::Maximal_Chars> is an alias of C<String>
which exists for convenient self-documentation of C<Text>-related code.

=head2 Text::Unicode

    ::MD::Text::Unicode ::= selection of Text
        where (topic->Text_from_Maximal_Chars is_a \@String::Unicode_Codes);

The selection contract C<Text::Unicode> represents the infinite type
consisting just of the C<Text> values for which every one of their member
characters is a member of the 0x110000-character repertoire of Unicode.
This C<Text> subtype has is own canonical representation in terms of a
C<String> value named C<Unicode_Codes> where each member codepoint matches
the standard Unicode codepoints for the same symbols.

=head2 String::Unicode_Codes

    ::MD::String::Unicode_Codes ::= selection of String::Maximal_Chars
        where (topic all (function : (topic in 0..0x10FFFF)));

The selection contract C<String::Unicode_Codes> represents the infinite type
consisting just of the C<String> values for which every one of their member
integers is in the range 0..0x10FFFF inclusive.

=head2 Text::ASCII

    ::MD::Text::ASCII ::= selection of Text::Unicode
        where (topic->Text_from_Unicode_Codes is_a \@String::ASCII_Chars);

The selection contract C<Text::ASCII> represents the infinite type
consisting just of the C<Text> values for which every one of their member
characters is a member of the 128-character repertoire of 7-bit ASCII.
This C<Text> subtype has is own canonical representation in terms of a
C<String> value named C<ASCII_Chars> where each member codepoint matches
the standard ASCII codes for the same symbols.

=head2 String::ASCII_Chars

    ::MD::String::ASCII_Chars ::= selection of String::Unicode_Codes
        where (topic all (function : (topic in 0..127)));

The selection contract C<String::ASCII_Chars> represents the infinite type
consisting just of the C<String> values for which every one of their member
integers is in the range 0..127 inclusive.

=head2 in_order (Text)

    ::MD::in_order::Text ::= function --> Boolean <-- (Text, Text)
        implements 2::""
        : ((\.0->Text_to_Maximal_Chars) in_order (\.1->Text_to_Maximal_Chars));

The function C<in_order::Text> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Text>.

=head2 so (Text)

    ::MD::so::Text ::= function --> Boolean <-- (Text)
        implements 2::""
        : (\.0 != '');

The function C<so::Text> results in C<True> iff its C<0> argument is
not C<''>, and in C<False> if it is C<''>.  This function implements the
C<Boolable> virtual function C<so> aka C<?> aka C<to_Boolean> for the
composing type C<Text>.

=head2 empty (Text)

    ::MD::empty::Text ::= function --> Text <-- (Text)
        implements 2::""
        : ('');

The function C<empty::Text> simply results in C<''>.  This function
implements the C<Emptyable> virtual function C<empty> for the composing
type C<Text>.

=head2 substring_of (Text)

    ::MD::substring_of::Text ::= function --> Boolean <-- (Text, Text)
        implements 2::""
        : ((\.0->Text_to_Maximal_Chars)
            substring_of (\.1->Text_to_Maximal_Chars));

The function C<substring_of::Text> implements the C<Stringy> virtual
function C<substring_of> for the composing type C<Text>.

=head2 overlaps_string (Text)

    ::MD::overlaps_string::Text ::= function --> Boolean <-- (Text, Text)
        implements 2::""
        is commutative
        : ((\.0->Text_to_Maximal_Chars)
            overlaps_string (\.1->Text_to_Maximal_Chars));

The function C<overlaps_string::Text> implements the C<Stringy> virtual
function C<overlaps_string> for the composing type C<Text>.

=head2 disjoint_string (Text)

    ::MD::disjoint_string::Text ::= function --> Boolean <-- (Text, Text)
        implements 2::""
        is commutative
        : ((\.0->Text_to_Maximal_Chars)
            disjoint_string (\.1->Text_to_Maximal_Chars));

The function C<disjoint_string::Text> implements the C<Stringy> virtual
function C<disjoint_string> for the composing type C<Text>.

=head2 catenate (Text)

    ::MD::catenate::Text ::= function --> Text <-- (Text, Text)
        implements 2::""
        is associative identity ('')
        repeater replicate::Text
        : (Text_from_Maximal_Chars((\.0->Text_to_Maximal_Chars)
            ~ (\.1->Text_to_Maximal_Chars)));

The function C<catenate::Text> implements the C<Stringy> virtual function
C<catenate> aka C<~> for the composing type C<Text>.

=head2 replicate (Text)

    ::MD::replicate::Text ::= function --> Text <-- (Text, Integer_NN)
        implements 2::""
        : (Text_from_Maximal_Chars((\.0->Text_to_Maximal_Chars) ~# \.1));

The function C<replicate::Text> implements the C<Stringy> virtual function
C<replicate> aka C<~#> for the composing type C<Text>.

=head2 to_Text (Text)

    ::MD::to_Text::Text ::= function --> Text <-- (Text)
        implements 2::""
        : (\.0);

The function C<to_Text::Text> simply results in its C<0> argument.
This function implements the C<Textual> virtual function C<to_Text>
for the composing type C<Text>.

=head2 Text_from_Maximal_Chars

    ::MD::Text_from_Maximal_Chars ::= function
        --> Text <-- (String::Maximal_Chars)
        : (\Text wrap \.0);

The function C<Text_from_Maximal_Chars> results in the C<Text> value
selected in terms of an integer sequence in the proprietary
C<Maximal_Chars> character mapping of its C<0> argument.

=head2 Text_to_Maximal_Chars

    ::MD::Text_to_Maximal_Chars ::= function
        --> String::Maximal_Chars <-- (Text)
        : (\.0->unwrap);

The function C<Text_to_Maximal_Chars> results in an integer sequence in the
proprietary C<Maximal_Chars> character mapping that corresponds to its
C<Text>-typed C<0> argument.

=head2 Text_from_Unicode_Codes

    ::MD::Text_from_Unicode_Codes ::= function
        --> Text::Unicode <-- (String::Unicode_Codes)
        : (\.0->Text_from_Maximal_Chars);

The function C<Text_from_Unicode_Codes> results in the C<Text> value selected
in terms of an integer sequence in the standard Unicode codepoint
mapping of its C<0> argument.

=head2 Text_to_Unicode_Codes

    ::MD::Text_to_Unicode_Codes ::= function
        --> String::Unicode_Codes <-- (Text::Unicode)
        : (\.0->Text_to_Maximal_Chars);

The function C<Text_to_Unicode_Codes> results in an integer sequence in the
standard Unicode codepoint mapping that corresponds to its
C<Text>-typed C<0> argument.

=head2 Text_from_ASCII_Chars

    ::MD::Text_from_ASCII_Chars ::= function
        --> Text::ASCII <-- (String::ASCII_Chars)
        : (\.0->Text_from_Unicode_Codes);

The function C<Text_from_ASCII_Chars> results in the C<Text> value selected
in terms of an integer sequence in the standard 7-bit ASCII character
mapping of its C<0> argument.

=head2 Text_to_ASCII_Chars

    ::MD::Text_to_ASCII_Chars ::= function
        --> String::ASCII_Chars <-- (Text::ASCII)
        : (\.0->Text_to_Unicode_Codes);

The function C<Text_to_ASCII_Chars> results in an integer sequence in the
standard 7-bit ASCII character mapping that corresponds to its
C<Text>-typed C<0> argument.

=head1 COLLECTIVE DATA TYPES OVERVIEW

A I<collective> value either is a generic regular aggregate of a
multiplicity of other, I<component>, values whose composition is
transparent to the user or is something that can act as such an aggregate.
The C<Core> package provides I<collective> types with a variety of
desirable alternative properties.

Some I<collective> values are fully I<discrete> and so their components can
be enumerated as individuals and counted, while other collective values are
at least partially I<continuous> and so at least some of their components
can not be enumerated or counted (the count is effectively an infinity);
however it is still possible to test the membership of a value in such a
collective.  C<Interval> is an example of a typically-continuous type while
most collective types provided by C<Core> are discrete; however, an
C<Interval> can be treated as a discrete type iff the types it ranges over
are C<Bicessable>.

Some I<collective> values are I<positional> and define an explicit total
order for their components which does not necessarily depend on any order
specific to the component values themselves, and which does not necessarily
place multiple same-valued components consecutively.  Such a collective
value can reliably and consistently enumerate its components in its defined
order, and the collective also supports integral index-based lookup of its
members where each member lives at a distinct index.  In contrast,
I<nonpositional> collective values simply track what values their
components are and don't provide index-based lookup; those that are
enumerable do not guarantee that components are returned in any particular
order.  An example positional type is C<Array> while example nonpositional
types are C<Set>, C<Bag>, and C<Relation>.  Some I<positional> types are
I<sorted>, ensuring that components are organized in the collection
corresponding to a total order that is specific to the component values
themselves, meaning also that all same-valued components are consecutive;
I<nonsorted> positional types don't do this.

Some I<collective> values are I<setty>, ensuring that each of their
components is unique, while other collective values are I<baggy>,
permitting multiple components to be the same value.  Examples of setty
types are C<Set> and C<Relation>, while examples of baggy types are
C<Array> and C<Bag>.  Some setty types may silently avoid duplicate values,
where adding the same value twice has the same effect as adding it once,
while other setty types may raise an error if adding a duplicate value is
attempted.

The I<collective> types provided by the C<Core> package all speak to a
space having two orthogonal dimensions into which their components are
logically arranged, where one dimension is called I<homogeneous> and the
other dimension is called I<attributive>.  A I<collective> value's
components addressed in terms of their location along its I<homogeneous>
dimension are called I<members> of the collective, while components
addressed in terms of their location along its I<attributive> dimension are
called I<attributes>.  To be more accurate, a I<member> is a slice of the
space that includes all components with the same single location along the
homogeneous dimension, while an I<attribute> is a slice of the space that
includes all components with the same single location along the attributive
dimension; in many contexts, said slice is considered as a single value of
its own.  Every I<member> of a collective value is conceptually of a common
data type with its fellow members or should be interpreted logically in the
same way.  Every I<attribute> of a collective value is conceptually of its
own data type or should be interpreted logically in a distinct way from its
fellow attributes.

While many collective types just utilize one of the dimensions
I<homogeneous> or I<attributive>, some utilize both.  Values of the
C<Array>, C<Set>, C<Bag>, C<Interval> types each arrange their components
along just the I<homogeneous> dimension and ignore I<attributive>, so for
brevity we just say their components I<are> members.  Values of the
C<Tuple> type each arrange their components along just the I<attributive>
dimension and ignore I<homogeneous>, so for brevity we just say their
components I<are> attributes.  Values of the C<Relation> and C<Tuple_Bag>
types each arrange their components over both of the dimensions, so we say
they have both members and attributes.

Given that the I<homogeneous> and I<attributive> dimensions are to a large
degree isomorphic, and so there are a lot of corresponding operations that
apply to both, the C<Core> package uses different terminology and operator
names for corresponding things so it is clear what dimension is being acted
on.  For example, a C<Relation> value has no single concept of its
component count, rather we say I<cardinality> is a count of its members
while I<degree> is a count of its attributes.  When equally terse and
pleasant terminology isn't available for a pair of corresponding concepts,
the homogeneous dimension is given priority for the nicer API since that is
expected to be the dominant one for typical usage patterns.

See the C<Homogeneous> type which defines the common API for all collective
types utilizing the I<homogeneous> dimension, and see the C<Attributive>
type which defines the orthogonal common API for all collective types
utilizing the I<attributive> dimension.  See the C<Relational> type which
defines the common API for all collective types utilizing both dimensions.

See also the C<Accessible> type which provides an extra API that can be
applied on a type-by-type basis to either the I<homogeneous> dimension or
the I<attributive> dimension (but not both) as makes the most sense for the
composing types in question; example composers are C<Array> and C<Tuple>
respectively for said dimensions.

=head1 ACCESSIBLE DATA TYPES

=head2 Accessible

    ::MD::Accessible ::= interface
        requires_implements {".",".?",".!"};

I<TODO.  For types that support simple accessor-based lookup of single values;
for one-dimensional collections of pairs that support lookup by one
pair element of the other pair element, and every pair in the
collection has a distinct first element.
Does not have anything to say related to either enumerating elements or
to slicing a subset elements into a new collection.
Accessible just provides certain convenient shared names for operators that
otherwise have distinct names on the composing types.
Composed by: Positional (Array, String,...), Tuple, Dictionary, etc.
(Conceptually also composed by Capsule, but isn't to avoid conflicts.)>

=head2 .

    ::MD::"."::"" ::= function virtual --> Any <-- (Accessible, Any)
        requires (topic --> \@".?");

I<TODO.>

=head2 .?

    ::MD::".?"::"" ::= function virtual --> Boolean <-- (Accessible, Any);

I<TODO.>

=head2 .!

    ::MD::".!"::"" ::= function virtual --> Any <-- (Accessible, Any);

I<TODO.>

=head1 HOMOGENEOUS DATA TYPES

=head2 Homogeneous

    ::MD::Homogeneous ::= interface
        composes Emptyable
        requires_implements {so,empty
            ,has_n,multiplicity,insert_n,remove_n
            ,all_unique,unique
            ,subset_of,same_members,overlaps_members,disjoint_members
            ,member_plus,except,intersect,union,exclusive
            ,nest,unnest,any,where,map,reduce,...};

The interface contract C<Homogeneous> is infinite.  A C<Homogeneous> value
is a I<collective> value such that every one of its component I<members> is
conceptually of a common data type with its fellow members or should be
interpreted logically in the same way.  Idiomatically a C<Homogeneous> is a
generic collection which does not as a whole represent any kind of thing in
particular, such as a text or a graphic, and is simply the sum of its
I<members>; however some types which do represent such a particular kind of
thing may choose to compose C<Homogeneous> because it makes sense to
provide its operators.  The default value of C<Homogeneous> is the C<Array>
value with zero members, C<[]>.

If a C<Homogeneous> value is also C<Discrete>, all of its members can be
enumerated as individuals and counted; otherwise, that may not be possible.
If a C<Homogeneous> value is also C<Positional>, all of its members are
arranged in an explicit total order and can both be enumerated in that
order as well as be looked up by integral indexed-based position against
that order; otherwise, that may not be possible.  If a C<Homogeneous> value
is also C<Setty>, all of its members are guaranteed to be distinct values;
otherwise, duplication of values may occur amongst members.

C<Homogeneous> is composed, directly or indirectly, by: C<Discrete>,
C<Positional>, C<Array>, C<String>, C<Setty>, C<Set>, C<Bag>,
C<Relational>, C<Relation>, C<Tuple_Bag>, C<Interval>.

I<TODO.  Note that for all the regular function-taking member-wise
Homogeneous operators that are logically supposed to work with each
collection member in isolation and/or shouldn't put significance on either
duplicate members or member position in the collection, including the likes
of {any, where, map} etc, but not including the likes of {reduce}, the
operators will only be passing the asset portion (where applicable) of the
member to the higher-order function, and not say the index-asset pair for a
Positional or the asset-count pair for a Baggy.  Note that for a Relation
or Tuple_Bag each entire Tuple is the member asset, and for a Dictionary
the pair is the asset.  (With the corresponding attribute-wise Tuple
operators, they are given the whole attribute name-value pair.)  The main
reason for this is to help ensure consistency of results while supporting a
variety of collection implementations including ones that are lazy, such as
by not eagerly counting duplicates, or that use distributed computation.
For that matter, the likes of {reduce} should probably be treated the same
way; see also the 'repeater' function trait that helps optimize it.
Surely, any time when one may think these operations need to know the
baggy count or positional index, its for a problem best solved differently.>

=head2 in ∈

    ::MD::in ::= function commutes has;

    ::MD::Unicode_Aliases::"∈" ::= alias of in;

The function C<in> aka C<∈> results in C<True> iff its C<0> argument is
equal to at least 1 member value of its C<1> argument; otherwise it results
in C<False>.  Note that this operation is also known as I<containment>.
Other programming languages may name their corresponding operators
I<in_array>.

=head2 not_in ∉

    ::MD::not_in ::= function commutes not_has;

    ::MD::Unicode_Aliases::"∉" ::= alias of not_in;

The function C<not_in> aka C<∉> results in C<True> iff its C<0> argument is
equal to no member value of its C<1> argument; otherwise it results in
C<False>.

=head2 has ∋

    ::MD::has ::= function --> Boolean <-- (Homogeneous, Any)
        (has_n(\.0, \.1, 1));

    ::MD::Unicode_Aliases::"∋" ::= alias of has;

The function C<has> aka C<∋> results in C<True> iff its C<0> argument has
at least 1 member whose value is equal to its C<1> argument; otherwise it
results in C<False>.  Other programming languages may name their
corresponding operators I<contains>, I<exists>, I<includes>.

=head2 not_has ∌

    ::MD::not_has ::= function negates has;

    ::MD::Unicode_Aliases::"∌" ::= alias of not_has;

The function C<not_has> aka C<∌> results in C<True> iff its C<0> argument
does not have any member whose value is equal to its C<1> argument;
otherwise it results in C<False>.

=head2 has_n

    ::MD::has_n::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Any, Integer_NN);

The virtual function C<has_n> results in C<True> iff its C<0> argument has
at least N members such that each is equal to its C<1> argument, where N is
defined by its C<2> argument; otherwise it results in C<False>.  The
result is always C<True> when the C<2> argument is zero.  Note that
having a C<2> argument greater than 1 in combination with a C<Setty> typed
C<0> argument will always result in C<False>.

=head2 multiplicity

    ::MD::multiplicity::"" ::= function virtual
        --> Integer_NN <-- (Homogeneous, Any);

The virtual function C<multiplicity> results in the integral count of
members of its C<0> argument such that each member value is equal to its
C<1> argument.  For a C<Setty> typed C<0> argument, the result is always
just 0 or 1.

=head2 insert

    ::MD::insert ::= function --> Homogeneous <-- (Homogeneous, Any)
        : (insert_n(\.0, \.1, 1));

The function C<insert> results in the value of its C<0> argument's
collection type that has all of the members of the function's C<0> argument
plus 1 additional member that is equal to its C<1> argument; its semantics
are identical to those of C<insert_n> where N is 1.  Other programming
languages may name their corresponding operators I<add>; it is also common
to use assignment syntax.

=head2 insert_n

    ::MD::insert_n::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Any, Integer_NN);

The virtual function C<insert_n> results in the value of its C<0>
argument's collection type that has all of the members of the function's
C<0> argument plus N additional members that are each equal to its C<1>
argument, where N is defined by its C<2> argument; however, if the result's
type is C<Setty>, the result will have no more than 1 member equal to the
C<1> argument (any duplicates will be silently eliminated), so the result
may equal the C<0> argument even when the C<2> argument is nonzero.  If the
result's type is C<Positional>, then the result starts with all of the
members of C<0> in the same order and ends with any added instances of C<1>.

=head2 remove

    ::MD::remove ::= function --> Homogeneous <-- (Homogeneous, Any)
        : (remove_n(\.0, \.1, 1));

The function C<remove> results in the value of its C<0> argument's
collection type that has all of the members of the function's C<0> argument
minus 1 existing member that is each equal to its C<1> argument; its
semantics are identical to those of C<remove_n> where N is 1.  Other
programming languages may name their corresponding operators I<delete>.

=head2 remove_n

    ::MD::remove_n::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Any, Integer_NN);

The virtual function C<remove_n> results in the value of its C<0>
argument's collection type that has all of the members of the function's
C<0> argument minus N existing members that are each equal to its C<1>
argument, where N is defined as the lesser of its C<2> argument and the
count of members of C<0> equal to the C<1> argument, so the result may
equal the C<0> argument even when the C<2> argument is nonzero.  If the
result's type is C<Positional>, then the removed instances of C<1> are
those closest to the end of C<0>.  Note that C<remove_n> is designed to
mirror C<insert_n> and so the identity C<c = remove_n(insert_n(c,x,n),x,n)>
should hold for any C<Homogeneous> type, even a C<Positional> one, except
with a C<Setty> C<c> that already has an C<x> element with a nonzero C<n>.

=head2 all_unique

    ::MD::all_unique::"" ::= function virtual --> Boolean <-- (Homogeneous);

The virtual function C<all_unique> results in C<True> iff its C<0> argument
has no 2 members that are the same value, and C<False> otherwise.  The
result is always C<True> for a C<Setty> argument.

=head2 unique

    ::MD::unique::"" ::= function virtual --> Homogeneous <-- (Homogeneous);

The virtual function C<unique> results in the value of its C<0> argument's
collection type that has, for every distinct member value I<V> of the
function's C<0> argument, exactly 1 member whose value is equal to I<V>.
The result is always the same value as its argument when that is C<Setty>.
If the result's type is C<Positional>, then each retained member is the one
closest to the start of the argument out of those members sharing the
retained member's value.  See also the C<Positional> function C<squish>.

=head2 proper_subset_of ⊂

    ::MD::proper_subset_of ::= function
        --> Boolean <-- (Homogeneous, Homogeneous)
        : (topic --> \@not_same and topic --> \@subset_of);

    ::MD::Unicode_Aliases::"⊂" ::= alias of proper_subset_of;

The function C<proper_subset_of> aka C<⊂> results in C<True> iff the
multiset of members of its C<0> argument is a proper subset of the
multiset of members of its C<1> argument; otherwise it results in C<False>.
Note that this operation is also known as I<strict multiset inclusion>.

=head2 not_proper_subset_of ⊄

    ::MD::not_proper_subset_of ::= function negates proper_subset_of;

    ::MD::Unicode_Aliases::"⊄" ::= alias of not_proper_subset_of;

The function C<not_proper_subset_of> aka C<⊄> results in C<True> iff the
multiset of members of its C<0> argument is not a proper subset of the
multiset of members of its C<1> argument; otherwise it results in C<False>.

=head2 proper_superset_of ⊃

    ::MD::proper_superset_of ::= function commutes proper_subset_of;

    ::MD::Unicode_Aliases::"⊃" ::= alias of proper_superset_of;

The function C<proper_superset_of> aka C<⊃> results in C<True> iff the
multiset of members of its C<0> argument is a proper superset of the
multiset of members of its C<1> argument; otherwise it results in C<False>.

=head2 not_proper_superset_of ⊅

    ::MD::not_proper_superset_of ::= function negates proper_superset_of;

    ::MD::Unicode_Aliases::"⊅" ::= alias of not_proper_superset_of;

The function C<not_proper_superset_of> aka C<⊅> results in C<True> iff the
multiset of members of its C<0> argument is not a proper superset of the
multiset of members of its C<1> argument; otherwise it results in C<False>.

=head2 subset_of ⊆

    ::MD::subset_of::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Homogeneous);

    ::MD::Unicode_Aliases::"⊆" ::= alias of subset_of;

The function C<subset_of> aka C<⊆> results in C<True> iff the multiset of
members of its C<0> argument is a subset of the multiset of members of
its C<1> argument; otherwise it results in C<False>.  Note that this
operation is also known as I<multiset inclusion>.

=head2 not_subset_of ⊈

    ::MD::not_subset_of ::= function negates subset_of;

    ::MD::Unicode_Aliases::"⊈" ::= alias of not_subset_of;

The function C<not_subset_of> aka C<⊈> results in C<True> iff the multiset
of members of its C<0> argument is not a subset of the multiset of
members of its C<1> argument; otherwise it results in C<False>.

=head2 superset_of ⊇

    ::MD::superset_of ::= function commutes subset_of;

    ::MD::Unicode_Aliases::"⊇" ::= alias of superset_of;

The function C<superset_of> aka C<⊇> results in C<True> iff the multiset of
members of its C<0> argument is a superset of the multiset of members of
its C<1> argument; otherwise it results in C<False>.

=head2 not_superset_of ⊉

    ::MD::not_superset_of ::= function negates superset_of;

    ::MD::Unicode_Aliases::"⊉" ::= alias of not_superset_of;

The function C<not_superset_of> aka C<⊉> results in C<True> iff the
multiset of members of its C<0> argument is not a superset of the multiset
of members of its C<1> argument; otherwise it results in C<False>.

=head2 same_members

    ::MD::same_members::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative;

The virtual function C<same_members> results in C<True> iff the multiset of
members of its C<0> argument is the same as the multiset of members of its
C<1> argument; otherwise it results in C<False>.  This function may result
in C<True> for some C<Positional> arguments for which C<same> would result
in C<False> because the latter considers member order significant while the
former doesn't; for non-C<Positional> arguments, the 2 functions are
typically the same.

=head2 proper_subset_or_superset

    ::MD::proper_subset_or_superset ::= function
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative
        : (not topic --> \@same_members and topic --> \@subset_or_superset);

The function C<proper_subset_or_superset> results in C<True> iff the
multiset of members of one of its 2 arguments C<0> and C<1> is a proper
subset of the multiset of members of its other argument; otherwise it
results in C<False>.

=head2 subset_or_superset

    ::MD::subset_or_superset ::= function
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative
        : (topic --> \@subset_of or topic --> \@superset_of);

The function C<subset_or_superset> results in C<True> iff the multiset of
members of one of its 2 arguments C<0> and C<1> is a subset of the multiset
of members of its other argument; otherwise it results in C<False>.

=head2 overlaps_members

    ::MD::overlaps_members::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative;

The virtual function C<overlaps_members> results in C<True> iff, given I<X> as the
multiset of members of its argument C<0> and I<Y> as the multiset of
members of its argument C<1>, there exists at least 1 member that both I<X>
and I<Y> have, and there also exists at least 1 other member each of I<X>
and I<Y> that the other doesn't have; otherwise it results in C<False>.

=head2 disjoint_members

    ::MD::disjoint_members::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative;

The virtual function C<disjoint_members> results in C<True> iff the multiset of
members of its C<0> argument has no member values in common with the
multiset of members of its C<1> argument; otherwise it results in C<False>.

=head2 member_plus ⊎

    ::MD::member_plus::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Homogeneous)
        is associative;

    ::MD::Unicode_Aliases::"⊎" ::= alias of member_plus;

The virtual function C<member_plus> aka C<⊎> results in the I<multiset sum>
of its 2 arguments C<0> and C<1>.  The result is a value of the function's
C<0> argument's collection type that has all of the members of the
function's C<0> argument plus all of the members of its C<1> argument.  For
every distinct member value of the result, its multiplicity is the integral
sum of the multiplicities of that same member value of each of the 2
arguments; however, if the result's type is C<Setty>, the result will only
have 1 member per distinct member value (any duplicates will be silently
eliminated).  If the result's type is C<Positional>, then the result starts
with all of the members of C<0> and ends with the members of C<1>, the
members from both in the same order as in their respective arguments; that
is, this function then behaves identically to C<catenate> aka C<~> when
given the same arguments.  This operation has an identity value of a
collection with zero members.  For non-ordered types, this operation is
also commutative.  Other programming languages may name their corresponding
operators I<union all> or I<+>.

=head2 except ∖

    ::MD::except::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Homogeneous);

    ::MD::Unicode_Aliases::"∖" ::= alias of except;

The virtual function C<except> aka C<∖> results in the I<multiset
difference> between its 2 arguments C<0> (I<minuend>) and C<1>
(I<subtrahend>).  The result is a value of the function's C<0> argument's
collection type that has all of the members of the function's C<0> argument
minus all of the matching members of its C<1> argument.  For every distinct
member value of the result, its multiplicity is the integral difference of
the multiplicities of that same member value of each of the 2 arguments
(when subtracting the I<subtrahend> from the I<minuend>); a multiplicity is
zero when it would otherwise be negative.  If the result's type is
C<Positional>, then the removed instances of any distinct member value are
those closest to the end of C<0>.  Note that C<except> is designed to
mirror C<member_plus> and so the identity C<x = except(member_plus(x,y),y)>
should hold for any C<Homogeneous> type, even a C<Positional> one, except
with C<Setty> C<x> and C<y> that have any members that are the same value.
Other programming languages may name their corresponding operators I<minus>
or I<-> or I<difference> or I<\\> or I<complement> or I<setdiff> or I<diff>
or I<--> etc or I<subtract>.

=head2 intersect ∩

    ::MD::intersect::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Homogeneous)
        is {associative,idempotent};

    ::MD::Unicode_Aliases::"∩" ::= alias of intersect;

The virtual function C<intersect> aka C<∩> results in the I<multiset
intersection> of its 2 arguments C<0> and C<1>.  The result is a value of
the function's C<0> argument's collection type that has all of the members
of the function's C<0> argument that match their own members of its C<1>
argument.  For every distinct member value of the result, its multiplicity
is the integral minimum of the multiplicities of that same member value of
each of the 2 arguments (any nonmatched argument member does not appear in
the result).  If the result's type is C<Positional>, then the removed
instances of any distinct member value are those closest to the end of
C<0>.  This operation conceptually has an identity value of a collection
with an infinite number of members.  For non-ordered types, this operation
is also commutative.  Other programming languages may name their
corresponding operators I<&> or I<*>.

=head2 union ∪

    ::MD::union::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Homogeneous)
        is idempotent;

    ::MD::Unicode_Aliases::"∪" ::= alias of union;

The virtual function C<union> aka C<∪> results in the I<multiset union> of
its 2 arguments C<0> and C<1>.  The result is a value of the function's
C<0> argument's collection type that has all of the members of the
function's C<0> argument plus all of the nonmatching members of its C<1>
argument.  For every distinct member value of the result, its multiplicity
is the integral maximum of the multiplicities of that same member value of
each of the 2 arguments.  If the result's type is C<Positional>, then the
result starts with all of the members of C<0> and ends with the nonmatching
members of C<1>, the members from both in the same order as in their
respective arguments; the removed (due to matching) instances of any
distinct member value are those closest to the end of C<1>.  Note that the
identity C<union(x,y) = member_plus(x,except(y,x))> should hold for any
C<Homogeneous> type, even a C<Positional> one.  This operation has an
identity value of a collection with zero members.  For non-ordered types,
this operation is also associative and commutative.  Other programming
languages may name their corresponding operators I<|> or I<+>.

=head2 exclusive symm_diff ∆

    ::MD::exclusive::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Homogeneous);

    ::MD::symm_diff ::= alias of exclusive;

    ::MD::Unicode_Aliases::"∆" ::= alias of exclusive;

The virtual function C<exclusive> aka C<symm_diff> aka C<∆> results in the
I<multiset symmetric difference> of its 2 arguments C<0> and C<1>.  The
result is a value of the function's C<0> argument's collection type that
has all of the members of each of the function's C<0> and C<1> arguments
that do not have matching members of their counterpart argument.  For every
distinct member value of the result, its multiplicity is the integral
maximum of the multiplicities of that same member value of each of the 2
arguments, minus the integral minimum of the same.  If the result's type is
C<Positional>, then the result starts with the nonmatching members of C<0>
and ends with the nonmatching members of C<1>, the members from both in the
same order as in their respective arguments; the removed (due to matching)
instances of any distinct member value are those closest to the end of C<0>
or C<1> respectively.  Note that the identity C<exclusive(x,y) =
member_plus(except(x,y),except(y,x)) = except(union(x,y),intersect(x,y))>
should hold for any C<Homogeneous> type, even a C<Positional> one.  This
operation has an identity value of a collection with zero members.  For
non-ordered types, this operation is also associative and commutative.
Other programming languages may name their corresponding operators
I<symmdiff> or I<^> or I<%>.

=head2 nest group

    ::MD::nest::"" ::= function virtual --> Homogeneous <-- (Homogeneous)
        requires (...);

    ::MD::group ::= alias of nest;

I<TODO.>

=head2 unnest ungroup

    ::MD::unnest::"" ::= function virtual --> Homogeneous <-- (Homogeneous)
        requires (...);

    ::MD::ungroup ::= alias of unnest;

I<TODO.>

=head2 any there_exists ∃

    ::MD::any::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Primed_Func_Ref);

    ::MD::there_exists ::= alias of any;

    ::MD::Unicode_Aliases::"∃" ::= alias of any;

I<TODO.  Result is true when at least one member evaluates to true.
This is logically equivalent to testing if a same-topic 'where' result is nonempty,
but 'any' is instead virtual with applicable Foundation-level functions to
aid efficiency with less-savvy optimizers that don't know to short-circuit.>

=head2 none there_does_not_exist ∄

    ::MD::none ::= function negates any;

    ::MD::there_does_not_exist ::= alias of none;

    ::MD::Unicode_Aliases::"∄" ::= alias of none;

I<TODO.  Result is true when no member evaluates to true.>

=head2 all for_all ∀

    ::MD::all ::= function --> Boolean <-- (Homogeneous, Primed_Func_Ref)
        : (\.0 none negated_func(of : \.1, passing_args : \@(0)));

    ::MD::for_all ::= alias of all;

    ::MD::Unicode_Aliases::"∀" ::= alias of all;

I<TODO.  Result is true when no member evaluates to false.>

=head2 all_is_a

    ::MD::all_is_a ::= function --> Boolean <-- (Homogeneous, Reference)
        : (\.0 all (\@is_a assuming topic ^ \@(1)));

I<TODO.>

=head2 where

    ::MD::where::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Primed_Func_Ref);

I<TODO.  The primed-func-ref is expected to be a Capsule with 2 asset attrs
named 'func' and 'args', which are a Reference and a Tuple respectively.
The 'args' can be any Tuple that doesn't have a '0' attr.
The function referenced by 'func' is expected to take a Tuple argument
whose '0' attr is a member of the collection and whose other attrs match
those given in 'args'.>

=head2 filtering

    ::MD::filtering ::= function commutes where;

I<TODO.>

=head2 map

    ::MD::map::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Primed_Func_Ref);

I<TODO.  The primed-func-ref is as per that of 'where'.>

=head2 reduce

    ::MD::reduce::"" ::= function virtual
        --> Any <-- (Homogeneous, Primed_Func_Ref);

I<TODO.  The primed-func-ref is expected to be a Capsule with 2 asset attrs
named 'func' and 'args', which are a Reference and a Tuple respectively.
The 'args' can be any Tuple that doesn't have either '0' or '1' attrs.
The function referenced by 'func' is expected to take a Tuple argument
whose '0' and '1' attrs are members of the collection and whose other attrs match
those given in 'args'.
Depending on the collection subtype, order of 0,1 may or may not be significant.
If collection is unordered, func must be both associative and commutative,
and reduce can always be parallelized.
If collection is ordered, reduce can be parallelized if func is associative;
otherwise the reduce is a serial operation, at least naively.>

=head1 DISCRETE DATA TYPES

=head2 Discrete

    ::MD::Discrete ::= interface
        composes Homogeneous and_provides_its_default
        requires_implements {so,empty
            ,has_n,multiplicity,insert_n,remove_n
            ,all_unique,unique
            ,subset_of,same_members,overlaps_members,disjoint_members
            ,member_plus,except,intersect,union,exclusive
            ,nest,unnest,any,where,map,reduce,...
            ,to_Set,to_Bag,count,unique_count};

The interface contract C<Discrete> is infinite.  A C<Discrete> value is a
C<Homogeneous> value such that all of its members can be enumerated as
individuals and counted.  The default value of C<Discrete> is the C<Array>
value with zero members, C<[]>.

C<Discrete> is composed, directly or indirectly, by: C<Positional>,
C<Array>, C<String>, C<Setty>, C<Set>, C<Bag>, C<Relational>, C<Relation>,
C<Tuple_Bag>.

=head2 to_Set ?<

    ::MD::to_Set::"" ::= function virtual --> Set <-- (Discrete);

    ::MD::"?<" ::= alias of to_Set;

The virtual function C<to_Set> aka C<< ?< >> results in the C<Set> value
that represents the same set of distinct member values as its C<0>
argument.  The purpose of C<to_Set> is to canonicalize C<Discrete> values
so they can be treated abstractly as sets of discrete values, for
operations where neither multiplicity nor order is significant.

=head2 to_Bag +<

    ::MD::to_Bag::"" ::= function virtual --> Bag <-- (Discrete);

    ::MD::"+<" ::= alias of to_Bag;

The virtual function C<to_Bag> aka C<< +< >> results in the C<Bag> value
that represents the same multiset of members as its C<0> argument.  The
purpose of C<to_Bag> is to canonicalize C<Discrete> values so they can be
treated abstractly as multisets of discrete values, for operations where
multiplicity possibly is significant but order doesn't.

=head2 count cardinality #

    ::MD::count::"" ::= function virtual --> Integer_NN <-- (Discrete);

    ::MD::cardinality ::= alias of count;
    ::MD::"#"         ::= alias of count;

The virtual function C<count> aka C<cardinality> aka C<#> results in the
integral count of the members of its C<0> argument; when multiple members
have the same member value, every member counts as 1 towards the total.

=head2 unique_count

    ::MD::unique_count::"" ::= function virtual --> Integer_NN <-- (Discrete);

The virtual function C<unique_count> results in the integral count of the
distinct member values of its C<0> argument.

=head1 POSITIONAL DATA TYPES

=head2 Positional

    ::MD::Positional ::= interface
        composes {Stringy, Accessible, Discrete and_provides_its_default}
        requires_implements {so,empty
            ,substring_of,overlaps_string,disjoint_string
            ,catenate,replicate
            ,has_n,multiplicity,insert_n,remove_n
            ,all_unique,unique
            ,except,intersect,union,exclusive
            ,nest,unnest,any,where,map,reduce,...
            ,to_Bag,to_Set,count
            ,to_Array,elem,has_index,first_index,last_index,slice,index_succ_all_matches,...};

The interface contract C<Positional> is infinite.  A C<Positional> value is
both a C<Stringy> value and a C<Discrete> value; it is a homogeneous
aggregate of other, I<member> values that are arranged in an explicit total
order and can both be enumerated in that order as well as be looked up by
integral indexed-based position against that order; there is a single
canonical interpretation of where each I<member> begins and ends within the
aggregate.  A C<Positional> value is dense, meaning that every one of its
members exists at a distinct adjacent integral position; a C<Positional>
preserves the identity that the count of its members is equal to one plus
the difference of its first and last index positions.  Idiomatically, a
C<Positional> value is zero-based, meaning its first-ordered member is at
index position C<0>, but that doesn't have to be the case.

The default value of C<Positional> is the C<Array> value with zero members,
C<[]>.  C<Positional> is C<Orderable> in the general case conditionally
depending on whether all of its member values are mutually C<Orderable>
themselves; its minimum value is the same C<[]> as its default value; it
has no maximum value.  The ordering algorithm of C<Positional> is based on
pairwise comparison of its members by matching index starting at the lowest
index; iff C<Positional> value X is a leading sub-sequence of C<Positional>
value Y, then X is ordered before Y; otherwise, the mutual ordering of the
lowest-indexed non-matching members of X and Y determines that the ordering
of X and Y as a whole are the same as said members.  C<Positional> is
composed, directly or indirectly, by: C<Array>, C<String>.

=head2 Excuse::No_Such_Index

    ::MD::Excuse::No_Such_Index ::= constant (\@0) composes Excuse;

I<TODO.>

=head2 in_order (Positional)

    ::MD::in_order::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
    : (
        i ::= (topic --> \@index_succ_all_matches);
      <--
        if not \.0 .? i then
            e1 ::= True
        else if not \.1 .? i then
            False
        else
            e2 ::= (\.0.i in_order \.1.i);

        e1 ::?= 'This is the case where LHS is a leading subsequence of or is equal to RHS.';
        e2 ::?= 'This will succeed iff in_order() is defined for the member type.';
    );

The function C<in_order::Positional> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Positional>.

=head2 subset_of (Positional)

    ::MD::subset_of::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
        : ((\.0->to_Bag) subset_of (\.1->to_Bag));

The function C<subset_of::Positional> results in C<True> iff the multiset
of members of its C<0> argument is a subset of the multiset of members of
its C<1> argument; otherwise it results in C<False>.  This function
implements the C<Homogeneous> virtual function C<subset_of> aka C<⊆> for
the composing type C<Positional>.

=head2 same_members (Positional)

    ::MD::same_members::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
        is commutative
        : ((\.0->to_Bag) same_members (\.1->to_Bag));

The function C<same_members::Positional> results in C<True> iff the
multiset of members of its C<0> argument is the same as the multiset of
members of its C<1> argument; otherwise it results in C<False>.  This
function may result in C<True> for some arguments for which C<same> would
result in C<False> because the latter considers member order significant
while the former doesn't.  This function implements the C<Homogeneous>
virtual function C<same_members> for the composing type C<Positional>.

=head2 overlaps_members (Positional)

    ::MD::overlaps_members::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
        is commutative
        : ((\.0->to_Bag) overlaps_members (\.1->to_Bag));

The function C<overlaps_members::Positional> results in C<True> iff, given
I<X> as the multiset of members of its argument C<0> and I<Y> as the
multiset of members of its argument C<1>, there exists at least 1 member
that both I<X> and I<Y> have, and there also exists at least 1 other member
each of I<X> and I<Y> that the other doesn't have; otherwise it results in
C<False>.  This function implements the C<Homogeneous> virtual function
C<overlaps_members> for the composing type C<Positional>.

=head2 disjoint_members (Positional)

    ::MD::disjoint_members::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
        is commutative
        : ((\.0->to_Bag) disjoint_members (\.1->to_Bag));

The function C<disjoint_members::Positional> results in C<True> iff the
multiset of members of its C<0> argument has no member values in common
with the multiset of members of its C<1> argument; otherwise it results in
C<False>.  This function implements the C<Homogeneous> virtual function
C<disjoint_members> for the composing type C<Positional>.

=head2 member_plus (Positional)

    ::MD::member_plus::Positional ::= function
        --> Positional <-- (Positional, Positional)
        implements 2::""
        is associative
        : (topic --> \@catenate);

The function C<member_plus::Positional> results in the I<multiset sum> of
its 2 arguments C<0> and C<1>; it behaves identically to C<catenate> aka
C<~> when given the same arguments.  This function implements the
C<Homogeneous> virtual function C<member_plus> aka C<⊎> for the composing
type C<Positional>.

=head2 unique_count (Positional)

    ::MD::unique_count::Positional ::= function --> Integer_NN <-- (Positional)
        implements 2::""
        : (\.0->to_Set->count);

The function C<unique_count::Positional> results in the integral count of
the distinct member values of its C<0> argument.  This function implements
the C<Discrete> virtual function C<unique_count> for the composing type
C<Positional>.

=head2 to_Array ~<

    ::MD::to_Array::"" ::= function virtual --> Array <-- (Positional);

    ::MD::"~<" ::= alias of to_Array;

The virtual function C<to_Array> aka C<< ~< >> results in the C<Array>
value that represents the same sequence of members as its C<0> argument.
The purpose of C<to_Array> is to canonicalize C<Positional> values so they
can be treated abstractly as sequences of discrete values with minimal
effort.

=head2 elem . (Positional)

    ::MD::elem::"" ::= function virtual --> Any <-- (Positional, Integral)
        requires (topic --> \@has_index);

    ::MD::"."::Positional ::= function --> Any <-- (Positional, Integral)
        implements 2::""
        requires (topic --> \@has_index)
        : (topic --> \@elem);

I<TODO.>

=head2 has_index .? (Positional)

    ::MD::has_index::"" ::= function virtual --> Boolean <-- (Positional, Integral);

    ::MD::".?"::Positional ::= function --> Boolean <-- (Positional, Integral)
        implements 2::""
        : (topic --> \@has_index);

I<TODO.>

=head2 elem_or_excuse .! (Positional)

    ::MD::elem_or_excuse ::= function --> Any <-- (Positional, Integral)
        : (topic --> \@has_index ?? topic --> \@elem !! Excuse::No_Such_Index());

    ::MD::".!"::Positional ::= function --> Any <-- (Positional, Integral)
        implements 2::""
        : (topic --> \@elem_or_excuse);

I<TODO.>

=head2 squish

    ::MD::squish ::= function --> Positional <-- (Positional)
        : (\.0 map (function : (\%( group : \.0, member : False )))
            ->nest map (function : (\.0.\group)));

The function C<squish> results in the value of its C<0> argument's
ordered collection type that has all of the members of the function's C<0>
argument but that, for every run of 2 or more consecutive members that are
all the same value, that run retains only 1 of those members.  Iff the
argument is such that all appearances of each distinct value are adjacent
members, the result of C<squish> is the same as that of C<unique>.

=head2 first_index

    ::MD::first_index::"" ::= function virtual --> Integral <-- (Positional)
        requires (?\.0);

I<TODO.>

=head2 last_index

    ::MD::last_index::"" ::= function virtual --> Integral <-- (Positional)
        requires (?\.0);

I<TODO.>

=head2 slice

    ::MD::slice::"" ::= function virtual
        --> Positional <-- (Positional, Interval);

I<TODO.  Need to clarify constraints, eg is this a strict subsequence
operation or is it more like an intersection.>

=head2 first

    ::MD::first ::= function --> Any <-- (Positional)
        requires (?\.0)
        : (\.0 . first_index(\.0));

I<TODO.>

=head2 nonfirst

    ::MD::nonfirst ::= function --> Positional <-- (Positional)
        requires (?\.0)
        : (\.0 slice first_index(\.0)^..last_index(\.0));

I<TODO.>

=head2 last

    ::MD::last ::= function --> Any <-- (Positional)
        requires (?\.0)
        : (\.0 . last_index(\.0));

I<TODO.>

=head2 nonlast

    ::MD::nonlast ::= function --> Positional <-- (Positional)
        requires (?\.0)
        : (\.0 slice first_index(\.0)..^last_index(\.0));

I<TODO.>

=head2 index_succ_all_matches

    ::MD::index_succ_all_matches::"" ::= function virtual
        --> Integral <-- (Positional, Positional)
        is commutative;

I<TODO.  Also consider index_succ_common_prefix as name.>

=head1 ARRAY DATA TYPES

=head2 Array

    ::MD::Array ::= selection where (topic -->^ FDN__is_a_Array)
        default ([])
        composes Positional and_provides_its_default;

The selection contract C<Array> represents the infinite Muldis D Foundation
type I<FDN__Array>.  An C<Array> value is a general purpose
arbitrarily-long ordered sequence of any other, I<member> values, which
explicitly does not represent any kind of thing in particular, and is
simply the sum of its members.  An C<Array> value is dense; iff it has any
members, then its first-ordered member is at index position C<0>, and its
last-indexed member is at the index position that is one less than the
count of its members.  An C<Array> in the general case may have
multiple members that are the same value, and any duplicates may or may not
exist at consecutive indexes.  The default value of C<Array> is C<[]>, the
only zero-member C<Array> value.  C<Array> is C<Orderable>; its minimum
value is the same C<[]> as its default value; it has no maximum value; its
ordering algorithm is defined by C<Positional>.  Other programming
languages may name their corresponding types I<List>.

=head2 String

    ::MD::String::"" ::= selection of Array where (topic all_is_a \@Integer);

The selection contract C<String> represents the infinite type consisting
just of the C<Array> values having just C<Integer> members.  A C<String>
value is a general purpose integer string, which explicitly does not
represent any kind of thing in particular, neither octets nor characters
nor anything else, simply a sequence of generic integers.  A C<String>
value is isomorphic to an C<Attr_Name> value, and values of proper subtypes
of C<String> are isomorphic to C<Bits> and C<Blob> and C<Text> values.

Other programming languages don't necessarily have a dedicated type
representing a string of generic integers, but rather they may have generic
arrays, or bit arrays with names like I<bit> or I<bit varying>,
or octet arrays with names like I<byte[]> or I<bytea>, or character
arrays with names like I<string> or I<text> or I<varchar>, or types like
I<string> that may represent either octets or characters.

=head2 empty_Array ~∅

    ::MD::empty_Array ::= constant ([]);

    ::MD::Unicode_Aliases::"~∅" ::= alias of empty_Array;

The constant C<empty_Array> aka C<~∅> represents the only zero-member
C<Array> value, C<[]>.

=head2 so (Array)

    ::MD::so::Array ::= function --> Boolean <-- (Array)
        implements 2::""
        : (\.0 != []);

The function C<so::Array> results in C<True> iff its C<0> argument has any
members, and in C<False> iff it has no members.  This function implements
the C<Boolable> virtual function C<so> aka C<?> aka C<to_Boolean> for the
composing type C<Array>.

=head2 empty (Array)

    ::MD::empty::Array ::= function --> Array <-- (Array)
        implements 2::""
        : ([]);

The function C<empty::Array> results in the only zero-member C<Array>
value.  This function implements the C<Emptyable> virtual function C<empty>
aka C<∅> for the composing type C<Array>.

=head2 substring_of (Array)

    ::MD::substring_of::Array ::= function --> Boolean <-- (Array, Array)
        implements 2::""
        : (topic -->^ FDN__Array_substring_of);

The function C<substring_of::Array> results in C<True> iff the sequence of
members of its C<0> argument is a substring of the sequence of members of
its C<1> argument; otherwise it results in C<False>.  This function
implements the C<Stringy> virtual function C<substring_of> for the
composing type C<Array>.

=head2 overlaps_string (Array)

    ::MD::overlaps_string::Array ::= function --> Boolean <-- (Array, Array)
        implements 2::""
        is commutative
        : (topic -->^ FDN__Array_overlaps_string);

The function C<overlaps_string::Array> results in C<True> iff, given I<X>
as the sequence of members of its argument C<0> and I<Y> as the sequence of
members of its argument C<1>, when I<X> and I<Y> are overlapped to the
greatest possible extent such that every corresponding member pair has 2 of
the same value, the overlap of I<X> and I<Y> has at least 1 member, and
each of I<X> and I<Y> has at least 1 member that is not overlapped;
otherwise it results in C<False>.  This function implements the C<Stringy>
virtual function C<overlaps_string> for the composing type C<Array>.

=head2 disjoint_string (Array)

    ::MD::disjoint_string::Array ::= function --> Boolean <-- (Array, Array)
        implements 2::""
        is commutative
        : (topic -->^ FDN__Array_disjoint_string);

The function C<disjoint_string::Array> results in C<True> iff the sequence
of members of its C<0> argument can not be overlapped with the sequence of
members of its C<1> argument by at least 1 member such that every
corresponding member pair has 2 of the same value; otherwise it results in
C<False>.  This function implements the C<Stringy> virtual function
C<disjoint_string> for the composing type C<Array>.

=head2 catenate (Array)

    ::MD::catenate::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        is associative identity ([])
        repeater replicate::Array
        : (topic -->^ FDN__Array_catenate);

The function C<catenate::Array> results in the catenation of its 2
arguments C<0> and C<1> such that the result starts with the members of
C<0> and ends with the members of C<1>.  This function implements the
C<Stringy> virtual function C<catenate> aka C<~> for the composing type
C<Array>.

=head2 replicate (Array)

    ::MD::replicate::Array ::= function --> Array <-- (Array, Integer_NN)
        implements 2::""
        : (topic -->^ FDN__Array_replicate);

The function C<replicate::Array> results in the catenation of N instances
of its C<0> argument where N is defined by its C<1> argument.  If the C<1>
argument is zero then the result is the only zero-member C<Array>.  This
function implements the C<Stringy> virtual function C<replicate> aka C<~#>
for the composing type C<Array>.

=head2 has_n (Array)

    ::MD::has_n::Array ::= function --> Boolean <-- (Array, Any, Integer_NN)
        implements 2::""
        : (topic -->^ FDN__Array_has_n);

The function C<has_n::Array> results in C<True> iff its C<0> argument has
at least N members at any indexes such that each is equal to its C<1>
argument, where N is defined by its C<2> argument; otherwise it results in
C<False>.  This function implements the C<Homogeneous> virtual function
C<has_n> for the composing type C<Array>.

=head2 multiplicity (Array)

    ::MD::multiplicity::Array ::= function --> Integer_NN <-- (Array, Any)
        implements 2::""
        : (topic -->^ FDN__Array_multiplicity);

The function C<multiplicity::Array> results in the integral count
of members of its C<0> argument such that each member value is equal to its
C<1> argument.  This function implements the C<Homogeneous> virtual
function C<multiplicity> for the composing type C<Array>.

=head2 insert_n (Array)

    ::MD::insert_n::Array ::= function --> Array <-- (Array, Any, Integer_NN)
        implements 2::""
        : (topic -->^ FDN__Array_insert_n);

The function C<insert_n::Array> results in the C<Array> value that has all
of the members of the function's C<0> argument plus N additional members
that are each equal to its C<1> argument, where N is defined by its C<2>
argument.  The result starts with all of the members of C<0> in the same
order and ends with any added instances of C<1>.  This function implements
the C<Homogeneous> virtual function C<insert_n> for the composing type
C<Array>.

=head2 remove_n (Array)

    ::MD::remove_n::Array ::= function --> Array <-- (Array, Any, Integer_NN)
        implements 2::""
        : (topic -->^ FDN__Array_remove_n);

The function C<remove_n::Array> results in the C<Array> value that has all
of the members of the function's C<0> argument minus N existing members
that are each equal to its C<1> argument, where N is defined as the lesser
of its C<2> argument and the count of members of C<0> equal to the C<1>
argument.  The removed instances of C<1> are those closest to the end of
C<0>.  This function implements the C<Homogeneous> virtual function
C<remove_n> for the composing type C<Array>.

=head2 all_unique (Array)

    ::MD::all_unique::Array ::= function --> Boolean <-- (Array)
        implements 2::""
        : (topic -->^ FDN__Array_all_unique);

The function C<all_unique::Array> results in C<True> iff its C<0> argument
has no 2 members that are the same value, and C<False> otherwise.  This
function implements the C<Homogeneous> virtual function C<all_unique> for
the composing type C<Array>.

=head2 unique (Array)

    ::MD::unique::Array ::= function --> Array <-- (Array)
        implements 2::""
        : (topic -->^ FDN__Array_unique);

The function C<unique::Array> results in the C<Array> value that has, for
every distinct member value I<V> of the function's C<0> argument, exactly 1
member whose value is equal to I<V>.  Each retained member is the one
closest to the start of the argument out of those members sharing the
retained member's value.  This function implements the C<Homogeneous>
virtual function C<unique> for the composing type C<Array>.

=head2 except (Array)

    ::MD::except::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        : (topic -->^ FDN__Array_except);

The function C<except::Array> results in the I<multiset difference> between
its 2 arguments C<0> (I<minuend>) and C<1> (I<subtrahend>).  The result is
the C<Array> value that has all of the members of the function's C<0>
argument minus all of the matching members of its C<1> argument.  The
removed instances of any distinct member value are those closest to the end
of C<0>.  This function implements the C<Homogeneous> virtual function
C<except> aka C<∖> for the composing type C<Array>.

=head2 intersect (Array)

    ::MD::intersect::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        is {associative,idempotent}
        : (topic -->^ FDN__Array_intersect);

The function C<intersect::Array> results in the I<multiset intersection> of
its 2 arguments C<0> and C<1>.  The result is the C<Array> value that has
all of the members of the function's C<0> argument that match their own
members of its C<1> argument.  The removed instances of any distinct member
value are those closest to the end of C<0>.  This operation conceptually
has an identity value of a collection with an infinite number of members. 
This function implements the C<Homogeneous> virtual function C<intersect>
aka C<∩> for the composing type C<Array>.

=head2 union (Array)

    ::MD::union::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        is idempotent identity ([])
        : (topic -->^ FDN__Array_union);

The function C<union::Array> results in the I<multiset union> of its 2
arguments C<0> and C<1>.  The result is the C<Array> value that has all of
the members of the function's C<0> argument plus all of the nonmatching
members of its C<1> argument.  The result starts with all of the members of
C<0> and ends with the nonmatching members of C<1>, the members from both
in the same order as in their respective arguments; the removed (due to
matching) instances of any distinct member value are those closest to the
end of C<1>.  This function implements the C<Homogeneous> virtual function
C<union> aka C<∪> for the composing type C<Array>.

=head2 exclusive (Array)

    ::MD::exclusive::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        identity ([])
        : (topic -->^ FDN__Array_exclusive);

The function C<exclusive::Array> results in the I<multiset symmetric
difference> of its 2 arguments C<0> and C<1>.  The result is the C<Array>
value that has all of the members of each of the function's C<0> and C<1>
arguments that do not have matching members of their counterpart argument. 
The result starts with the nonmatching members of C<0> and ends with the
nonmatching members of C<1>, the members from both in the same order as in
their respective arguments; the removed (due to matching) instances of any
distinct member value are those closest to the end of C<0> or C<1>
respectively.  This function implements the C<Homogeneous> virtual function
C<exclusive> aka C<symm_diff> aka C<∆> for the composing type C<Array>.

=head2 nest (Array)

    ::MD::nest::Array ::= function --> Array <-- (Array)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Array_nest);

I<TODO.>

=head2 unnest (Array)

    ::MD::unnest::Array ::= function --> Array <-- (Array)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Array_unnest);

I<TODO.>

=head2 any (Array)

    ::MD::any::Array ::= function --> Boolean <-- (Array, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Array_any);

I<TODO.>

=head2 where (Array)

    ::MD::where::Array ::= function --> Array <-- (Array, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Array_where);

I<TODO.>

=head2 map (Array)

    ::MD::map::Array ::= function --> Array <-- (Array, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Array_map);

I<TODO.>

=head2 reduce (Array)

    ::MD::reduce::Array ::= function --> Any <-- (Array, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Array_reduce);

I<TODO.>

=head2 to_Set (Array)

    ::MD::to_Set::Array ::= function --> Set <-- (Array)
        implements 2::""
        : (\.0->to_Bag->to_Set);

The function C<to_Set::Array> results in the C<Set> value that has, for
every distinct member value I<V> of the function's C<0> argument, exactly 1
member whose value is equal to I<V>.  This function implements the
C<Discrete> virtual function C<to_Set> aka C<< ?< >> for the composing type
C<Array>.

=head2 to_Bag (Array)

    ::MD::to_Bag::Array ::= function --> Bag <-- (Array)
        implements 2::""
        : (topic -->^ FDN__Array_to_Bag);

The function C<to_Bag::Array> results in the C<Bag> value that has all of
the members of the function's C<0> argument.  This function implements the
C<Discrete> virtual function C<to_Bag> aka C<< +< >> for the composing type
C<Array>.

=head2 count (Array)

    ::MD::count::Array ::= function --> Integer_NN <-- (Array)
        implements 2::""
        : (topic -->^ FDN__Array_count);

The function C<count::Array> results in the integral count of the members
of its C<0> argument.  This function implements the C<Discrete> virtual
function C<count> aka C<cardinality> aka C<#> for the composing type
C<Array>.

=head2 to_Array (Array)

    ::MD::to_Array::Array ::= function --> Array <-- (Array)
        implements 2::""
        : (\.0);

The function C<to_Array::Array> simply results in its C<0> argument.  This
function implements the C<Positional> virtual function C<to_Array> aka
C<< ~< >> for the composing type C<Array>.

=head2 elem (Array)

    ::MD::elem::Array ::= function --> Any <-- (Array, Integer_NN)
        implements 2::""
        requires (topic --> \@has_index)
        : (topic -->^ FDN__Array_elem);

I<TODO.  Note, Ruby calls this "a.at(n)" alternately to a[n].>

=head2 has_index (Array)

    ::MD::has_index::Array ::= function --> Boolean <-- (Array, Integer_NN)
        implements 2::""
        : (topic -->^ FDN__Array_has_index);

I<TODO.  True if given array index exists.>

=head2 first_index (Array)

    ::MD::first_index::Array ::= function --> Integer_NN <-- (Array)
        implements 2::""
        requires (?\.0)
        : (0);

I<TODO.>

=head2 last_index (Array)

    ::MD::last_index::Array ::= function --> Integer_NN <-- (Array)
        implements 2::""
        requires (?\.0)
        : (-- #\.0);

I<TODO.>

=head2 slice (Array)

    ::MD::slice::Array ::= function --> Array <-- (Array, Interval)
        implements 2::""
        : (topic -->^ FDN__Array_slice);

I<TODO.>

=head2 index_succ_all_matches (Array)

    ::MD::index_succ_all_matches::Array ::= function
        --> Integer_NN <-- (Array, Array)
        implements 2::""
        is commutative
        : (topic -->^ FDN__Array_index_succ_all_matches);

I<TODO.  While conceivably implementable at a higher level, make low level
for perceived efficiency.>

=head1 SETTY DATA TYPES

=head2 Setty

    ::MD::Setty ::= interface;

The interface contract C<Setty> is infinite.  A C<Setty> value is a
I<collective> value such that every one of its component I<members> is a
distinct value.  The default value of C<Setty> is the C<Set> value with
zero members, C<{}>.  C<Setty> is composed, directly or indirectly, by:
C<Set>, C<Relation>.

=head1 SET DATA TYPES

=head2 Set

    ::MD::Set ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped( topic, \Set, \@1::_Asset ))
            default ({})
            composes {Discrete, Setty and_provides_its_default};

        _Asset ::= selection of Bag
            where (all_unique topic);
    };

The selection contract C<Set> is infinite.  A C<Set> value is a general
purpose arbitrarily-large unordered collection of any other, I<member>
values, which explicitly does not represent any kind of thing in
particular, and is simply the sum of its members.  A C<Set> ensures that no
2 of its members are the same value.  The default value of C<Set> is C<{}>,
the only zero-member C<Set> value.

I<TODO. Update 'where' to say quantity for each distinct member is 1,
using a Foundation function specific to that purpose.>

=head2 empty_Set ?∅

    ::MD::empty_Set ::= constant ({});

    ::MD::Unicode_Aliases::"?∅" ::= alias of empty_Set;

The constant C<empty_Set> aka C<?∅> represents the only zero-member
C<Set> value, C<{}>.

=head2 so (Set)

    ::MD::so::Set ::= function --> Boolean <-- (Set)
        implements 2::""
        : (\.0 != {});

The function C<so::Set> results in C<True> iff its C<0> argument has any
members, and in C<False> iff it has no members.  This function implements
the C<Boolable> virtual function C<so> aka C<?> aka C<to_Boolean> for the
composing type C<Set>.

=head2 empty (Set)

    ::MD::empty::Set ::= function --> Set <-- (Set)
        implements 2::""
        : ({});

The function C<empty::Set> results in the only zero-member C<Set>
value.  This function implements the C<Emptyable> virtual function C<empty>
aka C<∅> for the composing type C<Set>.

=head2 has_n (Set)

    ::MD::has_n::Set ::= function --> Boolean <-- (Set, Any, Integer_NN)
        implements 2::""
        : (has_n(\.0->unwrap, \.1, \.2));

The function C<has_n::Set> results in C<True> iff either its C<2> argument
is zero or its C<0> argument has a member equal to its C<1> argument and
its C<2> argument is 1; otherwise it results in C<False>.  This function
implements the C<Homogeneous> virtual function C<has_n> for the composing
type C<Set>.

=head2 multiplicity (Set)

    ::MD::multiplicity::Set ::= function --> Integer_NN <-- (Set, Any)
        implements 2::""
        : (\.0->unwrap multiplicity \.1);

The function C<multiplicity::Set> results in 1 if its C<0> argument
has a member equal to its C<1> argument; otherwise it results in 0.  This
function implements the C<Homogeneous> virtual function C<multiplicity> for
the composing type C<Set>.

=head2 insert_n (Set)

    ::MD::insert_n::Set ::= function --> Set <-- (Set, Any, Integer_NN)
        implements 2::""
        : (\.0 has \.1 or \.2 = 0 ?? \.0
            !! \Set wrap insert_n(\.0->unwrap, \.1, 1));

The function C<insert_n::Set> results in the C<Set> value that has all of
the members of the function's C<0> argument; but, if the C<2> argument is
nonzero then the result has a member equal to the C<1> argument, whether or
not C<0> had it.  This function implements the C<Homogeneous> virtual
function C<insert_n> for the composing type C<Set>.

=head2 remove_n (Set)

    ::MD::remove_n::Set ::= function --> Set <-- (Set, Any, Integer_NN)
        implements 2::""
        : (\Set wrap remove_n(\.0->unwrap, \.1, \.2));

The function C<remove_n::Set> results in the C<Set> value that has all of
the members of the function's C<0> argument; but, if the C<2> argument is
nonzero and C<0> had a member equal to the C<1> argument, the result lacks
that member.  This function implements the C<Homogeneous> virtual function
C<remove_n> for the composing type C<Set>.

=head2 all_unique (Set)

    ::MD::all_unique::Set ::= function --> Boolean <-- (Set)
        implements 2::""
        : (True);

The function C<all_unique::Set> simply results in C<True>.  This function
implements the C<Homogeneous> virtual function C<all_unique> for the
composing type C<Set>.

=head2 unique (Set)

    ::MD::unique::Set ::= function --> Set <-- (Set)
        implements 2::""
        : (\.0);

The function C<unique::Set> simply results in its C<0> argument.  This
function implements the C<Homogeneous> virtual function C<unique> for the
composing type C<Set>.

=head2 subset_of (Set)

    ::MD::subset_of::Set ::= function --> Boolean <-- (Set, Set)
        implements 2::""
        : ((\.0->unwrap) subset_of (\.1->unwrap));

The function C<subset_of::Set> results in C<True> iff the set of members of
its C<0> argument is a subset of the set of members of its C<1> argument;
otherwise it results in C<False>.  This function implements the
C<Homogeneous> virtual function C<subset_of> aka C<⊆> for the composing
type C<Set>.

=head2 same_members (Set)

    ::MD::same_members::Set ::= function --> Boolean <-- (Set, Set)
        implements 2::""
        is commutative
        : (topic --> \@same);

The function C<same_members::Set> results in C<True> iff its 2 arguments
C<0> and C<1> are exactly the same C<Set> value, and C<False> otherwise;
its behaviour is identical to that of the function C<same> when given the
same arguments.  This function implements the C<Homogeneous> virtual
function C<same_members> for the composing type C<Set>.

=head2 overlaps_members (Set)

    ::MD::overlaps_members::Set ::= function --> Boolean <-- (Set, Set)
        implements 2::""
        is commutative
        : ((\.0->unwrap) overlaps_members (\.1->unwrap));

The function C<overlaps_members::Set> results in C<True> iff, given
I<X> as the set of members of its argument C<0> and I<Y> as the
set of members of its argument C<1>, there exists at least 1 member
that both I<X> and I<Y> have, and there also exists at least 1 other member
each of I<X> and I<Y> that the other doesn't have; otherwise it results in
C<False>.  This function implements the C<Homogeneous> virtual function
C<overlaps_members> for the composing type C<Set>.

=head2 disjoint_members (Set)

    ::MD::disjoint_members::Set ::= function --> Boolean <-- (Set, Set)
        implements 2::""
        is commutative
        : ((\.0->unwrap) disjoint_members (\.1->unwrap));

The function C<disjoint_members::Set> results in C<True> iff the
set of members of its C<0> argument has no member values in common
with the set of members of its C<1> argument; otherwise it results in
C<False>.  This function implements the C<Homogeneous> virtual function
C<disjoint_members> for the composing type C<Set>.

=head2 member_plus (Set)

    ::MD::member_plus::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        is {associative,commutative,idempotent} identity ({})
        : (topic --> \@union);

The function C<member_plus::Set> results in the I<set union> of its 2
arguments C<0> and C<1>; it behaves identically to C<union> aka C<∪> when
given the same arguments.  This function implements the C<Homogeneous>
virtual function C<member_plus> aka C<⊎> for the composing type C<Set>.

=head2 except (Set)

    ::MD::except::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        : (\Set wrap ((\.0->unwrap) except (\.1->unwrap)));

The function C<except::Set> results in the I<set difference> between
its 2 arguments C<0> (I<minuend>) and C<1> (I<subtrahend>).  The result is
the C<Set> value that has all of the members of the function's C<0>
argument minus all of the matching members of its C<1> argument.  This
function implements the C<Homogeneous> virtual function C<except> aka C<∖>
for the composing type C<Set>.

=head2 intersect (Set)

    ::MD::intersect::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        is {associative,commutative,idempotent}
        : (\Set wrap ((\.0->unwrap) intersect (\.1->unwrap)));

The function C<intersect::Set> results in the I<set intersection> of
its 2 arguments C<0> and C<1>.  The result is the C<Set> value that has all
of the members of the function's C<0> argument that match their own members
of its C<1> argument.  This function implements the C<Homogeneous> virtual
function C<intersect> aka C<∩> for the composing type C<Set>.

=head2 union (Set)

    ::MD::union::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        is {associative,commutative,idempotent} identity ({})
        : (\Set wrap ((\.0->unwrap) union (\.1->unwrap)));

The function C<union::Set> results in the I<set union> of its 2
arguments C<0> and C<1>.  The result is the C<Set> value that has all of
the members of the function's C<0> argument plus all of the nonmatching
members of its C<1> argument.  This function implements the C<Homogeneous>
virtual function C<union> aka C<∪> for the composing type C<Set>.

=head2 exclusive (Set)

    ::MD::exclusive::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        is {associative,commutative} identity ({})
        : (\Set wrap ((\.0->unwrap) exclusive (\.1->unwrap)));

The function C<exclusive::Set> results in the I<set symmetric
difference> of its 2 arguments C<0> and C<1>.  The result is the C<Set>
value that has all of the members of each of the function's C<0> and C<1>
arguments that do not have matching members of their counterpart argument. 
This function implements the C<Homogeneous> virtual function C<exclusive>
aka C<symm_diff> aka C<∆> for the composing type C<Set>.

=head2 nest (Set)

    ::MD::nest::Set ::= function --> Set <-- (Set)
        implements 2::""
        requires (...)
        : (\Set wrap (\.0->unwrap->nest));

I<TODO.>

=head2 unnest (Set)

    ::MD::unnest::Set ::= function --> Set <-- (Set)
        implements 2::""
        requires (...)
        : (\Set wrap (\.0->unwrap->unnest));

I<TODO.>

=head2 any (Set)

    ::MD::any::Set ::= function --> Boolean <-- (Set, Primed_Func_Ref)
        implements 2::""
        : (\.0->unwrap any \.1);

I<TODO.>

=head2 where (Set)

    ::MD::where::Set ::= function --> Set <-- (Set, Primed_Func_Ref)
        implements 2::""
        : (\Set wrap (\.0->unwrap where \.1));

I<TODO.>

=head2 map (Set)

    ::MD::map::Set ::= function --> Set <-- (Set, Primed_Func_Ref)
        implements 2::""
        : (\Set wrap (\.0->unwrap map \.1));

I<TODO.>

=head2 reduce (Set)

    ::MD::reduce::Set ::= function --> Any <-- (Set, Primed_Func_Ref)
        implements 2::""
        : (\Set wrap (\.0->unwrap reduce \.1));

I<TODO.>

=head2 to_Set (Set)

    ::MD::to_Set::Set ::= function --> Set <-- (Set)
        implements 2::""
        : (\.0);

The function C<to_Set::Set> simply results in its C<0> argument.  This
function implements the C<Discrete> virtual function C<to_Set> aka
C<< ?< >> for the composing type C<Set>.

=head2 to_Bag (Set)

    ::MD::to_Bag::Set ::= function --> Bag <-- (Set)
        implements 2::""
        : (\.0->unwrap);

The function C<to_Bag::Set> results in the C<Bag> value that has all of the
members of the function's C<0> argument.  This function implements the
C<Discrete> virtual function C<to_Bag> aka C<< +< >> for the composing type
C<Set>.

=head2 count (Set)

    ::MD::count::Set ::= function --> Integer_NN <-- (Set)
        implements 2::""
        : (\.0->unwrap->count);

The function C<count::Set> results in the integral count of the members
of its C<0> argument.  This function implements the C<Discrete> virtual
function C<count> aka C<cardinality> aka C<#> for the composing type C<Set>.

=head2 unique_count (Set)

    ::MD::unique_count::Set ::= function --> Integer_NN <-- (Set)
        implements 2::""
        : (\.0->count);

The function C<unique_count::Set> results in the integral count of the
members of its C<0> argument; its behavior is identical to C<count> given
the same argument.  This function implements the C<Discrete> virtual
function C<unique_count> for the composing type C<Set>.

=head1 BAG DATA TYPES

=head2 Bag

    ::MD::Bag ::= selection where (topic -->^ FDN__is_a_Bag)
        default (\+{})
        composes Discrete;

The selection contract C<Bag> represents the infinite Muldis D Foundation
type I<FDN__Bag>.  A C<Bag> value is a general purpose arbitrarily-large
unordered collection of any other, I<member> values, which explicitly does
not represent any kind of thing in particular, and is simply the sum of its
members.  A C<Bag> in the general case may have multiple members that are
the same value.  The default value of C<Bag> is C<\+{}>, the only
zero-member C<Bag> value.  Other programming languages may name their
corresponding types I<Multiset>.

=head2 empty_Bag +∅

    ::MD::empty_Bag ::= constant (\+{});

    ::MD::Unicode_Aliases::"+∅" ::= alias of empty_Bag;

The constant C<empty_Bag> aka C<+∅> represents the only zero-member
C<Bag> value, C<\+{}>.

=head2 so (Bag)

    ::MD::so::Bag ::= function --> Boolean <-- (Bag)
        implements 2::""
        : (\.0 != \+{});

The function C<so::Bag> results in C<True> iff its C<0> argument has any
members, and in C<False> iff it has no members.  This function implements
the C<Boolable> virtual function C<so> aka C<?> aka C<to_Boolean> for the
composing type C<Bag>.

=head2 empty (Bag)

    ::MD::empty::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        : (\+{});

The function C<empty::Bag> results in the only zero-member C<Bag>
value.  This function implements the C<Emptyable> virtual function C<empty>
aka C<∅> for the composing type C<Bag>.

=head2 has_n (Bag)

    ::MD::has_n::Bag ::= function --> Boolean <-- (Bag, Any, Integer_NN)
        implements 2::""
        : (topic -->^ FDN__Bag_has_n);

The function C<has_n::Bag> results in C<True> iff its C<0> argument has at
least N members such that each is equal to its C<1> argument, where N is
defined by its C<2> argument; otherwise it results in C<False>.  This
function implements the C<Homogeneous> virtual function C<has_n> for the
composing type C<Bag>.

=head2 multiplicity (Bag)

    ::MD::multiplicity::Bag ::= function --> Integer_NN <-- (Bag, Any)
        implements 2::""
        : (topic -->^ FDN__Bag_multiplicity);

The function C<multiplicity::Bag> results in the integral count
of members of its C<0> argument such that each member value is equal to its
C<1> argument.  This function implements the C<Homogeneous> virtual
function C<multiplicity> for the composing type C<Bag>.

=head2 insert_n (Bag)

    ::MD::insert_n::Bag ::= function --> Bag <-- (Bag, Any, Integer_NN)
        implements 2::""
        : (topic -->^ FDN__Bag_insert_n);

The function C<insert_n::Bag> results in the C<Bag> value that has all of
the members of the function's C<0> argument plus N additional members that
are each equal to its C<1> argument, where N is defined by its C<2>
argument.  This function implements the C<Homogeneous> virtual function
C<insert_n> for the composing type C<Bag>.

=head2 remove_n (Bag)

    ::MD::remove_n::Bag ::= function --> Bag <-- (Bag, Any, Integer_NN)
        implements 2::""
        : (topic -->^ FDN__Bag_remove_n);

The function C<remove_n::Bag> results in the C<Bag> value that has all of
the members of the function's C<0> argument minus N existing members that
are each equal to its C<1> argument, where N is defined as the lesser of
its C<2> argument and the count of members of C<0> equal to the C<1>
argument.  This function implements the C<Homogeneous> virtual function
C<remove_n> for the composing type C<Bag>.

=head2 all_unique (Bag)

    ::MD::all_unique::Bag ::= function --> Boolean <-- (Bag)
        implements 2::""
        : (topic -->^ FDN__Bag_all_unique);

The function C<all_unique::Bag> results in C<True> iff its C<0> argument
has no 2 members that are the same value, and C<False> otherwise.  This
function implements the C<Homogeneous> virtual function C<all_unique> for
the composing type C<Bag>.

=head2 unique (Bag)

    ::MD::unique::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        : (topic -->^ FDN__Bag_unique);

The function C<unique::Bag> results in the C<Bag> value that has, for every
distinct member value I<V> of the function's C<0> argument, exactly 1
member whose value is equal to I<V>.  This function implements the
C<Homogeneous> virtual function C<unique> for the composing type C<Bag>.

=head2 subset_of (Bag)

    ::MD::subset_of::Bag ::= function --> Boolean <-- (Bag, Bag)
        implements 2::""
        : (topic -->^ FDN__Bag_subset_of);

The function C<subset_of::Bag> results in C<True> iff the multiset of
members of its C<0> argument is a subset of the multiset of members of its
C<1> argument; otherwise it results in C<False>.  This function implements
the C<Homogeneous> virtual function C<subset_of> aka C<⊆> for the composing
type C<Bag>.

=head2 same_members (Bag)

    ::MD::same_members::Bag ::= function --> Boolean <-- (Bag, Bag)
        implements 2::""
        is commutative
        : (topic --> \@same);

The function C<same_members::Bag> results in C<True> iff its 2 arguments
C<0> and C<1> are exactly the same C<Bag> value, and C<False> otherwise;
its behaviour is identical to that of the function C<same> when given the
same arguments.  This function implements the C<Homogeneous> virtual
function C<same_members> for the composing type C<Bag>.

=head2 overlaps_members (Bag)

    ::MD::overlaps_members::Bag ::= function --> Boolean <-- (Bag, Bag)
        implements 2::""
        is commutative
        : (topic -->^ FDN__Bag_overlaps_members);

The function C<overlaps_members::Bag> results in C<True> iff, given
I<X> as the multiset of members of its argument C<0> and I<Y> as the
multiset of members of its argument C<1>, there exists at least 1 member
that both I<X> and I<Y> have, and there also exists at least 1 other member
each of I<X> and I<Y> that the other doesn't have; otherwise it results in
C<False>.  This function implements the C<Homogeneous> virtual function
C<overlaps_members> for the composing type C<Bag>.

=head2 disjoint_members (Bag)

    ::MD::disjoint_members::Bag ::= function --> Boolean <-- (Bag, Bag)
        implements 2::""
        is commutative
        : (topic -->^ FDN__Bag_disjoint_members);

The function C<disjoint_members::Bag> results in C<True> iff the
multiset of members of its C<0> argument has no member values in common
with the multiset of members of its C<1> argument; otherwise it results in
C<False>.  This function implements the C<Homogeneous> virtual function
C<disjoint_members> for the composing type C<Bag>.

=head2 member_plus (Bag)

    ::MD::member_plus::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        is {associative,commutative} identity (\+{})
        : (topic -->^ FDN__Bag_member_plus);

The function C<member_plus::Bag> results in the I<multiset sum> of its 2
arguments C<0> and C<1>.  The result is the C<Bag> value that has all of
the members of the function's C<0> argument plus all of the members of its
C<1> argument.  This function implements the C<Homogeneous> virtual
function C<member_plus> aka C<⊎> for the composing type C<Bag>.

=head2 except (Bag)

    ::MD::except::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        : (topic -->^ FDN__Bag_except);

The function C<except::Bag> results in the I<multiset difference> between
its 2 arguments C<0> (I<minuend>) and C<1> (I<subtrahend>).  The result is
the C<Bag> value that has all of the members of the function's C<0>
argument minus all of the matching members of its C<1> argument.  This
function implements the C<Homogeneous> virtual function C<except> aka C<∖>
for the composing type C<Bag>.

=head2 intersect (Bag)

    ::MD::intersect::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        is {associative,commutative,idempotent}
        : (topic -->^ FDN__Bag_intersect);

The function C<intersect::Bag> results in the I<multiset intersection> of
its 2 arguments C<0> and C<1>.  The result is the C<Bag> value that has all
of the members of the function's C<0> argument that match their own members
of its C<1> argument.  This function implements the C<Homogeneous> virtual
function C<intersect> aka C<∩> for the composing type C<Bag>.

=head2 union (Bag)

    ::MD::union::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        is {associative,commutative,idempotent} identity (\+{})
        : (topic -->^ FDN__Bag_union);

The function C<union::Bag> results in the I<multiset union> of its 2
arguments C<0> and C<1>.  The result is the C<Bag> value that has all of
the members of the function's C<0> argument plus all of the nonmatching
members of its C<1> argument.  This function implements the C<Homogeneous>
virtual function C<union> aka C<∪> for the composing type C<Bag>.

=head2 exclusive (Bag)

    ::MD::exclusive::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        is {associative,commutative} identity (\+{})
        : (topic -->^ FDN__Bag_exclusive);

The function C<exclusive::Bag> results in the I<multiset symmetric
difference> of its 2 arguments C<0> and C<1>.  The result is the C<Bag>
value that has all of the members of each of the function's C<0> and C<1>
arguments that do not have matching members of their counterpart argument. 
This function implements the C<Homogeneous> virtual function C<exclusive>
aka C<symm_diff> aka C<∆> for the composing type C<Bag>.

=head2 nest (Bag)

    ::MD::nest::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Bag_nest);

I<TODO.>

=head2 unnest (Bag)

    ::MD::unnest::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Bag_unnest);

I<TODO.>

=head2 any (Bag)

    ::MD::any::Bag ::= function --> Boolean <-- (Bag, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Bag_any);

I<TODO.>

=head2 where (Bag)

    ::MD::where::Bag ::= function --> Bag <-- (Bag, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Bag_where);

I<TODO.>

=head2 map (Bag)

    ::MD::map::Bag ::= function --> Bag <-- (Bag, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Bag_map);

I<TODO.>

=head2 reduce (Bag)

    ::MD::reduce::Bag ::= function --> Any <-- (Bag, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Bag_reduce);

I<TODO.>

=head2 to_Set (Bag)

    ::MD::to_Set::Bag ::= function --> Set <-- (Bag)
        implements 2::""
        : (\Set wrap (\.0->unique));

The function C<to_Set::Bag> results in the C<Set> value that has, for every
distinct member value I<V> of the function's C<0> argument, exactly 1
member whose value is equal to I<V>.  This function implements the
C<Discrete> virtual function C<to_Set> aka C<< ?< >> for the composing type
C<Bag>.

=head2 to_Bag (Bag)

    ::MD::to_Bag::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        : (\.0);

The function C<to_Bag::Bag> simply results in its C<0> argument.  This
function implements the C<Discrete> virtual function C<to_Bag> aka
C<< +< >> for the composing type C<Bag>.

=head2 count (Bag)

    ::MD::count::Bag ::= function --> Integer_NN <-- (Bag)
        implements 2::""
        : (topic -->^ FDN__Bag_count);

The function C<count::Bag> results in the integral count of the members
of its C<0> argument.  This function implements the C<Discrete> virtual
function C<count> aka C<cardinality> aka C<#> for the composing type C<Bag>.

=head2 unique_count (Bag)

    ::MD::unique_count::Bag ::= function --> Integer_NN <-- (Bag)
        implements 2::""
        : (topic -->^ FDN__Bag_unique_count);

The function C<unique_count::Bag> results in the integral count of the
distinct member values of its C<0> argument.  This function implements the
C<Discrete> virtual function C<unique_count> for the composing type C<Bag>.

=head1 ATTRIBUTIVE DATA TYPES

=head2 Attributive

    ::MD::Attributive ::= interface
        requires_implements {has_any_attrs,degree,on,but,extend,rename,has_attrs,has_just_attrs};

I<TODO.  For types that support attribute-name-based lookup of values;
for collections of name-value pairs where all names are distinct;
for typically heterogeneous collections.
Composed by: Tuple, Relation, Tuple_Bag.>

=head2 Excuse::No_Such_Attr_Name

    ::MD::Excuse::No_Such_Attr_Name ::= constant (\@0) composes Excuse;

I<TODO.>

=head2 has_any_attrs ?^

    ::MD::has_any_attrs::"" ::= function virtual --> Boolean <-- (Attributive);

    ::MD::"?^" ::= alias of has_any_attrs;

I<TODO.>

=head2 is_nullary !?^

    ::MD::is_nullary ::= function negates has_any_attrs;

    ::MD::"!?^" ::= alias of is_nullary;

I<TODO.>

=head2 degree #^

    ::MD::degree::"" ::= function virtual --> Integer_NN <-- (Attributive);

    ::MD::"#^" ::= alias of degree;

I<TODO.>

=head2 on ^ project

    ::MD::on::"" ::= function virtual
        --> Attributive <-- (Attributive, Attr_Names)
        requires (...);

    ::MD::"^"     ::= alias of on;
    ::MD::project ::= alias of on;

I<TODO.  Also, this is analogous to set intersect.>

=head2 from

    ::MD::from ::= function commutes on;

I<TODO.>

=head2 but -^ project_all_but

    ::MD::but::"" ::= function virtual
        --> Attributive <-- (Attributive, Attr_Names)
        requires (...);

    ::MD::"-^"            ::= alias of but;
    ::MD::project_all_but ::= alias of but;

I<TODO.  Also, this is analogous to set difference.>

=head2 extend +^

    ::MD::extend::"" ::= function virtual
        --> Attributive <-- (Attributive, Attributive)
        requires (topic --> \@attr_names_disjoint)
        is {associative,commutative};

    ::MD::"+^" ::= alias of extend;

I<TODO.  Also, this is analogous to set union (disjoint).>

I<Note: There is no version of 'extend' that takes a routine; one can just
use the above version plus an eg-tuple selector. In the case of relation
extend, one can do the aforementioned within a 'map' routine, for the
routine version; they can use join/cross-product for the static version.>

=head2 rename

    ::MD::rename::"" ::= function virtual
        --> Attributive <-- (Attributive, Attr_Renaming)
        requires (...);

I<TODO.>

=head2 renaming

    ::MD::renaming ::= function commutes rename;

I<TODO.>

=head2 attr_names_disjoint

    ::MD::attr_names_disjoint ::= function
        --> Boolean <-- (Attributive, Attributive)
        is commutative
        : (...);

I<TODO.>

=head2 has_attrs ^?

    ::MD::has_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, Signature);

    ::MD::"^?" ::= alias of has_attrs;

I<TODO.>

=head2 has_just_attrs ^?=

    ::MD::has_just_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, Signature);

    ::MD::"^?=" ::= alias of has_just_attrs;

I<TODO.>

=head1 TUPLE DATA TYPES

=head2 Tuple

    ::MD::Tuple ::= selection where (topic -->^ FDN__is_a_Tuple)
        default (\%())
        composes {Accessible and_provides_its_default,
            Attributive and_provides_its_default};

The selection contract C<Tuple> represents the infinite
Muldis D Foundation type I<FDN__Tuple>.  A C<Tuple> value is ...

I<TODO.>

=head2 Tuple_D0 D0

    ::MD::Tuple_D0 ::= constant (\%());

    ::MD::D0 ::= alias of Tuple_D0;

The constant C<Tuple_D0> aka C<D0> represents the only zero-attribute
C<Tuple> value.

=head2 has_any_attrs (Tuple)

    ::MD::has_any_attrs::Tuple ::= function --> Boolean <-- (Tuple)
        implements 2::""
        : (\.0 != \%());

I<TODO.>

=head2 degree (Tuple)

    ::MD::degree::Tuple ::= function --> Integer_NN <-- (Tuple)
        implements 2::""
        : (topic -->^ FDN__Tuple_degree);

I<TODO.>

=head2 attr . (Tuple)

    ::MD::attr ::= function --> Any <-- (Tuple, Attr_Name)
        requires (topic --> \@has_attr_name)
        : (topic -->^ FDN__Tuple_attr);

    ::MD::"."::Tuple ::= function --> Any <-- (Tuple, Attr_Name)
        implements 2::""
        requires (topic --> \@has_attr_name)
        : (topic --> \@attr);

I<TODO.>

=head2 has_attr_name .? (Tuple)

    ::MD::has_attr_name ::= function --> Boolean <-- (Tuple, Attr_Name)
        : (topic -->^ FDN__Tuple_has_attr_name);

    ::MD::".?"::Tuple ::= function --> Boolean <-- (Tuple, Attr_Name)
        implements 2::""
        : (topic --> \@has_attr_name);

I<TODO.>

=head2 attr_or_excuse .! (Tuple)

    ::MD::attr_or_excuse ::= function --> Any <-- (Tuple, Attr_Name)
        : (topic --> \@has_attr_name ?? topic --> \@attr !! Excuse::No_Such_Attr_Name());

    ::MD::".!"::Tuple ::= function --> Any <-- (Tuple, Attr_Name)
        implements 2::""
        : (topic --> \@attr_or_excuse);

I<TODO.>

=head2 on (Tuple)

    ::MD::on::Tuple ::= function --> Tuple <-- (Tuple, Attr_Names)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Tuple_on);

I<TODO.>

=head2 but (Tuple)

    ::MD::but::Tuple ::= function --> Tuple <-- (Tuple, Attr_Names)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Tuple_but);

I<TODO.>

=head2 extend (Tuple)

    ::MD::extend::Tuple ::= function --> Tuple <-- (Tuple, Tuple)
        implements 2::""
        requires (topic --> \@attr_names_disjoint)
        is {associative,commutative} identity (\%())
        : (topic -->^ FDN__Tuple_extend);

I<TODO.>

=head2 rename (Tuple)

    ::MD::rename::Tuple ::= function --> Tuple <-- (Tuple, Attr_Renaming)
        implements 2::""
        requires (...)
        : (...);

I<TODO.>

=head2 has_attrs (Tuple)

    ::MD::has_attrs::Tuple ::= function --> Boolean <-- (Tuple, Signature)
        implements 2::""
        : (...);

I<TODO.>

=head2 has_just_attrs (Tuple)

    ::MD::has_just_attrs::Tuple ::= function --> Boolean <-- (Tuple, Signature)
        implements 2::""
        : (...);

I<TODO.>

=head2 any_attrs

    ::MD::any_attrs ::= function --> Boolean <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_any_attrs);

I<TODO.>

=head2 none_of_attrs

    ::MD::none_of_attrs ::= function negates any_attrs;

I<TODO.>

=head2 all_attrs

    ::MD::all_attrs ::= function --> Boolean <-- (Tuple, Primed_Func_Ref)
        : (\.0 none_of_attrs negated_func(of : \.1, passing_args : \@(0)));

I<TODO.>

=head2 attrs_where

    ::MD::attrs_where ::= function --> Tuple <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_attrs_where);

I<TODO.>

=head2 attrs_map

    ::MD::attrs_map ::= function --> Tuple <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_attrs_map);

I<TODO.>

=head2 attrs_reduce

    ::MD::attrs_reduce ::= function --> Any <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_attrs_reduce);

I<TODO.>

=head1 RELATIONAL DATA TYPES

=head2 Relational

    ::MD::Relational ::= interface
        composes {Homogeneous, Attributive}
        requires_implements {...};

I<TODO.>

=head1 RELATION DATA TYPES

=head2 Relation

    ::MD::Relation ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped( topic, \Relation, \@1::_Asset ))
            default (\?%())
            composes {Relational, Setty};

        _Asset ::= selection of Tuple_Bag
            where (all_unique topic);
    };

I<TODO.  See also definition of Set in terms of Bag, which Relation mirrors.>

=head2 Relation_D0C0 D0C0

    ::MD::Relation_D0C0 ::= constant (\?%());

    ::MD::D0C0 ::= alias of Relation_D0C0;

The constant C<Relation_D0C0> aka C<D0C0> represents the only
zero-attribute, zero-tuple C<Relation> value.  Note that I<The Third
Manifesto> also refers to this value by the special name I<TABLE_DUM>.

=head2 Relation_D0C1 D0C1

    ::MD::Relation_D0C1 ::= constant (\?%{()});

    ::MD::D0C1 ::= alias of Relation_D0C1;

The constant C<Relation_D0C1> aka C<D0C1> represents the only
zero-attribute, single-tuple C<Relation> value.  Note that I<The Third
Manifesto> also refers to this value by the special name I<TABLE_DEE>.

=head1 TUPLE-BAG DATA TYPES

=head2 Tuple_Bag

    ::MD::Tuple_Bag ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped( topic, \Tuple_Bag, \@1::_Asset ))
            default (\+%())
            composes Relational;

        _Asset ::= selection of Tuple where
        (
            if topic ^?= \%( heading : \@Attr_Names, body : \@Bag ) then
                if \.body all_is_a \@Tuple then
                    \.body all (\@"^?=" assuming \.heading)
                else
                    False
            else
                False
        );
    };

I<TODO.>

=head2 Tuple_Bag_D0C0

    ::MD::Tuple_Bag_D0C0 ::= constant (\+%());

The constant C<Tuple_Bag_D0C0> represents the only zero-attribute,
zero-tuple C<Tuple_Bag> value.

=head2 Tuple_Bag_D0C1

    ::MD::Tuple_Bag_D0C1 ::= constant (\+%{()});

The constant C<Tuple_Bag_D0C1> represents the only zero-attribute,
single-tuple C<Tuple_Bag> value.

=head1 INTERVAL DATA TYPES

=head2 Interval

    ::MD::Interval ::= selection ...
        composes Homogeneous
        ...;

I<TODO.>

=head1 QUANTITY DATA TYPES

=head2 Quantity

    ::MD::Quantity ::= selection ...
        composes Numerical
        ...;

I<TODO.>

=head1 CAPSULE DATA TYPES

=head2 Capsule

    ::MD::Capsule::"" ::= selection where (topic -->^ FDN__is_a_Capsule)
        default (False wrap False);

The selection contract C<Capsule> represents the infinite Muldis D
Foundation type I<FDN__Capsule>.  An C<Capsule> value is ...

I<TODO.  Candidate literal syntax is `\:(wrapper,asset)`.>

Given that almost every selection contract is a subset of
C<Capsule>, the latter intentionally does not compose any interface
contracts, and only has the minimal set of its own operators, so to
minimize interference with other types' interfaces.

=head2 Capsule::wrap

    ::MD::Capsule::wrap ::= function --> Capsule <-- (Any, Any)
        : (topic -->^ FDN__Capsule_wrap);

I<TODO.>

=head2 Capsule::wrapper

    ::MD::Capsule::wrapper ::= function --> Any <-- (Capsule)
        : (topic -->^ FDN__Capsule_wrapper);

I<TODO.>

=head2 Capsule::unwrap

    ::MD::Capsule::unwrap ::= function --> Any <-- (Capsule)
        : (topic -->^ FDN__Capsule_unwrap);

I<TODO.>

=head2 Capsule::has_wrapped

    ::MD::Capsule::has_wrapped ::= function
        --> Boolean <-- (Capsule, Any, Reference)
        : (wrapper(\.0) = \.1 and unwrap(\.0) --> \.2);

I<TODO.>

=head1 EXTERNAL DATA TYPES

=head2 External

    ::MD::External::"" ::= selection where (topic -->^ FDN__is_a_External)
        default (-->^ FDN__default_External);

The selection contract C<External> represents the infinite Muldis D
Foundation type I<FDN__External>.  An C<External> value is an opaque and
transient reference to an entity that is defined and managed externally to
the Muldis D language environment, either internally to the Muldis D host
implementation or in some peer language that it mediates.  Its default
value is implementation-defined.

As C<External> values are black boxes to Muldis D, it is the responsibility
of their external manager to at the very least implement the C<same>
function for them in a fully deterministic manner, as well as externally
define any other operators for them that users may wish to invoke for those
values from Muldis D code, including any to map with or marshal with Muldis
D values.

=head2 External::call_function

    ::MD::External::call_function ::= function --> Any <-- Any
        : (FDN__External_call_function ^<-- topic);

The function C<External::call_function> is a proxy for invoking a function
that is defined and managed externally to the Muldis D language
environment.  Muldis D will assume said function is completely
deterministic, and there would likely be problems if it isn't.  Using
C<External::call_function> as a foundation, it is possible to define an
arbitrarily complex type graph involving C<External> values.

=head1 SOURCE CODE BEHAVIOURAL DATA TYPES

I<TODO.>

=head2 Source_Code::Package_List

    ::MD::Source_Code::Package_List ::= selection of Array
        where (topic all_is_a (selection of {Package, Decoration} default Package()));

I<TODO.>

=head2 Source_Code::Package

    ::MD::Source_Code::Package ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped( topic, \Package, \@1::_Asset ))
            default (\Package wrap 1::_Asset());

        _Asset ::= selection of Tuple where
        (
            if
                topic ^?= \%(
                    identity : (selection of Pkg_Decl_Map where (degree(topic) = 1)),
                    foundation : ...,
                    uses : \@Pkg_Decl_Map,
                    floating : ...,
                    materials : ...,
                    annotation : ...,
                    decoration : ...,
                )
            then
                topic.\uses attr_names_disjoint topic.\identity
            else
                False
        );
    };

I<TODO.>

=head2 Source_Code::Pkg_Decl_Map

    ::MD::Source_Code::Pkg_Decl_Map ::= selection of Tuple
        where (topic all_attrs (function : (\.asset --> \@Pkg_Canon_Name)));

I<TODO.>

=head2 Source_Code::negated_func

    ::MD::Source_Code::negated_func ::= function --> Primed_Func_Ref
        <-- (of : Primed_Func_Ref, passing_args : Attr_Names)
    : (
        (function : (
            not(
                (\.of.\args +^ (topic ^ \.passing_args)) --> (\.of.\func)
            )
        )) assuming topic
    );

I<TODO.  This expects the original function is from Tuple to Boolean.>

=head1 SOURCE CODE ANNOTATION DATA TYPES

I<TODO.>

=head2 Source_Code::Annotation

    ::MD::Source_Code::Annotation::"" ::= interface;

I<TODO.>

=head1 SOURCE CODE DECORATION DATA TYPES

I<TODO.  Generally speaking, all Decoraction types are declared by a
package that is not Core, such as in some Core::Plain_Text/etc package.>

I<TODO:  The decoration data types may loosely resemble template defs so
that decorations don't necessarily have to be attached to all
behavioral/annotation nodes they are conceptually adjacent / apply to but
rather can be in some nearby parent context and refer to behavioral/etc
nodes by name.>

=head2 Source_Code::Decoration

    ::MD::Source_Code::Decoration::"" ::= interface;

I<TODO.>

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::See_Also> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the B<Muldis D Standard
Library> (B<MDSL>) primary component of the B<Muldis D> language
specification.  MDSL substantially comprises executable code as well.

MDSL is Copyright © 2002-2016, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D::Standard_Library> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
