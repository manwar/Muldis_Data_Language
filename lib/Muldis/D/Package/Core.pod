=pod

=encoding utf8

=head1 NAME

Muldis::D::Package::Core -
Muldis D core data types and operators

=head1 VERSION

This document is Muldis::D::Package::Core version 0.201.0.-9.

=head1 SYNOPSIS

    Muldis_D:Plain_Text:"http://muldis.com":"0.201.0.-9";
    script Unicode:8.0:UTF-8;
    package
    {
        identity My_App ::= My_App:"http://mycorp.com":"0";
        foundation "http://muldis.com":"0.201.0.-9";
        uses
        {
            MD ::= Core:"http://muldis.com":"0.201.0.-9";
        };
        entry ::My_App::main;
        floating {::My_App, ::MD, ::MD::Unicode_Aliases};
        `TODO: Put example routines etc here, one is a procedure named "main".`
    };

=head1 DESCRIPTION

This document defines the Muldis D package
C<Core:"http://muldis.com":"0.201.0.-9"> which provides the common core
system-defined data types and operators that regular users of the language
would employ directly in their applications and schemas.

See also L<Muldis::D::Standard_Library> to read about the B<Muldis D
Standard Library> specification, of which this document is a part.

=head1 PACKAGE

    Muldis_D:Plain_Text:"http://muldis.com":"0.201.0.-9";
    script Unicode:8.0:UTF-8;
    package
    {
        identity MD ::= Core:"http://muldis.com":"0.201.0.-9";
        foundation "http://muldis.com":"0.201.0.-9";
        floating {::MD, ::MD::Round_Meth, ::MD::Capsule, ::MD::Source_Code};
        ...
    };

=head1 MAXIMAL AND MINIMAL DATA TYPES

=head2 Any

    ::MD::Any ::= selection default (False);

The selection contract C<Any> represents the infinite
I<universal type>, which is the maximal data type of the entire Muldis D
type system and consists of all values which can possibly exist.  It also
represents the infinite Muldis D Foundation type I<FDN__Any>.  Its
default value is C<False>.  Other programming languages may name their
corresponding types I<Object> or I<Universal>.

=head2 None

    ::MD::None ::= selection of {};

The selection contract C<None> represents the finite I<empty type>,
which is the minimal data type of the entire Muldis D type system and
consists of exactly zero values.  It can not have any default value.

=head2 same =

    ::MD::same ::= function --> Boolean <-- (Any, Any)
        is commutative
        : (\<*args -->^ FDN__same);

    ::MD::"=" ::= alias of same;

The function C<same> aka C<=> results in C<True> iff its 2 arguments C<0>
and C<1> are exactly the same value, and C<False> otherwise.  Other
programming languages may name their corresponding operators I<==> or
I<===> or I<eq>.

Note that C<same> is guaranteed to result in C<False> when exactly one of
its 2 arguments is an C<External> value but beyond that its behavior when
both of its arguments are C<External> values is implementation defined, in
that implementations are expected to make it completely deterministic
according to appropriate rules of value distinctness for the external
environment in question; for example, if the external entity referenced by
an C<External> value is considered a mutable container, then 2 C<External>
should only be considered I<same> if they both point to the same container,
and not if two distinct containers have the same content.

=head2 not_same != ≠

    ::MD::not_same ::= function negates same
        is commutative;

    ::MD::"!=" ::= alias of not_same;

    ::MD::Unicode_Aliases::"≠" ::= alias of not_same;

The function C<not_same> aka C<!=> aka C<≠> results in C<False> iff its 2
arguments C<0> and C<1> are exactly the same value, and C<True> otherwise.
Other programming languages may name their corresponding operators
I<< <> >> or I<!===> or or I<~=> or I<^=> or I<ne> or I</=> or I<=/=>
or I<=\=>.

=head2 is_a

    ::MD::is_a ::= function --> Boolean <-- (Any, Contract_Name)
        : ((\<0,) --> (\Function_Call wrap (func: \<1, args: ())));

The function C<is_a> results in C<True> iff its C<0> argument is a
member of the type specified by its C<1> argument, and C<False> otherwise.
Note that C<v is_a \@T> is more idiomatically written C<T::(v)>.

=head2 not_is_a

    ::MD::not_is_a ::= function negates is_a;

The function C<not_is_a> results in C<False> iff its C<0> argument is a
member of the type specified by its C<1> argument, and C<True> otherwise.
Note that C<v not_is_a \@T> is more idiomatically written C<!T::(v)>.

=head2 default

    ::MD::default ::= function --> Any <-- (Contract_Name)
        : (() --> (\Function_Call wrap (func: \<0, args: ())));

The function C<default> results in the default value of the not-empty type
specified by its C<0> argument.
Note that C<default \@T> is more idiomatically written C<T::()>.

=head1 EXCUSE DATA TYPES

=head2 Excuse

    ::MD::Excuse::"" ::= interface;

The semantic contract C<Excuse> is infinite.  An C<Excuse> value is an
explicitly stated reason for why, given some particular problem domain, a
value is not being used that is ordinary for that domain.  For example, the
typical integer division operation is not defined to give an integer result
when the divisor is zero, and so a Muldis D function for integer division
could be defined to result in an C<Excuse> value rather than throw an
exception in that case.  For another example, an C<Excuse> value could be
used to declare that the information we are storing about a person is
missing certain details and why those are missing, such as because the
person left the birthdate field blank on their application form.  Its
default value is C<Excuse::No_Reason>.  An C<Excuse> is isomorphic to an
C<Exception> but that use of the former is not meant to terminate execution
of code early unlike the latter which is.  Other programming languages that
have typed exceptions are analogous.

=head2 Excuse::No_Reason

    ::MD::Excuse::No_Reason ::= constant
        composes Excuse and_provides_its_default;

The constant C<Excuse::No_Reason> represents the C<Excuse> value which
simply says that an ordinary value for any given domain is missing and that
there is simply no excuse that has been given for this; in other words,
something has gone wrong without the slightest hint of an explanation.
This is conceptually the most generic C<Excuse> value there is and it can
be used by lazy programmers as a fallback for when they don't have even a
semblance of a better explanation for why an ordinary value is missing.
Other programming languages may name their corresponding values or
quasi-values I<null> or I<nil> or I<none> or I<nothing> or I<undef> or
I<unknown>; but unlike some of those languages, C<No_Reason> equals itself.

=head2 or_else coalesce

    ::MD::or_else ::= function --> Any <-- (Any, Any)
        is {associative,idempotent}
        : (Excuse \<0 ?? \<1 !! \<0);

    ::MD::coalesce ::= alias of or_else;

The function C<or_else> aka C<coalesce> results in its C<0>
argument iff the latter is not an C<Excuse>, and results in its C<1>
argument otherwise.  This function is designed to be chained for any number
of sequenced values in order to pick the first non-C<Excuse> in a list.
Other programming languages may name their corresponding operators
I<??> or I<//> or I<?:>.

=head2 and_then

    ::MD::and_then ::= function --> Any <-- (Any, Any)
        is {associative,idempotent}
        : (Excuse \<0 ?? \<0 !! \<1);

The function C<and_then> results in its C<0> argument iff the latter is an
C<Excuse>, and results in its C<1> argument otherwise.  This function is
designed to be chained for any number of sequenced values in order to pick
the first C<Excuse> in a list.

=head1 ORDERABLE DATA TYPES

=head2 Orderable

    ::MD::Orderable ::= interface
        requires_implements in_order;

The interface contract C<Orderable> is infinite.  An C<Orderable> value has
all of the traditional comparison operators defined for it such that values
of its type I<T> can be deterministically sorted by Muldis D into a
canonical total order.  But I<T> otherwise does not necessarily have
conceptually a total order in the normal sense or that order is different
than what the provided comparison operators give you.  An C<Orderable> type
is a type for which one can take all of its values and place them on a line
such that each value is definitively considered I<before> all of the values
one one side and I<after> all of the values on the other side.  Other
programming languages may name their corresponding types I<IComparable> or
I<Ord> or I<ordered> or I<ordinal>.

The default value of C<Orderable> is the C<Integer> value C<0>.  The
minimum and maximum values of C<Orderable> are C<Neg_Inf> and C<Pos_Inf>,
respectively; these 2 C<Excuse> values are canonically considered to be
before and after, respectively, I<every> other value of the Muldis D type
system, regardless of whether those values are members a type for which an
C<Orderable>-composing contract exists.  The primary reason for having
these values C<Neg_Inf> and C<Pos_Inf> is so Muldis D has an easy
consistent way to define an C<Interval> that is partially or completely
unbounded, and to use as identity values for chained order-comparisons.

C<Orderable> is composed, directly or indirectly, by: C<Neg_Inf>,
C<Pos_Inf>, C<Bicessable>, C<Boolean>, C<Integral>, C<Integer>,
C<Fractional>, C<Fraction>, C<Stringy>, C<Bits>, C<Blob>, C<Textual>,
C<Text>, C<Positional>, C<Array>, C<String>, C<Tuple_Array>.

=head2 Neg_Inf -∞

    ::MD::Neg_Inf ::= constant composes {Orderable, Excuse};

    ::MD::Unicode_Aliases::"-∞" ::= alias of Neg_Inf;

The constant C<Neg_Inf> aka C<-∞> represents the type-agnostic concept of
negative infinity, an C<Orderable> value that sorts I<before> all other
values in the Muldis D type system.  This value is also an C<Excuse> that
says the result of some operation is infinite in the negative direction.
Note that IEEE floating-point standards define a negative infinity value.

=head2 Pos_Inf +∞

    ::MD::Pos_Inf ::= constant composes {Orderable, Excuse};

    ::MD::Unicode_Aliases::"+∞" ::= alias of Pos_Inf;

The constant C<Pos_Inf> aka C<-∞> represents the type-agnostic concept of
positive infinity, an C<Orderable> value that sorts I<after> all other
values in the Muldis D type system.  This value is also an C<Excuse> that
says the result of some operation is infinite in the positive direction.
Note that IEEE floating-point standards define a positive infinity value.

=head2 in_order

    ::MD::in_order::"" ::= function virtual
        --> Boolean <-- (Orderable, Orderable);

The virtual function C<in_order> results in C<True> iff its 2 arguments are
considered to already be I<in order> as given to the function, meaning that
either both arguments are exactly the same value or otherwise that the C<0>
argument value is definitively considered I<before> the C<1> argument
value; if C<0> is considered I<after> C<1> then C<in_order> results in
C<False>.  The primary reason for C<in_order> is to underlie all
order-determination or value sorting operations in an easy consistent way;
an C<Orderable>-composing contract only has to implement C<in_order> and
then values of its type can be compared, sorted on, and have intervals
defined in terms of them.

Other programming languages may instead typically use a three-way
comparison operator for this role, where its possible result values are
I<before>, I<same>, and I<after>, and those 3 are typically represented by
either the integers {-1,0,1} or a special 3-valued enumeration type.  Said
operators may be named I<< <=> >> or I<cmp> or I<compare> or I<CompareTo>
or I<memcmp> or I<strcmp>.  But Muldis D uses a C<Boolean> result instead
partly to keep its core type system simpler (it would have gone the
enumeration route) and partly because the logic for doing sorting or
comparisons or validation is typically much simpler with this foundation.

=head2 in_order (Neg_Inf, Pos_Inf)

    ::MD::in_order::Neg_Inf_L ::= function --> Boolean <-- (Neg_Inf, Orderable)
        implements 2::""
        : (True);

    ::MD::in_order::Neg_Inf_R ::= function --> Boolean <-- (Orderable, Neg_Inf)
        implements 2::""
        : (\<*args --> \same::());

    ::MD::in_order::Pos_Inf_L ::= function --> Boolean <-- (Pos_Inf, Orderable)
        implements 2::""
        : (\<*args --> \same::());

    ::MD::in_order::Pos_Inf_R ::= function --> Boolean <-- (Orderable, Pos_Inf)
        implements 2::""
        : (True);

The 4 functions {C<in_order::Neg_Inf_L>, C<in_order::Neg_Inf_R>,
C<in_order::Pos_Inf_L>, C<in_order::Pos_Inf_R>} implement the C<Orderable>
virtual function C<in_order> for the composing types C<Neg_Inf> and
C<Pos_Inf>, specifically for comparing either value with any C<Orderable>.

=head2 before <

    ::MD::before ::= function commutes after;

    ::MD::"<" ::= alias of before;

The function C<before> aka C<< < >> results in C<True> iff its C<0>
argument is I<before> its C<1> argument; otherwise it results in C<False>.
Other programming languages may name this operator I<lt>.

=head2 after >

    ::MD::after ::= function negates before_or_same;

    ::MD::">" ::= alias of after;

The function C<after> aka C<< > >> results in C<True> iff its C<0>
argument is I<after> its C<1> argument; otherwise it results in C<False>.
Other programming languages may name this operator I<gt>.

=head2 before_or_same <= ≤

    ::MD::before_or_same ::= alias of in_order;

    ::MD::"<=" ::= alias of before_or_same;

    ::MD::Unicode_Aliases::"≤" ::= alias of before_or_same;

The function C<before_or_same> aka C<< <= >> aka C<≤> results in C<True>
iff its C<0> argument is I<before> its C<1> argument or they are the same
value; otherwise it results in C<False>.  Other programming languages may
name this operator I<le>.

=head2 after_or_same >= ≥

    ::MD::after_or_same ::= function commutes before_or_same;

    ::MD::">=" ::= alias of after_or_same;

    ::MD::Unicode_Aliases::"≥" ::= alias of after_or_same;

The function C<after_or_same> aka C<< >= >> aka C<≥> results in C<True>
iff its C<0> argument is I<after> its C<1> argument or they are the same
value; otherwise it results in C<False>.  Other programming languages may
name this operator I<ge>.

=head2 min

    ::MD::min ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity (+∞)
        : (\<*args --> \in_order::() ?? \<0 !! \<1);

The function C<min> results in whichever of its 2 arguments is first when
the 2 are sorted I<in order>.  This function is designed to be chained for
any number of values in order to pick the one that sorts
I<before> all of the others.

=head2 max

    ::MD::max ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity (-∞)
        : (\<*args --> \in_order::() ?? \<1 !! \<0);

The function C<max> results in whichever of its 2 arguments is last when
the 2 are sorted I<in order>.  This function is designed to be chained for
any number of values in order to pick the one that sorts
I<after> all of the others.

=head2 minmax

    ::MD::minmax ::= function
        --> (Orderable, Orderable) <-- (Orderable, Orderable)
        is commutative
        : (\<*args --> \in_order::() ?? \<*args !! (\<1, \<0));

The function C<minmax> results in a binary C<Tuple> containing its 2
arguments sorted I<in order>; the function's result is the same as its
source when the arguments are already in order, and the reverse of that
otherwise, meaning the values of C<0> and C<1> are swapped.

=head1 SUCCESSABLE DATA TYPES

=head2 Successable

    ::MD::Successable ::= interface
        requires_implements {asset,succ};

The interface contract C<Successable> is infinite.  A C<Successable> value
is a member of a conceptually noncontiguous totally ordered type; it has a
definitive I<successor> value of that type, at least where the given value
isn't the last value.

The primary reason for C<Successable> is to provide an easy consistent and
terse API for a generator of arbitrary sequences of values of any type.  In
this context, a C<Successable> value defines a complete self-contained
I<state> for a sequence generator, which is everything the generator needs
to know to both emit a I<current> value, which we call the I<asset>, as
well as determine all subsequent values of the sequence without any further
input.  To keep the fundamental general case API simple, there is just the
a monadic function to derive the next state from the current one, and a
monadic function to extract the asset from the current state, so actually
reading a sequence of values requires 2 function calls per value in the
general case.  For some trivial cases of C<Successable>, the I<state> and
I<asset> are one and the same, so just 1 function call per value is needed.
Keep in mind that asset values may repeat in a sequence, so it is not them
but rather the state values that have the total order property.  Other
programming languages may name their corresponding types I<sequence> or
I<iterator> or I<enumerator>.

C<Successable> is a less rigorous analogy to C<Bicessable>, where the
latter also requires the ability to produce the I<predecessor> value of the
given value, as well as the ability to determine if 2 arbitrary values are
in order.  While conceptually a C<Successable> has those features, formally
it is not required to because for some types it may be onerous or
unnecessary for its mandate to support those features; for example,
producing a successor state may disgard information otherwise needed to
recall any of its predecessors.

The default and minimum and maximum values of C<Successable> are the same
as those of C<Orderable>.  C<Successable> is composed, directly or
indirectly, by: C<Bicessable>, C<Boolean>, C<Integral>, C<Integer>.

C<Successable> is intended to be a generalized tool for performing I<list
comprehension> or I<set comprehension>.  The typically idiomatic and more
efficient way to do many kinds of such I<comprehensions> is to use the
features of various C<Homogeneous> types to map an existing list or set to
another using generic member mapping and filtering functions, such as a
list of even integers less than a hundred.  With those cases, the
map/filter approach can permit processing members in any order or in
parallel, and avoiding unnecessary intermediate values.  In contrast, the
primary intended uses of C<Successable> is when either you want to produce
or process a potentially infinite-sized list (lazily) or especially produce
a sequence with uneven step sizes, such as an arbitrary number of
Fibonacci.  This is for cases where it may be necessary to calculate all
the intermediate values in order to arrive at a desired nth one, and doing
them out of sequence or in parallel may not be an option.

=head2 asset

    ::MD::asset::"" ::= function virtual --> Any <-- (Successable);

The virtual function C<asset> results in the I<asset> of its C<0> argument,
which for trivial cases may simply be that same argument.  Other
programming languages may name their corresponding operators I<Current>.

=head2 succ

    ::MD::succ::"" ::= function virtual
        --> {Successable, Pos_Inf} <-- (Successable);

The virtual function C<succ> results in the I<successor> value of its
C<0> argument, or in C<Pos_Inf> if there is none.  Other programming
languages may name their corresponding operators I<next> or I<MoveNext>.

=head2 nth_succ

    ::MD::nth_succ ::= function
        --> {Successable, Pos_Inf} <-- (Successable, Integer_NN)
    : (
        if !?\<1 then
            \<0
        else
            if Excuse::(s ::= succ \<0) then
                s
            else
                s nth_succ --\<1
    );

The function C<nth_succ> results in the Nth I<successor> value of its C<0>
argument, where N is its C<1> argument, or in C<Pos_Inf> if there is none.

=head1 BICESSABLE DATA TYPES

=head2 Bicessable

    ::MD::Bicessable ::= interface
        composes {Orderable and_provides_its_default,
            Successable and_provides_its_default}
        requires_implements {in_order,asset,pred,succ};

The interface contract C<Bicessable> is infinite.  A C<Bicessable> value
is an C<Orderable> value for which, using the same canonical total order
for its type, there exists definitive I<predecessor> and I<successor>
values, at least where the given value isn't the first or last value on the
line respectively.  Similarly, one can take any two values of a
C<Bicessable> type and produce an ordered list of all of that type's values
which are on the line between those two values.  A primary quality of a
type that is C<Orderable> but not C<Bicessable> is that you can take any
two values of that type and then find a third value of that type which lies
between the first two on the line; by definition for a C<Bicessable> type,
there is no third value between one of its values and that value's
predecessor or successor value.  Other programming languages may name their
corresponding types I<ordinal> or categorically as I<enum>.  Note that
while a generic rational numeric type may qualify as an ordinal type by
some definitions of I<ordinal>, since it is possible to count all the
rationals if arranged a particular way, these types would not qualify as
C<Bicessable> here when that ordering is not the same as the one used for
the same type's C<Orderable> comparisons.  The default and minimum and
maximum values of C<Bicessable> are the same as those of C<Orderable>.
C<Bicessable> is composed, directly or indirectly, by: C<Boolean>,
C<Integral>, C<Integer>.

For some C<Bicessable> types, there is the concept of a I<quantum> or
I<step size>, where every consecutive pair of values on that type's value
line are conceptually spaced apart at equal distances; this distance would
be the quantum, and all steps along the value line are at exact multiples
of that quantum.  However, C<Bicessable> types in general don't need to be
like this, and there can be different amounts of conceivable distance
between consecutive values; a C<Bicessable> type is just required to know
where all the values are.  For example, C<Integer> has a quantum while a
type consisting just of prime integers does not.

Note that while mathematics formally defines I<predecessor> and
I<successor> for non-negative integers only, and some other programming
languages extend this concept to real numbers with the meaning I<minus one>
and I<plus one> respectively, Muldis D only formally associates these terms
with the quantum of I<one> for types specifically representing integers;
for C<Bicessable> types in general, the terms just mean prior or next
values and should not be conceptualized as mathematical operations.

=head2 pred

    ::MD::pred::"" ::= function virtual
        --> {Bicessable, Neg_Inf} <-- (Bicessable);

The virtual function C<pred> results in the I<predecessor> value of its
C<0> argument, or in C<Neg_Inf> if there is none.  Other programming
languages may name their corresponding operators I<prior> or I<previous>.

=head2 nth_pred

    ::MD::nth_pred ::= function
        --> {Bicessable, Neg_Inf} <-- (Bicessable, Integer_NN)
    : (
        if !?\<1 then
            \<0
        else
            if Excuse::(s ::= pred \<0) then
                s
            else
                s nth_pred --\<1
    );

The function C<nth_pred> results in the Nth I<predecessor> value of its C<0>
argument, where N is its C<1> argument, or in C<Neg_Inf> if there is none.

=head1 BOOLABLE DATA TYPES

=head2 Boolable

    ::MD::Boolable ::= interface requires_implements to_Boolean;

The interface contract C<Boolable> is infinite.  A C<Boolable> value has a
canonical way of being cast to a C<Boolean> value in a context-free manner,
as the answer to the non-specific question "Is that so?" on the value taken
in isolation, whatever that would conceivably mean for the value's type.
The idiomatic predicate being asked has to do with whether or not something
exists; for composing numeric types it is asking whether the number is
nonzero; for composing collection types it is asking whether the collection
has any members.  The primary reason for C<Boolable> is to provide an easy
consistent and terse way to ask a common predicate question such as this.
The default value of C<Boolable> is C<False>.  Other programming languages
often have the concept of particular values from a wide variety of types as
being conceptually either I<false> or I<true>, and C<Boolable> is the
formalization of that concept for Muldis D, allowing program code to be
written in a similar style but with more type safety as any treatment of a
value as a C<Boolean> must be made explicit.

C<Boolable> is composed, directly or indirectly, by: C<Boolean>,
C<Numerical>, C<Integral>, C<Integer>, C<Fractional>, C<Fraction>,
C<Emptyable>, C<Stringy>, C<Bits>, C<Blob>, C<Textual>, C<Text>,
C<Homogeneous>, C<Unionable>, C<Discrete>, C<Positional>, C<Array>,
C<String>, C<Set>, C<Bag>, C<Relational>, C<Tuple_Array>, C<Relation>,
C<Tuple_Bag>, C<Intervalish>, C<Interval>, C<Unionable_Intervalish>,
C<Interval_Set>, C<Interval_Bag>.

While conceivably C<Boolable> could also be composed by C<Attributive>, and
hence C<Tuple>, it isn't because that would set up a semantic conflict for
C<Relation> and C<Tuple_Bag> which are collections across 2 dimensions, and
it was decided for those latter types that C<Boolable> would apply to them
explicitly in their C<Homogeneous> dimension (by way of C<Emptyable>) and
not in their C<Attributive> dimension.  As such, the C<Attributive> functions
C<has_any_attrs> and C<is_nullary> are provided as that dimension's direct
analogies to the C<Homogeneous> dimension's C<Boolable>-implementing
C<has_any_members> (C<to_Boolean>/C<so>) and C<is_empty> (C<not_so>) functions.

=head2 to_Boolean so ?

    ::MD::to_Boolean::"" ::= function virtual --> Boolean <-- (Boolable);

    ::MD::so  ::= alias of to_Boolean;
    ::MD::"?" ::= alias of to_Boolean;

The virtual function C<to_Boolean> aka C<so> aka C<?> results in C<True>
typically when its C<0> argument is a nonzero number or a nonempty
collection; otherwise it results in C<False>.

=head2 not_so !?

    ::MD::not_so ::= function negates to_Boolean;

    ::MD::"!?" ::= alias of not_so;

The function C<not_so> aka C<!?> results in C<True> typically when
its C<0> argument is a number zero or an empty collection; otherwise
it results in C<False>.

=head1 BOOLEAN DATA TYPES

=head2 Boolean Bool

    ::MD::Boolean ::= selection where (\<*args -->^ FDN__is_a_Boolean)
        default (False)
        composes {Bicessable, Boolable and_provides_its_default};

    ::MD::Bool ::= alias of Boolean;

The selection contract C<Boolean> aka C<Bool> represents the finite Muldis
D Foundation type I<FDN__Boolean>.  A C<Boolean> value is a general purpose
2-valued logic boolean or I<truth value>, or specifically it is one of the
2 values C<False> and C<True>.  Its default value is C<False>.  C<Boolean>
is both C<Orderable> and C<Bicessable>; its minimum value is C<False> and
its maximum value is C<True>.  Other programming languages frequently don't
have a dedicated boolean type but rather consider values of other types,
typically integer types, to be I<false> or I<true>.

=head2 False ⊥

    ::MD::False ::= constant (False);

    ::MD::Unicode_Aliases::"⊥" ::= alias of False;

The constant C<False> aka C<⊥> represents the boolean logical truth value
I<false> aka I<contradiction>.  Other programming languages frequently use
the integer 0 to represent I<false>.

=head2 True ⊤

    ::MD::True ::= constant (True);

    ::MD::Unicode_Aliases::"⊤" ::= alias of True;

The constant C<True> aka C<⊤> represents the boolean logical truth value
I<true> aka I<tautology>.  Other programming languages frequently use the
integer 1 to represent I<true>.

=head2 in_order (Boolean)

    ::MD::in_order::Boolean ::= function --> Boolean <-- (Boolean, Boolean)
        implements 2::""
        : (!\<0 or \<1);

The function C<in_order::Boolean> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Boolean>.

=head2 asset (Boolean)

    ::MD::asset::Boolean ::= function --> Boolean <-- (Boolean)
        implements 2::""
        : (\<0);

The function C<asset::Boolean> simply results in its C<0> argument.
This function implements the C<Successable> virtual function C<asset> for
the composing type C<Boolean>.

=head2 pred (Boolean)

    ::MD::pred::Boolean ::= function --> {False, Neg_Inf} <-- (Boolean)
        implements 2::""
        : (\<0 ?? False !! -∞);

The function C<pred::Boolean> implements the C<Bicessable> virtual
function C<pred> for the composing type C<Boolean>.

=head2 succ (Boolean)

    ::MD::succ::Boolean ::= function --> {True, Pos_Inf} <-- (Boolean)
        implements 2::""
        : (!\<0 ?? True !! +∞);

The function C<succ::Boolean> implements the C<Successable> virtual
function C<succ> for the composing type C<Boolean>.

=head2 to_Boolean (Boolean)

    ::MD::to_Boolean::Boolean ::= function --> Boolean <-- (Boolean)
        implements 2::""
        : (\<0);

The function C<to_Boolean::Boolean> performs a logical I<proposition>; it
simply results in its C<0> argument.  This function implements the
C<Boolable> virtual function C<to_Boolean> aka C<so> aka C<?> for the
composing type C<Boolean>.

=head2 not ! ¬

    ::MD::not ::= function negates to_Boolean::Boolean;

    ::MD::"!" ::= alias of not;

    ::MD::Unicode_Aliases::"¬" ::= alias of not;

The function C<not> aka C<!> aka C<¬> performs a logical I<negation> or
I<logical complement>; it results in C<True> iff its C<0> argument is
C<False> and vice-versa.  Other programming languages may name their
corresponding operators I<~> or I<^> or I<N>.

=head2 and ∧

    ::MD::and ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity (True)
        : (\<0 ?? \<1 !! False);

    ::MD::Unicode_Aliases::"∧" ::= alias of and;

The function C<and> aka C<∧> performs a logical I<conjunction>; it results
in C<True> iff its 2 arguments C<0> and C<1> are both C<True>, and C<False>
otherwise.  Other programming languages may name their corresponding
operators I<&> or I<&&> or I<K>.

=head2 nand not_and ⊼ ↑

    ::MD::nand ::= function negates and
        is commutative;

    ::MD::not_and ::= alias of nand;

    ::MD::Unicode_Aliases::"⊼" ::= alias of nand;
    ::MD::Unicode_Aliases::"↑" ::= alias of nand;

The function C<nand> aka C<not_and> aka C<⊼> aka C<↑> performs a logical
I<alternative denial>; it results in C<False> iff its 2 arguments C<0> and
C<1> are both C<True>, and C<True> otherwise.

=head2 or ∨

    ::MD::or ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity (False)
        : (\<0 ?? True !! \<1);

    ::MD::Unicode_Aliases::"∨" ::= alias of or;

The function C<or> aka C<∨> performs a logical I<disjunction>; it results
in C<True> iff at least one of its 2 arguments C<0> and C<1> is C<True>,
and C<False> otherwise.  Other programming languages may name their
corresponding operators I<|> or I<||> or I<A>.

=head2 nor not_or ⊽ ↓

    ::MD::nor ::= function negates or
        is commutative;

    ::MD::not_or ::= alias of nor;

    ::MD::Unicode_Aliases::"⊽" ::= alias of nor;
    ::MD::Unicode_Aliases::"↓" ::= alias of nor;

The function C<nor> aka C<not_or> aka C<⊽> aka C<↓> performs a logical
I<joint denial>; it results in C<False> iff at least one of its 2 arguments
C<0> and C<1> is C<True>, and C<True> otherwise.

=head2 xnor iff ↔

    ::MD::xnor ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative} identity (True)
        : (\<*args --> \same::());

    ::MD::iff ::= alias of xnor;

    ::MD::Unicode_Aliases::"↔" ::= alias of xnor;

The function C<xnor> aka C<iff> aka C<↔> performs a logical
I<biconditional> or I<material equivalence> or I<even parity>; it results
in C<True> iff its 2 arguments C<0> and C<1> are exactly the same value,
and C<False> otherwise.  This function is effectively a C<Boolean>-specific
alias of the function C<same> aka C<=>; it behaves identically to C<same>
when given the same arguments.  Other programming languages may
name their corresponding operators I<E>.

=head2 xor ⊻ ↮

    ::MD::xor ::= function negates xnor
        is {associative,commutative} identity (False);

    ::MD::Unicode_Aliases::"⊻" ::= alias of xor;
    ::MD::Unicode_Aliases::"↮" ::= alias of xor;

The function C<xor> aka C<⊻> aka C<↮> performs a logical I<exclusive
disjunction> or I<odd parity>; it results in C<False> iff its 2 arguments
C<0> and C<1> are exactly the same value, and C<True> otherwise.  This
function is effectively a C<Boolean>-specific alias of the function
C<not_same> aka C<!=> aka C<≠>; it behaves identically to C<not_same>
when given the same arguments.  Other programming languages may name their
corresponding operators I<^>.

=head2 imp implies →

    ::MD::imp ::= function --> Boolean <-- (Boolean, Boolean)
        : (\<0 ?? \<1 !! True);

    ::MD::implies ::= alias of imp;

    ::MD::Unicode_Aliases::"→" ::= alias of imp;

The function C<imp> aka C<implies> aka C<→> performs a logical I<material
implication>; it results in C<False> when its C<0> argument is C<True> and
its C<1> argument is C<False>, and C<True> otherwise.

=head2 nimp not_implies ↛

    ::MD::nimp ::= function negates imp;

    ::MD::not_implies ::= alias of nimp;

    ::MD::Unicode_Aliases::"↛" ::= alias of nimp;

The function C<nimp> aka C<not_implies> aka C<↛> performs a logical
I<material nonimplication>; it results in C<True> when its C<0> argument is
C<True> and its C<1> argument is C<False>, and C<False> otherwise.

=head2 if ←

    ::MD::if ::= function commutes imp;

    ::MD::Unicode_Aliases::"←" ::= alias of if;

The function C<if> aka C<←> performs a logical I<converse implication> or
I<reverse material implication>; it results in C<False> when its C<0>
argument is C<False> and its C<1> argument is C<True>, and C<True>
otherwise.

=head2 nif not_if ↚

    ::MD::nif ::= function commutes nimp;

    ::MD::not_if ::= alias of nif;

    ::MD::Unicode_Aliases::"↚" ::= alias of nif;

The function C<nif> aka C<not_if> aka C<↚> performs a logical I<converse
nonimplication>; it results in C<True> when its C<0> argument is C<False>
and its C<1> argument is C<True>, and C<False> otherwise.

=head1 ROUNDING INSTRUCTION DATA TYPES

=head2 Round_Meth

    ::MD::Round_Meth ::= enumeration
        union {Down,Up,To_Zero,To_Inf
            ,Half_Down,Half_Up,Half_To_Zero,Half_To_Inf
            ,Half_Even,Half_Odd}
        default To_Zero;

The selection contract C<Round_Meth> is finite.  When a value of some
C<Orderable> type needs to be mapped into a proper subtype that doesn't
contain that value, such as when mapping an arbitrary number to one with
less precision, some rounding method is applied to determine which value of
the subtype is to be mapped to while most accurately reflecting the
original value.  The C<Round_Meth> type enumerates the rounding methods
that Muldis D operators can typically apply.

With C<Down> (aka I<floor>), C<Up> (aka I<ceiling>), C<To_Zero> (aka
I<truncate>), and C<To_Inf>, the original value will always be mapped to
the single nearest value that is lower than it, or higher than it, or
towards "zero" from it, or towards the nearer infinity from it,
respectively.  With C<Half_Down>, C<Half_Up>, C<Half_To_Zero>,
C<Half_To_Inf>, C<Half_Even> (aka I<unbiased rounding>, I<convergent
rounding>, I<statistician's rounding>, or I<bankers' rounding>), and
C<Half_Odd> the original value will be mapped to the single target value
that it is nearest to, if there is one; otherwise, if it is exactly
half-way between 2 adjacent target values, then C<Half_Down> will round
towards negative infinity, C<Half_Up> will round towards positive infinity,
C<Half_To_Zero> will round towards "zero", C<Half_To_Inf> will round
towards the nearer infinity, while C<Half_Even> and C<Half_Odd> will round
towards the nearest "even" or "odd" target respectively.

The default value of C<Round_Meth> is C<To_Zero>, which is the simplest.
Other programming languages may name their corresponding types
I<RoundingMode> (Java) or I<MidpointRounding> (C#).

=head1 NUMERICAL DATA TYPES

=head2 Numerical

    ::MD::Numerical ::= interface
        composes Boolable
        requires_implements {to_Boolean
            ,zero,opposite,reciprocal,modulus
            ,plus,minus,times,multiple_of
            ,fractional_divided_by,integral_divided_by
            ,integral_power,integral_nn_power};

The interface contract C<Numerical> is infinite.  A C<Numerical> value
either is a simple number of some kind or is something that can act as a
simple number.  A I<simple number> means, typically speaking, any rational
real number, those numbers that can be derived simply by multiplying or
dividing integers.  All operators defined by the C<Core> package
for C<Numerical> are expect to be closed over the real rational numbers,
and consist mainly of addition, subtraction, multiplication, and division
of any rationals, plus exponentiation of any rationals to integer powers
only.  Idiomatically a C<Numerical> is a pure number which does not
represent any kind of thing in particular, neither cardinal nor ordinal nor
nominal; however some types which do represent such a particular kind of
thing may choose to compose C<Numerical> because it makes sense to provide
its operators.  The default value of C<Numerical> is the C<Integer> value
C<0>.  A C<Numerical> in the general case is not C<Orderable>, but often a
type that is numeric is also orderable.  Other programming languages may
name their corresponding types I<Numeric>.

C<Numerical> is composed, directly or indirectly, by: C<Integral>,
C<Integer>, C<Fractional>, C<Fraction>, C<Quantitative>, C<Quantity>.
It is also composed by a lot of additional contracts defined by other
Muldis D packages such as L<Core::Math|Muldis::D::Package::Core::Math>;
these include types for irrational or algebraic or complex numbers or
quaternions or rational types with a fixed precision or scale or
floating-point types and so on.

=head2 Excuse::Div_By_Zero

    ::MD::Excuse::Div_By_Zero ::= constant composes Excuse;

The constant C<Excuse::Div_By_Zero> represents the I<undefined> result of
attempting to divide a simple number by a simple, unsigned, number zero.
Note that IEEE floating-point standards define a negative or positive
infinity result value when dividing by an explicitly signed (negative or
positive) zero, but the Muldis D C<Core> package lacks those concepts.

=head2 Excuse::Zero_To_The_Zero

    ::MD::Excuse::Zero_To_The_Zero ::= constant composes Excuse;

The constant C<Excuse::Zero_To_The_Zero> represents the I<undefined> result
of attempting to exponentiate a number zero to the power of a number zero.

=head2 to_Boolean (Numerical)

    ::MD::to_Boolean::Numerical ::= function virtual --> Boolean <-- (Numerical)
        implements 2::"";

The virtual function C<to_Boolean::Numerical> results in C<True> when its
C<0> argument is a nonzero number; otherwise it results in C<False>.  This
function implements the C<Boolable> virtual function C<to_Boolean> aka
C<so> aka C<?> for the composing type C<Numerical>.

=head2 is_zero

    ::MD::is_zero ::= function negates to_Boolean::Numerical;

The function C<is_zero> results in C<True> when its C<0> argument is a
number zero; otherwise it results in C<False>.

=head2 zero

    ::MD::zero::"" ::= function virtual --> Numerical <-- (Numerical);

The virtual function C<zero> results in the number zero of its C<0>
argument's numerical type, assuming that every type composing C<Numerical>
has one.

=head2 opposite

    ::MD::opposite::"" ::= function virtual --> Numerical <-- (Numerical);

    ::MD::additive_inverse ::= alias of opposite;

The virtual function C<opposite> aka C<additive_inverse> aka unary C<-> aka
unary C<−> results in the numeric I<opposite> or I<negation> or I<additive
inverse> or I<unary minus> of its C<0> argument, and is a shorthand for
either multiplying that argument by negative one or subtracting it from
zero.  By definition, the sum of a number and its opposite is zero.

=head2 reciprocal

    ::MD::reciprocal::"" ::= function virtual
        --> {Numerical, Excuse::Div_By_Zero} <-- (Numerical);

    ::MD::multiplicative_inverse ::= alias of reciprocal;

The virtual function C<reciprocal> aka C<multiplicative_inverse> results in
the numeric I<reciprocal> or I<multiplicative inverse> of its nonzero C<0>
argument, and is a shorthand for dividing one by that argument.  By
definition, the product of a number and its reciprocal is one.  The result
is always C<Fractional> for both C<Integral> and C<Fractional> arguments.
The result is only I<defined> when the argument is a nonzero number; it is
an C<Excuse> otherwise.

=head2 modulus abs

    ::MD::modulus::"" ::= function virtual --> Numerical <-- (Numerical);

    ::MD::abs ::= alias of modulus;

The virtual function C<modulus> aka C<abs> results in the numeric
I<modulus> or I<absolute value> of its C<0> argument, which is the
(non-negative) distance between that argument and zero.  Note that typical
mathematical notion writes this operator in circumfix like I<|n|>.

=head2 plus +

    ::MD::plus::"" ::= function virtual
        --> Numerical <-- (Numerical, Numerical)
        is {associative,commutative}
        repeater times;

    ::MD::"+" ::= alias of plus;

The virtual function C<plus> aka C<+> results in the numeric I<sum> from
performing I<addition> of its 2 I<summand> arguments C<0> (I<augend>) and
C<1> (I<addend>).  This operation has an identity value of a number zero.

=head2 minus

    ::MD::minus::"" ::= function virtual
        --> Numerical <-- (Numerical, Numerical);

The virtual function C<minus> aka binary C<-> aka binary C<−> results in
the numeric I<difference> from performing I<subtraction> of its 2 arguments
C<0> (I<minuend>) and C<1> (I<subtrahend>).

=head2 - −

    ::MD::"-" ::= function
        --> Numerical <-- {(Numerical), (Numerical, Numerical)}
        : (\<*args --> (degree::(\<*args) = 1 ?? \opposite::() !! \minus::()));

    ::MD::Unicode_Aliases::"−" ::= alias of "-";

The function C<-> aka C<−> is a proxy for either of the virtual functions
unary C<opposite> and binary C<minus>, depending on how many arguments it
was invoked with.

=head2 modulus_minus abs_minus |-| |−|

    ::MD::modulus_minus ::= function
        --> Numerical <-- (Numerical, Numerical)
        is commutative
        : (modulus \<*args --> \minus::());

    ::MD::abs_minus ::= alias of modulus_minus;
    ::MD::"|-|"     ::= alias of modulus_minus;

    ::MD::Unicode_Aliases::"|−|" ::= alias of modulus_minus;

The function C<modulus_minus> aka C<abs_minus> aka C<|-|> aka C<|−|>
results in the numeric I<absolute difference> of its 2 arguments C<0> and
C<1>, which is the (non-negative) distance between those arguments.

=head2 times * ×

    ::MD::times::"" ::= function virtual
        --> Numerical <-- (Numerical, Numerical)
        is {associative,commutative}
        repeater integral_nn_power;

    ::MD::"*" ::= alias of times;

    ::MD::Unicode_Aliases::"×" ::= alias of times;

The virtual function C<times> aka C<*> aka C<×> results in the numeric
I<product> from performing I<multiplication> of its 2 I<factor> arguments
C<0> (I<multiplier>) and C<1> (I<multiplicand>).  This operation has an
identity value of a number positive one.

=head2 multiple_of

    ::MD::multiple_of::"" ::= function virtual
        --> {Boolean, Excuse::Div_By_Zero} <-- (Numerical, Numerical);

The virtual function C<multiple_of> results in C<True> iff its C<0>
argument is an even multiple of its C<1> argument (that is, the former is
evenly divisible by the latter), and C<False> otherwise.  The result is
only I<defined> when the C<1> argument is a nonzero number; it is an
C<Excuse> otherwise.  Other programming languages may name their
corresponding operators I<%%>.

=head2 nearest_multiple_of round

    ::MD::nearest_multiple_of ::= function
        --> {Numerical, Excuse::Div_By_Zero}
        <-- (Numerical, Numerical, Round_Meth)
        : (if \<1->is_zero then Excuse::Div_By_Zero()
            else \<1 * \<*args --> \div::());

    ::MD::round ::= alias of nearest_multiple_of;

The function C<nearest_multiple_of> aka C<round> results in the same or
nearest number to its C<0> argument that is an even multiple of its C<1>
argument (that is, the result is evenly divisible by the latter), where the
nearest is determined by the rounding method specified by the C<2>
argument.  For the common case of rounding to the nearest integer, use a
C<1> argument of positive one.  The result is C<Integral> for C<Integral>
arguments and is C<Fractional> for C<Fractional> arguments.  The result is
only I<defined> when the C<1> argument is a nonzero number; it is an
C<Excuse> otherwise.  Other programming languages may name their
corresponding operators I<truncate> or I<int> or I<floor> or I<ceil> or
other things, some of which would always round to a multiple of one.

=head2 fractional_divided_by / ÷ ∕

    ::MD::fractional_divided_by::"" ::= function virtual
        --> {Numerical, Excuse::Div_By_Zero} <-- (Numerical, Numerical);

    ::MD::"/" ::= alias of fractional_divided_by;

    ::MD::Unicode_Aliases::"÷" ::= alias of fractional_divided_by;
    ::MD::Unicode_Aliases::"∕" ::= alias of fractional_divided_by;

The virtual function C<fractional_divided_by> aka C</> aka C<÷> aka C<∕>
results in the typically-fractional numeric I<quotient> from performing
I<division> of its 2 arguments C<0> (I<dividend> or I<numerator>) and C<1>
(I<divisor> or I<denominator>) using the semantics of real number division.
The result is always C<Fractional> for both C<Integral> and C<Fractional>
arguments; as such, C<fractional_divided_by> is the idiomatic way to select
any C<Fraction> values in terms of C<Integer> values.  The result is only
I<defined> when the C<1> argument is a nonzero number; it is an C<Excuse>
otherwise.

=head2 integral_divided_by div

    ::MD::integral_divided_by::"" ::= function virtual
        --> {Numerical, Excuse::Div_By_Zero}
        <-- (Numerical, Numerical, Round_Meth);

    ::MD::div ::= alias of integral_divided_by;

The virtual function C<integral_divided_by> aka C<div> results in the
integral numeric I<quotient> from performing I<division> of its 2 arguments
C<0> (I<dividend> or I<numerator>) and C<1> (I<divisor> or I<denominator>)
using the semantics of real number division, whereupon the real number
result is rounded to the same or nearest integral number, where the nearest
is determined by the rounding method specified by the C<2> argument.  The
result is C<Integral> for C<Integral> arguments and is C<Fractional> with a
I<denominator> of one for C<Fractional> arguments.  The result is only
I<defined> when the C<1> argument is a nonzero number; it is an C<Excuse>
otherwise.

=head2 modulo mod

    ::MD::modulo ::= function
        --> {Numerical, Excuse::Div_By_Zero}
        <-- (Numerical, Numerical, Round_Meth)
        : (if \<1->is_zero then Excuse::Div_By_Zero()
            else \<0 - \<*args --> \nearest_multiple_of::());

    ::MD::mod ::= alias of modulo;

The function C<modulo> aka C<mod> results in the possibly-fractional
numeric I<remainder> from performing same I<division> operation as
C<integral_divided_by> does with all of the same arguments; to be specific,
C<modulo> preserves the identity C<x mod y = x - y * (x div y)>.  The
result is C<Integral> for C<Integral> arguments and is C<Fractional> for
C<Fractional> arguments.  The result is only I<defined> when the C<1>
argument is a nonzero number; it is an C<Excuse> otherwise.  Other
programming languages may name their corresponding operators I<%> or I<//>
or I<\\> or I<div> or I<rem> or I<remainder> or various other things.

=head2 divided_by_and_modulo

    ::MD::divided_by_and_modulo::"" ::= function
        --> ({Numerical, Excuse::Div_By_Zero}, {Numerical, Excuse::Div_By_Zero})
        <-- (Numerical, Numerical, Round_Meth)
        : ((\<*args --> \div::(), \<*args --> \mod::()));

The function C<divided_by_and_modulo> results in a binary tuple whose C<0>
and C<1> attributes have the exact same values that C<integral_divided_by>
and C<modulo> would result in, respectively, when each is given all of the
same arguments.  This function is a shorthand for invoking the other two.

=head2 integral_power **

    ::MD::integral_power::"" ::= function virtual
        --> {Numerical, Excuse::Zero_To_The_Zero} <-- (Numerical, Integral);

    ::MD::"**" ::= alias of integral_power;

The virtual function C<integral_power> aka C<**> results in a
typically-fractional number from performing I<exponentiation> of its 2
arguments C<0> (I<base>) and C<1> (I<exponent> or I<power>).  The result is
always C<Fractional> for both an C<Integral> and a C<Fractional> C<0>
argument.  The result is only I<defined> when at least one of the arguments
C<0> and C<1> is a nonzero number; it is an C<Excuse> otherwise.  Other
programming languages may name their corresponding operators I<exp> or I<^>.

=head2 integral_nn_power power

    ::MD::integral_nn_power::"" ::= function virtual
        --> {Numerical, Excuse::Zero_To_The_Zero} <-- (Numerical, Integral_NN);

    ::MD::power ::= alias of integral_nn_power;

The virtual function C<integral_nn_power> aka C<power> results in a
possibly-fractional number from performing I<exponentiation> of its 2
arguments C<0> (I<base>) and C<1> (I<exponent> or I<power>).  The result is
C<Integral> for an C<Integral> C<0> argument and is C<Fractional> for a
C<Fractional> C<0> argument.  The result is only I<defined> when at least
one of the arguments C<0> and C<1> is a nonzero number; it is an C<Excuse>
otherwise.

=head1 INTEGRAL DATA TYPES

=head2 Integral

    ::MD::Integral ::= interface
        composes {Bicessable and_provides_its_default,
            Numerical and_provides_its_default}
        requires_implements {in_order,asset,pred,succ
            ,to_Boolean
            ,zero,opposite,reciprocal,modulus
            ,plus,minus,times,multiple_of
            ,fractional_divided_by,integral_divided_by
            ,integral_power,integral_nn_power
            ,to_Integer,factorial};

The interface contract C<Integral> is infinite.  An C<Integral> value
either is an exact integral number of some kind or is something that can
act as such.  Idiomatically an C<Integral> is a pure integer which does not
represent any kind of thing in particular, neither cardinal nor ordinal nor
nominal; however some types which do represent such a particular kind of
thing may choose to compose C<Integral> because it makes sense to provide
its operators.  The default value of C<Integral> is the C<Integer> value
C<0>.  C<Integral> is both C<Orderable> and C<Bicessable>.  For each type
composing C<Integral>, a value closer to negative infinity is ordered
before a value closer to positive infinity, and the definition of
I<predecessor> and I<successor> is exactly equal to subtracting or adding
an integer positive-one respectively, while other C<Bicessable> don't
generally mean that.  In the general case, C<Integral> has no minimum or
maximum value, but often a type that is C<Integral> will have them.
C<Integral> is composed by C<Integer>.

=head2 Integral_NN

    ::MD::Integral_NN ::= selection of Integral
        where (\<0 >= zero::(\<0));

The selection contract C<Integral_NN> represents the infinite type
consisting just of the C<Integral> values that are non-negative.  Its
default and minmum value is C<0>; it has no maximum value.

=head2 Integral_P

    ::MD::Integral_P ::= selection of Integral_NN
        where (\<0 > zero::(\<0)) default (succ::(Integral::()));

The selection contract C<Integral_P> represents the infinite type
consisting just of the C<Integral_NN> values that are positive.  Its
default and minmum value is C<1>; it has no maximum value.

=head2 pred (Integral)

    ::MD::pred::Integral ::= function virtual --> Integral <-- (Integral)
        implements 2::"";

    ::MD::"--" ::= alias of pred::Integral;

The virtual function C<pred::Integral> aka C<--> implements the
C<Bicessable> virtual function C<pred> for the composing type C<Integral>.
Other programming languages may name their corresponding operators
I<decrement>.

=head2 succ (Integral)

    ::MD::succ::Integral ::= function virtual --> Integral <-- (Integral)
        implements 2::"";

    ::MD::"++" ::= alias of succ::Integral;

The virtual function C<succ::Integral> aka C<++> implements the
C<Successable> virtual function C<succ> for the composing type C<Integral>.
Other programming languages may name their corresponding operators
I<increment>.

=head2 to_Integer

    ::MD::to_Integer::"" ::= function virtual --> Integer <-- (Integral);

The virtual function C<to_Integer> results in the C<Integer> value that
represents the same integer value as its C<0> argument.  The purpose of
C<to_Integer> is to canonicalize C<Integral> values so they can be compared
abstractly as integers, or so that it is easier to do exact math with
integers without running afoul of possible range limits of fixed-size
C<Integral> types, just dealing with the latter for storage.

=head2 factorial

    ::MD::factorial::"" ::= function virtual --> Integral_P <-- (Integral_NN);

The virtual function C<factorial> results in the integral numeric
I<factorial> of its C<0> argument, and is a shorthand for the product of
every integer between 1 and that argument; the factorial of zero is defined
to result in positive one.  Note that typical mathematical notion writes
this operator in postfix like I<n!>.

=head2 gcd greatest_common_divisor

    ::MD::gcd ::= function --> Integral_P <-- (Integral_NN, Integral_NN)
        is {commutative,associative,idempotent}
        : ((if \<1->is_zero then \<0 else 0::(\<1, mod::(\<0, \<1, To_Zero::())))
            ::?= 'Calculate using the Euclidean algorithm.');

    ::MD::greatest_common_divisor ::= alias of gcd;

The function C<gcd> aka C<greatest_common_divisor> results in the integral
numeric I<greatest common divisor> of its 2 arguments C<0> and C<1>, which
is the largest integer that will divide both arguments evenly.
I<TODO: Look into generalizing it to take negative integer arguments too.>

=head2 lcm least_common_multiple

    ::MD::lcm ::= function --> Integral_NN <-- (Integral_NN, Integral_NN)
        is {commutative,associative,idempotent}
        : (if \<0->is_zero or \<1->is_zero then \<0->zero
            else div::(\<0 * \<1, \<0 gcd \<1, To_Zero::()));

    ::MD::least_common_multiple ::= alias of lcm;

The function C<lcm> aka C<least_common_multiple> results in the integral
numeric I<least common multiple> of its 2 arguments C<0> and C<1>, which
is the smallest integer that is an even multiple of both arguments.
I<TODO: Look into generalizing it to take negative integer arguments too.>

=head2 coprime

    ::MD::coprime ::= function --> Boolean <-- (Integral, Integral)
        : ((abs::(\<0) gcd abs::(\<1)) = (\<0->zero->succ));

The function C<coprime> results in C<True> iff its 2 arguments C<0> and
C<1> are coprime (their I<greatest common divisor> is 1), and C<False>
otherwise.

=head1 INTEGER DATA TYPES

=head2 Integer

    ::MD::Integer ::= selection where (\<*args -->^ FDN__is_a_Integer)
        default (0)
        composes Integral and_provides_its_default;

The selection contract C<Integer> represents
the infinite Muldis D Foundation type I<FDN__Integer>.  An C<Integer>
value is a general purpose exact integral number of any magnitude, which
explicitly does not represent any kind of thing in particular, neither
cardinal nor ordinal nor nominal.  Its default value is C<0>.  C<Integer>
is both C<Orderable> and C<Bicessable>; it has no minimum or maximum value.
Other programming languages may name their corresponding types I<BigInt>.

=head2 Integer_NN

    ::MD::Integer_NN ::= selection of Integer where (\<0 >= 0);

The selection contract C<Integer_NN> represents the infinite type
consisting just of the C<Integer> values that are non-negative.  Its
default and minmum value is C<0>; it has no maximum value.

=head2 Integer_P

    ::MD::Integer_P ::= selection of Integer_NN where (\<0 > 0) default (1);

The selection contract C<Integer_P> represents the infinite type consisting
just of the C<Integer_NN> values that are positive.  Its default and minmum
value is C<1>; it has no maximum value.

=head2 in_order (Integer)

    ::MD::in_order::Integer ::= function --> Boolean <-- (Integer, Integer)
        implements 2::""
        : (\<*args -->^ FDN__Integer_in_order);

The function C<in_order::Integer> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Integer>.

=head2 asset (Integer)

    ::MD::asset::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (\<0);

The function C<asset::Integer> simply results in its C<0> argument.
This function implements the C<Successable> virtual function C<asset> for
the composing type C<Integer>.

=head2 pred (Integer)

    ::MD::pred::Integer ::= function --> Integer <-- (Integer)
        implements 2::Integral
        : (\<0 - 1);

The function C<pred::Integer> implements the C<Bicessable>/C<Integral>
virtual function C<pred> aka C<--> for the composing type C<Integer>.

=head2 succ (Integer)

    ::MD::succ::Integer ::= function --> Integer <-- (Integer)
        implements 2::Integral
        repeater plus::Integer
        : (\<0 + 1);

The function C<succ::Integer> implements the C<Successable>/C<Integral>
virtual function C<succ> aka C<++> for the composing type C<Integer>.

=head2 to_Boolean (Integer)

    ::MD::to_Boolean::Integer ::= function --> Boolean <-- (Integer)
        implements 2::""
        : (\<0 != 0);

The function C<to_Boolean::Integer> results in C<True> iff its C<0>
argument is not C<0>, and in C<False> if it is C<0>.  This function
implements the C<Boolable> virtual function C<to_Boolean> aka C<so> aka
C<?> for the composing type C<Integer>.

=head2 zero (Integer)

    ::MD::zero::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (0);

The function C<zero::Integer> simply results in C<0>.  This function
implements the C<Numerical> virtual function C<zero> for the composing type
C<Integer>.

=head2 opposite (Integer)

    ::MD::opposite::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (\<*args -->^ FDN__Integer_opposite);

The function C<opposite::Integer> implements the C<Numerical> virtual
function C<opposite> aka C<additive_inverse> aka unary C<-> aka unary C<−>
for the composing type C<Integer>.

=head2 reciprocal (Integer)

    ::MD::reciprocal::Integer ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Integer)
        implements 2::""
        : (1 / \<0);

The function C<reciprocal::Integer> implements the C<Numerical> virtual
function C<reciprocal> aka C<multiplicative_inverse> for the composing type
C<Integer>.

=head2 modulus (Integer)

    ::MD::modulus::Integer ::= function --> Integer_NN <-- (Integer)
        implements 2::""
        : (\<*args -->^ FDN__Integer_modulus);

The function C<modulus::Integer> implements the C<Numerical>
virtual function C<modulus> aka C<abs> for the composing type C<Integer>.

=head2 plus (Integer)

    ::MD::plus::Integer ::= function --> Integer <-- (Integer, Integer)
        implements 2::""
        is {associative,commutative} identity (0)
        repeater times::Integer
        : (\<*args -->^ FDN__Integer_plus);

The function C<plus::Integer> implements the C<Numerical>
virtual function C<plus> aka C<+> for the composing type C<Integer>.

=head2 minus (Integer)

    ::MD::minus::Integer ::= function --> Integer <-- (Integer, Integer)
        implements 2::""
        : (\<*args -->^ FDN__Integer_minus);

The function C<minus::Integer> implements the C<Numerical> virtual function
C<minus> aka binary C<-> aka binary C<−> for the composing type C<Integer>.

=head2 times (Integer)

    ::MD::times::Integer ::= function --> Integer <-- (Integer, Integer)
        implements 2::""
        is {associative,commutative} identity (1)
        repeater integral_nn_power::Integer
        : (\<*args -->^ FDN__Integer_times);

The function C<times::Integer> implements the C<Numerical> virtual function
C<times> aka C<*> aka C<×> for the composing type C<Integer>.

=head2 multiple_of (Integer)

    ::MD::multiple_of::Integer ::= function
        --> {Boolean, Excuse::Div_By_Zero} <-- (Integer, Integer)
        implements 2::""
        : (if \<1 = 0 then Excuse::Div_By_Zero()
            else \<*args -->^ FDN__Integer_multiple_of);

The function C<multiple_of::Integer> implements the C<Numerical>
virtual function C<multiple_of> for the composing type C<Integer>.

=head2 fractional_divided_by (Integer)

    ::MD::fractional_divided_by::Integer ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Integer, Integer)
        implements 2::""
    : (
        n ::= \<0;
        d ::= \<1;

        <-- if d = 0 then Excuse::Div_By_Zero() else q;

        q ::= (\Fraction wrap (
            numerator   : div::((d > 0 ?? n !! -n), gcd, To_Zero::()),
            denominator : div::((d > 0 ?? d !! -d), gcd, To_Zero::()),
        ));

        gcd ::= gcd::(abs::(n), abs::(d));
    );

The function C<fractional_divided_by::Integer> implements the C<Numerical>
virtual function C<fractional_divided_by> aka C</> aka C<÷> aka C<∕> for
the composing type C<Integer>.

=head2 integral_divided_by (Integer)

    ::MD::integral_divided_by::Integer ::= function
        --> {Integer, Excuse::Div_By_Zero}
        <-- (Integer, Integer, Round_Meth)
        implements 2::""
    : (
        dividend   ::= \<0;
        divisor    ::= \<1;
        round_meth ::= \<2;

        <-- if divisor = 0 then Excuse::Div_By_Zero() else e1;

        e1 ::?= 'This is the case where we are dividing by a non-zero.';

        e1 ::= (
               dividend = 0       ?? 0
            !! divisor  = 1       ?? dividend
            !! dividend = divisor ?? 1
            !! divisor  = -1      ?? -dividend
            !!                       e2
        );

        e2 ::?= 'This is the case where the divisor and dividend do not'
            ' equal each other and neither of them is a zero or a one.';

        e2 ::= (
            real_q_is_neg ::= (dividend < 0 xor divisor < 0);
            rtz_quotient  ::= (FDN__Integer_divided_by_rtz
                ^<-- (dividend, divisor));
            rtz_remainder ::= (dividend - (divisor * rtz_quotient));

            <-- rtz_remainder = 0 ?? rtz_quotient !! e3;
        );

        e3 ::?= 'This is the case where the divisor does not divide the'
            ' dividend evenly and the real number division result would'
            ' have a fractional part, so we decide how to round that.';

        e3 ::= (
            rti_quotient ::= (rtz_quotient + (real_q_is_neg ?? -1 !! 1));
            rdn_quotient ::= (rtz_quotient + (real_q_is_neg ?? -1 !! 0));
            rup_quotient ::= (rtz_quotient + (real_q_is_neg ??  0 !! 1));

            <-- round_meth ??? {
                Down::()    : rdn_quotient,
                Up::()      : rup_quotient,
                To_Zero::() : rtz_quotient,
                To_Inf::()  : rti_quotient,
            } !!!
                   (2 * abs::(rtz_remainder)) < abs::(divisor) ?? rtz_quotient
                !! (2 * abs::(rtz_remainder)) > abs::(divisor) ?? rti_quotient
                !! e4
            ;
        );

        e4 ::?= 'This is the case where real division remainder is'
            ' exactly one-half so we decide how to round that.';

        e4 ::= (
            q ::= (FDN__Integer_divided_by_rtz ^<-- (abs::(rtz_quotient),2))
            r ::= (abs::(rtz_quotient) - (2 * q));
            rtz_quotient_is_even ::= (r = 0);

            <-- round_meth ??? {
                Half_Down::()    : rdn_quotient,
                Half_Up::()      : rup_quotient,
                Half_To_Zero::() : rtz_quotient,
                Half_To_Inf::()  : rti_quotient,
                Half_Even::()    :
                  (rtz_quotient_is_even ?? rtz_quotient !! rti_quotient),
                Half_Odd::()     :
                  (rtz_quotient_is_even ?? rti_quotient !! rtz_quotient),
            } !!! fail  `oops, an unhandled case`
        );
    );

The function C<integral_divided_by::Integer> implements the C<Numerical>
virtual function C<integral_divided_by> aka C<div> for the composing type
C<Integer>.

=head2 integral_power (Integer)

    ::MD::integral_power::Integer ::= function
        --> {Fraction, Excuse::Zero_To_The_Zero} <-- (Integer, Integer)
        implements 2::""
        : (if \<0 = 0 and \<1 = 0 then Excuse::Zero_To_The_Zero()
            else \<0 / 1 ** \<1);

The function C<integral_power::Integer> implements the C<Numerical> virtual
function C<integral_power> aka C<**> for the composing type C<Integer>.

=head2 integral_nn_power (Integer)

    ::MD::integral_nn_power::Integer ::= function
        --> {Integer, Excuse::Zero_To_The_Zero} <-- (Integer, Integer_NN)
        implements 2::""
        : (if \<0 = 0 and \<1 = 0 then Excuse::Zero_To_The_Zero()
            else \<*args -->^ FDN__Integer_nn_power);

The function C<integral_nn_power::Integer> implements the C<Numerical>
virtual function C<integral_nn_power> aka C<power> for the composing type
C<Integer>.

=head2 to_Integer (Integer)

    ::MD::to_Integer::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (\<0);

The function C<to_Integer::Integer> simply results in its C<0> argument.
This function implements the C<Integral> virtual function C<to_Integer> for
the composing type C<Integer>.

=head2 factorial (Integer)

    ::MD::factorial::Integer ::= function --> Integer_P <-- (Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Integer_factorial);

The function C<factorial::Integer> implements the C<Integral> virtual
function C<factorial> for the composing type C<Integer>.

=head1 FRACTIONAL DATA TYPES

=head2 Fractional

    ::MD::Fractional ::= interface
        composes {Orderable and_provides_its_default,
            Numerical and_provides_its_default}
        requires_implements {in_order
            ,to_Boolean
            ,zero,opposite,reciprocal,modulus
            ,plus,minus,times,multiple_of
            ,fractional_divided_by,integral_divided_by
            ,integral_power,integral_nn_power
            ,to_Fraction,numerator,denominator};

The interface contract C<Fractional> is infinite.  A C<Fractional> value
either is a rational exact numeric of some kind, expressible as a coprime
I<numerator> / I<denominator> pair of C<Integral> whose I<denominator> is
positive, or is something that can act as such.  Idiomatically a
C<Fractional> is a pure rational number which does not represent any kind
of thing in particular, neither cardinal nor ordinal nor nominal; however
some types which do represent such a particular kind of thing may choose to
compose C<Fractional> because it makes sense to provide its operators.  The
default value of C<Fractional> is the C<Fraction> value C<0.0>.
C<Fractional> is C<Orderable>; for each type composing C<Fractional>, a
value closer to negative infinity is ordered before a value closer to
positive infinity.  In the general case it is not C<Bicessable> nor does it
have a minimum or maximum value, but sometimes a type that is C<Fractional>
will have either of those.  C<Fractional> is composed by C<Fraction>.

=head2 Fractional_NN

    ::MD::Fractional_NN ::= selection of Fractional
        where (\<0 >= zero::(\<0));

The selection contract C<Fractional_NN> represents the infinite type
consisting just of the C<Fractional> values that are non-negative.  Its
default and minmum value is C<0.0>; it has no maximum value.

=head2 to_Fraction

    ::MD::to_Fraction::"" ::= function virtual --> Fraction <-- (Fractional);

The virtual function C<to_Fraction> results in the C<Fraction> value that
represents the same rational value as its C<0> argument.  The purpose of
C<to_Fraction> is to canonicalize C<Fractional> values so they can be
compared abstractly as rationals, or so that it is easier to do exact math
with rationals without running afoul of possible range limits of fixed-size
C<Fractional> types, just dealing with the latter for storage.

=head2 numerator

    ::MD::numerator::"" ::= function virtual --> Integral <-- (Fractional);

The virtual function C<numerator> results in the I<numerator> of its
C<0> argument, when the latter is expressed as a coprime I<numerator> /
I<denominator> pair of C<Integral> whose I<denominator> is positive.

=head2 denominator

    ::MD::denominator::"" ::= function virtual --> Integral_P <-- (Fractional);

The virtual function C<denominator> results in the I<denominator> of its
C<0> argument, when the latter is expressed as a coprime I<numerator> /
I<denominator> pair of C<Integral> whose I<denominator> is positive.

=head1 FRACTION DATA TYPES

=head2 Fraction

    ::MD::Fraction ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Fraction, \1::_Asset() ))
            default (0.0)
            composes Fractional and_provides_its_default;

        _Asset ::= selection of Tuple where
        (
            if
                \<0 has_just_attrs (
                    numerator : \Integer::(),
                    denominator : \Integer_P::(),
                )
            then
                \<<numerator coprime \<<denominator
            else
                False
        );
    };

The selection contract C<Fraction> is infinite.  A
C<Fraction> value is a general purpose exact rational number of any
magnitude and precision, expressible as a coprime
I<numerator> / I<denominator> pair of C<Integer> whose I<denominator> is
positive, which explicitly does not represent any kind of thing in
particular, neither cardinal nor ordinal nor nominal.  Its default value is
C<0.0>.  C<Fraction> is C<Orderable>; it has no minimum or maximum value.
Other programming languages may name their corresponding types I<BigRat>.

=head2 Fraction_NN

    ::MD::Fraction_NN ::= selection of Fraction where (\<0 >= 0.0);

The selection contract C<Fraction_NN> represents the infinite type
consisting just of the C<Fraction> values that are non-negative.  Its
default and minmum value is C<0.0>; it has no maximum value.

=head2 in_order (Fraction)

    ::MD::in_order::Fraction ::= function --> Boolean <-- (Fraction, Fraction)
        implements 2::""
    : (
        <-- (\<0->denominator) = (\<1->denominator)
            ?? in_order::(\<0->numerator, \<1->numerator)
         !!
          (
            common_d ::= lcm::(\<0->denominator, \<1->denominator);
            <-- in_order::(
                (\<0->numerator) * div::(common_d, \<0->denominator, To_Zero::()),
                (\<1->numerator) * div::(common_d, \<1->denominator, To_Zero::()),
            );
          )
    );

The function C<in_order::Fraction> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Fraction>.

=head2 to_Boolean (Fraction)

    ::MD::to_Boolean::Fraction ::= function --> Boolean <-- (Fraction)
        implements 2::""
        : (\<0 != 0.0);

The function C<to_Boolean::Fraction> results in C<True> iff its C<0>
argument is not C<0.0>, and in C<False> if it is C<0.0>.  This function
implements the C<Boolable> virtual function C<to_Boolean> aka C<so> aka
C<?> for the composing type C<Fraction>.

=head2 zero (Fraction)

    ::MD::zero::Fraction ::= function --> Fraction <-- (Fraction)
        implements 2::""
        : (0.0);

The function C<zero::Fraction> simply results in C<0.0>.  This function
implements the C<Numerical> virtual function C<zero> for the composing type
C<Fraction>.

=head2 opposite (Fraction)

    ::MD::opposite::Fraction ::= function --> Fraction <-- (Fraction)
        implements 2::""
        : (-(\<0->numerator) / (\<0->denominator));

The function C<opposite::Fraction> implements the C<Numerical> virtual
function C<opposite> aka C<additive_inverse> aka unary C<-> aka unary C<−>
for the composing type C<Fraction>.

=head2 reciprocal (Fraction)

    ::MD::reciprocal::Fraction ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Fraction)
        implements 2::""
        : (if \<0 = 0.0 then Excuse::Div_By_Zero()
            else (\<0->denominator) / (\<0->numerator));

The function C<reciprocal::Fraction> implements the C<Numerical> virtual
function C<reciprocal> aka C<multiplicative_inverse> for the composing type
C<Fraction>.

=head2 modulus (Fraction)

    ::MD::modulus::Fraction ::= function --> Fraction_NN <-- (Fraction)
        implements 2::""
        : (abs::(\<0->numerator) / (\<0->denominator));

The function C<modulus::Fraction> implements the C<Numerical>
virtual function C<modulus> aka C<abs> for the composing type C<Fraction>.

=head2 plus (Fraction)

    ::MD::plus::Fraction ::= function --> Fraction <-- (Fraction, Fraction)
        implements 2::""
        is {associative,commutative} identity (0.0)
        repeater times::Fraction_Integer
    : (
        <-- (\<0->denominator) = (\<1->denominator)
            ?? (\<0->numerator) + (\<1->numerator) / (\<0->denominator)
         !!
          (
            common_d ::= lcm::(\<0->denominator, \<1->denominator);
            <-- ((\<0->numerator) * div::(common_d, \<0->denominator, To_Zero::()))
                + ((\<1->numerator) * div::(common_d, \<1->denominator, To_Zero::()))
                / common_d;
          )
    );

The function C<plus::Fraction> implements the C<Numerical>
virtual function C<plus> aka C<+> for the composing type C<Fraction>.

=head2 minus (Fraction)

    ::MD::minus::Fraction ::= function --> Fraction <-- (Fraction, Fraction)
        implements 2::""
        : (\<0 + (-\<1));

The function C<minus::Fraction> implements the C<Numerical> virtual function
C<minus> aka binary C<-> aka binary C<−> for the composing type C<Fraction>.

=head2 times (Fraction)

    ::MD::times::Fraction ::= function --> Fraction <-- (Fraction, Fraction)
        implements 2::""
        is {associative,commutative} identity (1.0)
        repeater integral_nn_power::Fraction
        : (((\<0->numerator) * (\<1->numerator))
            / ((\<0->denominator) * (\<1->denominator)));

The function C<times::Fraction> implements the C<Numerical> virtual function
C<times> aka C<*> aka C<×> for the composing type C<Fraction>.

=head2 times (Fraction, Integer)

    ::MD::times::Fraction_Integer ::= function
        --> Fraction <-- (Fraction, Integer)
        implements 2::""
        : (((\<0->numerator) * \<1) / (\<0->denominator));

The function C<times::Fraction_Integer> implements the C<Numerical> virtual
function C<times> aka C<*> aka C<×> for the composing type C<Fraction>,
specifically for multiplying one by an C<Integer>.

=head2 multiple_of (Fraction)

    ::MD::multiple_of::Fraction ::= function
        --> {Boolean, Excuse::Div_By_Zero} <-- (Fraction, Fraction)
        implements 2::""
        : (if \<1 = 0.0 then Excuse::Div_By_Zero()
            else \mod::() <-- \<*args = 0.0);

The function C<multiple_of::Fraction> implements the C<Numerical>
virtual function C<multiple_of> for the composing type C<Fraction>.

=head2 fractional_divided_by (Fraction)

    ::MD::fractional_divided_by::Fraction ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Fraction, Fraction)
        implements 2::""
        : (if \<1 = 0.0 then Excuse::Div_By_Zero()
            else \<0 * reciprocal::(\<1));

The function C<fractional_divided_by::Fraction> implements the C<Numerical>
virtual function C<fractional_divided_by> aka C</> aka C<÷> aka C<∕> for
the composing type C<Fraction>.

=head2 integral_divided_by (Fraction)

    ::MD::integral_divided_by::Fraction ::= function
        --> {Fraction, Excuse::Div_By_Zero}
        <-- (Fraction, Fraction, Round_Meth)
        implements 2::""
    : (
        d ::= lcm::(\<0->denominator, \<1->denominator);
        n0 ::= ((\<0->numerator) * div::(d, \<0->denominator, To_Zero::()));
        n1 ::= ((\<1->numerator) * div::(d, \<1->denominator, To_Zero::()));
        <-- if \<1 = 0.0 then Excuse::Div_By_Zero()
            else div::(n0 * d, n1 * d, \<2) / 1;
    );

The function C<integral_divided_by::Fraction> implements the C<Numerical>
virtual function C<integral_divided_by> aka C<div> for the composing type
C<Fraction>.

=head2 integral_power (Fraction)

    ::MD::integral_power::Fraction ::= function
        --> {Fraction, Excuse::Zero_To_The_Zero} <-- (Fraction, Integer)
        implements 2::""
        : (\integral_nn_power::()
            <-- (\<1 >= 0 ?? \<*args !! (reciprocal::(\<0), -\<1)));

The function C<integral_power::Fraction> implements the C<Numerical> virtual
function C<integral_power> aka C<**> for the composing type C<Fraction>.

=head2 integral_nn_power (Fraction)

    ::MD::integral_nn_power::Fraction ::= function
        --> {Fraction, Excuse::Zero_To_The_Zero} <-- (Fraction, Integer_NN)
        implements 2::""
        : (if \<0 = 0.0 and \<1 = 0 then Excuse::Zero_To_The_Zero()
            else ((\<0->numerator) ** \<1) / ((\<0->denominator) ** \<1));

The function C<integral_nn_power::Fraction> implements the C<Numerical>
virtual function C<integral_nn_power> aka C<power> for the composing type
C<Fraction>.

=head2 to_Fraction (Fraction)

    ::MD::to_Fraction::Fraction ::= function --> Fraction <-- (Fraction)
        implements 2::""
        : (\<0);

The function C<to_Fraction::Fraction> simply results in its C<0> argument.
This function implements the C<Fractional> virtual function C<to_Fraction>
for the composing type C<Fraction>.

=head2 numerator (Fraction)

    ::MD::numerator::Fraction ::= function --> Integer <-- (Fraction)
        : (unwrap::(\<0).\numerator);

The function C<numerator::Fraction> implements the C<Fractional> virtual
function C<numerator> for the composing type C<Fraction>.

=head2 denominator (Fraction)

    ::MD::denominator::Fraction ::= function --> Integer_P <-- (Fraction)
        : (unwrap::(\<0).\denominator);

The function C<denominator::Fraction> implements the C<Fractional> virtual
function C<denominator> for the composing type C<Fraction>.

=head1 EMPTYABLE DATA TYPES

=head2 Emptyable

    ::MD::Emptyable ::= interface
        composes Boolable
        requires_implements {to_Boolean,empty};

The interface contract C<Emptyable> is infinite.  An C<Emptyable> value is
an aggregate C<Boolable> value that can have either zero or more than zero
components.  The primary reason for C<Emptyable> is to provide easy
consistent and terse ways to ask if an aggregate has any values, or to ask
for the value with no members of the same type as a given aggregate value.
The default value of C<Emptyable> is the C<Bits> value with zero members.

C<Emptyable> is composed, directly or indirectly, by: C<Stringy>, C<Bits>,
C<Blob>, C<Textual>, C<Text>, C<Homogeneous>, C<Unionable>, C<Discrete>,
C<Positional>, C<Array>, C<String>, C<Set>, C<Bag>, C<Relational>,
C<Tuple_Array>, C<Relation>, C<Tuple_Bag>, C<Intervalish>, C<Interval>,
C<Unionable_Intervalish>, C<Interval_Set>, C<Interval_Bag>.

=head2 Excuse::No_Empty_Value

    ::MD::Excuse::No_Empty_Value ::= constant composes Excuse;

The constant C<Excuse::No_Empty_Value> represents the I<undefined> result
of attempting to request the value with zero members of some collection
type that doesn't have a value with zero members.

=head2 to_Boolean (Emptyable) has_any_members

    ::MD::to_Boolean::Emptyable ::= function virtual --> Boolean <-- (Emptyable)
        implements 2::"";

    ::MD::has_any_members ::= alias of to_Boolean::Emptyable;

The virtual function C<to_Boolean::Emptyable> aka C<has_any_members>
results in C<True> iff its C<0> argument has any members, and in C<False>
iff it has no members.  This function implements the C<Boolable> virtual
function C<to_Boolean> aka C<so> aka C<?> for the composing type
C<Emptyable>.

=head2 is_empty ∅?

    ::MD::is_empty ::= function negates to_Boolean::Emptyable;

    ::MD::Unicode_Aliases::"∅?" ::= alias of is_empty;

The function C<is_empty> aka C<∅?> results in C<True> iff its C<0> argument
has no members, and in C<False> iff it has any members.
Other programming languages may name their corresponding operators I<empty?>.

=head2 empty ∅

    ::MD::empty::"" ::= function virtual
        --> {Emptyable, Excuse::No_Empty_Value} <-- (Emptyable);

    ::MD::Unicode_Aliases::"∅" ::= alias of empty;

The virtual function C<empty> aka C<∅> results in the value of its C<0>
argument's collection type that has zero members.  For many types like
C<Text> or C<Set>, this is a constant value, but for types like C<Relation>
or C<Tuple_Bag>, there is a distinct result for each distinct I<heading>.
Other programming languages may name their corresponding operators I<clear>.

=head1 STRINGY DATA TYPES

=head2 Stringy

    ::MD::Stringy ::= interface
        composes {Orderable, Emptyable and_provides_its_default}
        requires_implements {in_order,to_Boolean,empty
            ,substring_of,overlaps_string,disjoint_string
            ,catenate,replicate};

The interface contract C<Stringy> is infinite.  A C<Stringy> value is a
homogeneous ordered aggregate of other values such that there may not
necessarily be any single best interpretation of where each component value
begins or ends, and as such the only generic interpretation of a C<Stringy>
value is that it is a sequence of smaller C<Stringy> values of the same
type.  Idiomatically a C<Stringy> type has opaque values that each
represent something specific, such as a sequence of bits or of octets or of
characters of some repertoire; that being said, by way of C<Positional>,
some C<Stringy> types are in fact generic collections whose elements don't
represent something specific.  The general case of a C<Stringy> type has
operators for catenating or splitting C<Stringy> values, but it has no
generic concept of counting or addressing individual members of the
aggregate, with the lone special case exception that a count of zero can be
distinguished from a count of more than zero.  Addressing or counting
individual members can only be done properly in a composing type-specific
way, and often a single composing type may provide multiple ways, such as
character string types offering both codepoint and grapheme
representations.  The default value of C<Stringy> is the C<Bits> value with
zero members.  C<Stringy> expects every one of its composing types to be
orderable (but that some C<Positional> are only conditionally so), and
idiomatically that is done by some kind of pairwise comparison of members.

C<Stringy> is composed, directly or indirectly, by: C<Bits>, C<Blob>,
C<Textual>, C<Text>, C<Positional>, C<Array>, C<String>, C<Tuple_Array>.

=head2 substring_of

    ::MD::substring_of::"" ::= function virtual
        --> Boolean <-- (Stringy, Stringy);

The virtual function C<substring_of> results in C<True> iff the sequence of
members of its C<0> argument is a substring of the sequence of members of
its C<1> argument; otherwise it results in C<False>.  Other programming
languages may name their corresponding operators I<in>.

=head2 superstring_of

    ::MD::superstring_of ::= function commutes substring_of;

The function C<superstring_of> results in C<True> iff the sequence of
members of its C<0> argument is a superstring of the sequence of members of
its C<1> argument; otherwise it results in C<False>.  Other programming
languages may name their corresponding operators I<contains> or
I<include?>; some of them instead provide more generalized pattern
searching operators such as I<like> or I<~~> or I<=~>; some of them also
provide operators that result in an ordinal position or nonmatch indicator
rather than a boolean.

=head2 proper_substring_or_superstring

    ::MD::proper_substring_or_superstring ::= function
        --> Boolean <-- (String, String)
        is commutative
        : (\<*args --> \not_same::() and \<*args --> \substring_or_superstring::());

The function C<proper_substring_or_superstring> results in C<True> iff the
sequence of members of one of its 2 arguments C<0> and C<1> is a proper
substring of the sequence of members of its other argument; otherwise it
results in C<False>.

=head2 substring_or_superstring

    ::MD::substring_or_superstring ::= function
        --> Boolean <-- (String, String)
        is commutative
        : (\<*args --> \substring_of::() or \<*args --> \superstring_of::());

The function C<substring_or_superstring> results in C<True> iff the
sequence of members of one of its 2 arguments C<0> and C<1> is a substring
of the sequence of members of its other argument; otherwise it results in
C<False>.

=head2 overlaps_string

    ::MD::overlaps_string::"" ::= function virtual
        --> Boolean <-- (String, String)
        is commutative;

The virtual function C<overlaps_string> results in C<True> iff, given I<X>
as the sequence of members of its argument C<0> and I<Y> as the sequence of
members of its argument C<1>, when I<X> and I<Y> are overlapped to the
greatest possible extent such that every corresponding member pair has 2 of
the same value, the overlap of I<X> and I<Y> has at least 1 member, and
each of I<X> and I<Y> has at least 1 member that is not overlapped;
otherwise it results in C<False>.

=head2 disjoint_string

    ::MD::disjoint_string::"" ::= function virtual
        --> Boolean <-- (String, String)
        is commutative;

The virtual function C<disjoint_string> results in C<True> iff the sequence
of members of its C<0> argument can not be overlapped with the sequence of
members of its C<1> argument by at least 1 member such that every
corresponding member pair has 2 of the same value; otherwise it results in
C<False>.

=head2 catenate ~

    ::MD::catenate::"" ::= function virtual
        --> Stringy <-- (Stringy, Stringy)
        is associative
        repeater replicate;

    ::MD::"~" ::= alias of catenate;

The virtual function C<catenate> aka C<~> results in the catenation of its
2 arguments C<0> and C<1> such that the result starts with the members of
C<0> and ends with the members of C<1>, the members from both in the same
order as in their respective arguments.  This operation has an identity
value of a collection with zero members.  Other programming languages may
name their corresponding operators I<concat> or I<||> or I<+> or I<.> or
I<strcat> or I<join>; some of them also have string interpolation syntax
which logically does the same thing without an explicit operator.

=head2 replicate ~#

    ::MD::replicate::"" ::= function virtual
        --> Stringy <-- (Stringy, Integer_NN);

    ::MD::"~#" ::= alias of replicate;

The virtual function C<replicate> aka C<~#> results in the catenation of N
instances of its C<0> argument where N is defined by its C<1> argument.  If
the C<1> argument is zero then the result is the value of the C<0>
argument's collection type that has zero members.  Other programming
languages may name their corresponding operators I<x>.

=head1 BITS DATA TYPES

=head2 Bits

    ::MD::Bits ::= ::= selection of Capsule
        where (has_wrapped::( \<0, \Bits, \String::Bits() ))
        default (\~?'')
        composes {Stringy and_provides_its_default};

The selection contract C<Bits> is infinite.  A C<Bits> value is an
arbitrarily-long sequence of I<bits> where each bit is represented by
an C<Integer> in the range 0..1.  The default value of C<Bits> is
C<\~?''> (the empty bit string).  C<Bits> is C<Orderable>; its minimum
value is the same C<\~?''> as its default value; it has no maximum value;
its ordering algorithm corresponds directly to that of C<String>, pairwise
as integer sequences.  Other programming languages may name their
corresponding types I<bit> or I<bit varying>.

=head2 String::Bits

    ::MD::String::Bits ::= selection of String
        where (\<0 all (function : (\<0 in 0..1)));

The selection contract C<String::Bits> represents the infinite type
consisting just of the C<String> values for which every one of their member
integers is in the range 0..1 inclusive.

=head2 in_order (Bits)

    ::MD::in_order::Bits ::= function --> Boolean <-- (Bits, Bits)
        implements 2::""
        : ((\<0->Bits_to_String_Bits) in_order (\<1->Bits_to_String_Bits));

The function C<in_order::Bits> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Bits>.

=head2 to_Boolean (Bits)

    ::MD::to_Boolean::Bits ::= function --> Boolean <-- (Bits)
        implements 2::""
        : (\<0 != \~?'');

The function C<to_Boolean::Bits> results in C<True> iff its C<0> argument
is not C<\~?''>, and in C<False> if it is C<\~?''>.  This function
implements the C<Boolable> virtual function C<to_Boolean> aka C<so> aka
C<?> for the composing type C<Bits>.

=head2 empty (Bits)

    ::MD::empty::Bits ::= function --> Bits <-- (Bits)
        implements 2::""
        : (\~?'');

The function C<empty::Bits> simply results in C<\~?''>.  This function
implements the C<Emptyable> virtual function C<empty> for the composing
type C<Bits>.

=head2 substring_of (Bits)

    ::MD::substring_of::Bits ::= function --> Boolean <-- (Bits, Bits)
        implements 2::""
        : ((\<0->Bits_to_String_Bits) substring_of (\<1->Bits_to_String_Bits));

The function C<substring_of::Bits> implements the C<Stringy> virtual
function C<substring_of> for the composing type C<Bits>.

=head2 overlaps_string (Bits)

    ::MD::overlaps_string::Bits ::= function --> Boolean <-- (Bits, Bits)
        implements 2::""
        is commutative
        : ((\<0->Bits_to_String_Bits)
            overlaps_string (\<1->Bits_to_String_Bits));

The function C<overlaps_string::Bits> implements the C<Stringy> virtual
function C<overlaps_string> for the composing type C<Bits>.

=head2 disjoint_string (Bits)

    ::MD::disjoint_string::Bits ::= function --> Boolean <-- (Bits, Bits)
        implements 2::""
        is commutative
        : ((\<0->Bits_to_String_Bits)
            disjoint_string (\<1->Bits_to_String_Bits));

The function C<disjoint_string::Bits> implements the C<Stringy> virtual
function C<disjoint_string> for the composing type C<Bits>.

=head2 catenate (Bits)

    ::MD::catenate::Bits ::= function --> Bits <-- (Bits, Bits)
        implements 2::""
        is associative identity (\~?'')
        repeater replicate::Bits
        : (Bits_from_String_Bits::((\<0->Bits_to_String_Bits)
            ~ (\<1->Bits_to_String_Bits)));

The function C<catenate::Bits> implements the C<Stringy> virtual function
C<catenate> aka C<~> for the composing type C<Bits>.

=head2 replicate (Bits)

    ::MD::replicate::Bits ::= function --> Bits <-- (Bits, Integer_NN)
        implements 2::""
        : (Bits_from_String_Bits::((\<0->Bits_to_String_Bits) ~# \<1));

The function C<replicate::Bits> implements the C<Stringy> virtual function
C<replicate> aka C<~#> for the composing type C<Bits>.

=head2 Bits_from_String_Bits

    ::MD::Bits_from_String_Bits ::= function --> Bits <-- (String::Bits)
        : (\Bits wrap \<0);

The function C<Bits_from_String_Bits> results in the C<Bits> value selected
in terms of the integer sequence of its C<0> argument.

=head2 Bits_to_String_Bits

    ::MD::Bits_to_String_Bits ::= function --> String::Bits <-- (Bits)
        : (\<0->unwrap);

The function C<Bits_to_String_Bits> results in an integer sequence defining
the bits of its C<Bits>-typed C<0> argument.

=head1 BLOB DATA TYPES

=head2 Blob

    ::MD::Blob::"" ::= selection of Capsule
        where (has_wrapped::( \<0, \Blob, \String::Octets() ))
        default (\~+'')
        composes Stringy;

The selection contract C<Blob> is infinite.  A C<Blob> value is an
arbitrarily-long sequence of I<octets> where each octet is represented by
an C<Integer> in the range 0..255.  The default value of C<Blob> is
C<\~+''> (the empty octet string).  C<Blob> is C<Orderable>; its minimum
value is the same C<\~+''> as its default value; it has no maximum value;
its ordering algorithm corresponds directly to that of C<String>, pairwise
as integer sequences.  Other programming languages may name their
corresponding types I<Buf> or I<byte[]> or I<bytea>.

=head2 String::Octets

    ::MD::String::Octets ::= selection of String
        where (\<0 all (function : (\<0 in 0..255)));

The selection contract C<String::Octets> represents the infinite type
consisting just of the C<String> values for which every one of their member
integers is in the range 0..255 inclusive.

=head2 in_order (Blob)

    ::MD::in_order::Blob ::= function --> Boolean <-- (Blob, Blob)
        implements 2::""
        : ((\<0->Blob_to_Octets) in_order (\<1->Blob_to_Octets));

The function C<in_order::Blob> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Blob>.

=head2 to_Boolean (Blob)

    ::MD::to_Boolean::Blob ::= function --> Boolean <-- (Blob)
        implements 2::""
        : (\<0 != \~+'');

The function C<to_Boolean::Blob> results in C<True> iff its C<0> argument
is not C<\~+''>, and in C<False> if it is C<\~+''>.  This function
implements the C<Boolable> virtual function C<to_Boolean> aka C<so> aka
C<?> for the composing type C<Blob>.

=head2 empty (Blob)

    ::MD::empty::Blob ::= function --> Blob <-- (Blob)
        implements 2::""
        : (\~+'');

The function C<empty::Blob> simply results in C<\~+''>.  This function
implements the C<Emptyable> virtual function C<empty> for the composing
type C<Blob>.

=head2 substring_of (Blob)

    ::MD::substring_of::Blob ::= function --> Boolean <-- (Blob, Blob)
        implements 2::""
        : ((\<0->Blob_to_Octets) substring_of (\<1->Blob_to_Octets));

The function C<substring_of::Blob> implements the C<Stringy> virtual
function C<substring_of> for the composing type C<Blob>.

=head2 overlaps_string (Blob)

    ::MD::overlaps_string::Blob ::= function --> Boolean <-- (Blob, Blob)
        implements 2::""
        is commutative
        : ((\<0->Blob_to_Octets) overlaps_string (\<1->Blob_to_Octets));

The function C<overlaps_string::Blob> implements the C<Stringy> virtual
function C<overlaps_string> for the composing type C<Blob>.

=head2 disjoint_string (Blob)

    ::MD::disjoint_string::Blob ::= function --> Boolean <-- (Blob, Blob)
        implements 2::""
        is commutative
        : ((\<0->Blob_to_Octets) disjoint_string (\<1->Blob_to_Octets));

The function C<disjoint_string::Blob> implements the C<Stringy> virtual
function C<disjoint_string> for the composing type C<Blob>.

=head2 catenate (Blob)

    ::MD::catenate::Blob ::= function --> Blob <-- (Blob, Blob)
        implements 2::""
        is associative identity (\~+'')
        repeater replicate::Blob
        : (Blob_from_Octets::((\<0->Blob_to_Octets) ~ (\<1->Blob_to_Octets)));

The function C<catenate::Blob> implements the C<Stringy> virtual function
C<catenate> aka C<~> for the composing type C<Blob>.

=head2 replicate (Blob)

    ::MD::replicate::Blob ::= function --> Blob <-- (Blob, Integer_NN)
        implements 2::""
        : (Blob_from_Octets::((\<0->Blob_to_Octets) ~# \<1));

The function C<replicate::Blob> implements the C<Stringy> virtual function
C<replicate> aka C<~#> for the composing type C<Blob>.

=head2 Blob_from_Octets

    ::MD::Blob_from_Octets ::= function --> Blob <-- (String::Octets)
        : (\Blob wrap \<0);

The function C<Blob_from_Octets> results in the C<Blob> value selected in
terms of the integer sequence of its C<0> argument.

=head2 Blob_to_Octets

    ::MD::Blob_to_Octets ::= function --> String::Octets <-- (Blob)
        : (\<0->unwrap);

The function C<Blob_to_Octets> results in an integer sequence defining the
octets of its C<Blob>-typed C<0> argument.

=head1 TEXTUAL DATA TYPES

=head2 Textual

    ::MD::Textual ::= interface
        composes Stringy
        requires_implements {in_order,to_Boolean,empty
            ,substring_of,overlaps_string,disjoint_string
            ,catenate,replicate
            ,to_Text};

The interface contract C<Textual> is infinite.  A C<Textual> value is a
C<Stringy> value which is explicitly a sequence of characters of some
repertoire, typically Unicode or a subset thereof such as ASCII.  Note that
the C<Core> package has no concept of a I<single character> value in the
abstract sense that some programming languages do; the closest analogy is a
C<Stringy> value that just contains either one codepoint or grapheme or
similar concept; this is something in common with the Perl 6 language.

C<Textual> is composed by C<Text>, which implements C<Orderable> using the
simple culture-agnostic method of ordering codepoints numerically.
Idiomatically each culture-specific text collation method will have its own
distinct C<Textual>-composing type that implements C<Orderable> in its own
way, so the latter's operators will just work like users expect.

The C<Core> package excludes the majority of useful operators specific to
working with character strings; see instead other Muldis D packages such as
L<Core::Text|Muldis::D::Package::Core::Text> for these things.  Such tasks
include like case folding, pattern matching, whitespace trimming, Unicode
normalization, encoding to and decoding from most binary formats, and so on.

Muldis D is designed expressly to avoid mandatory external dependencies of
large complexity, such as most of the details of Unicode, in contrast with
a lot of the more modern languages of its time.  The Muldis D Foundation
and C<Core> package are strictly limited in their knowledge of Unicode;
they know that a codepoint of the Unicode repertoire is just in the integer
range C<0..0x10FFFF>, and that the leading subset C<0..127> is also 7-bit
ASCII, and they know how to read and write the fairly simple and stable
C<UTF-8> binary encoding for Unicode text, which is a proper superset of
7-bit ASCII encoding and is CPU endian-agnostic.  In contrast, anything to
do with knowing what abstract characters exist, and their various
properties (upper or lowercase, combining or not, etc), anything to do with
normalization or folding or pattern matching, and anything to do with other
binary encodings or character repertoires especially endian-specific, this
is all expressly I<not> part of the language core.  A
Muldis D implementation can choose whether or not to support them, allowing
for a lower barrier to entry.  Unicode in particular requires a vast
knowledge base to work properly with that is regularly updated, and Muldis
D has a principle that it is better to have multiple specialized components
that do their jobs well, such as handle Unicode intricacies, while the core
language can focus on other core competencies that don't involve complex
externally-defined moving targets.  The C<Core> package loosely just
considers a character string to be a sequence of generic integers and
doesn't ascribe very many distinct semantics to particular ones, while
non-C<Core> code is empowered to do that instead.

=head2 to_Text

    ::MD::to_Text::"" ::= function virtual --> Text <-- (Textual);

The virtual function C<to_Text> results in the C<Text> value that
represents the same character string value as its C<0> argument.  The
purpose of C<to_Text> is to canonicalize C<Textual> values so they can be
compared or worked with as character strings in a manner agnostic to things
like national collations or fixed-size types.

=head1 TEXT DATA TYPES

=head2 Text

    ::MD::Text::"" ::= selection of Capsule
        where (has_wrapped::( \<0, \Text, \String::Maximal_Chars() ))
        default ('')
        composes {Textual and_provides_its_default};

The selection contract C<Text> is infinite.  A C<Text> value is an
arbitrarily-long sequence of abstract I<characters> where each character is
a member of an infinite-size proprietary abstract character repertoire
named I<maximal>.  A C<Text> value is canonically defined in terms of a
C<String> value named C<Maximal_Chars>, where each member C<Integer> of the
latter represents an abstract character I<codepoint>, with each unique
integer corresponding to a unique character.  The default value of C<Text>
is C<''> (the empty character string).  C<Text> is C<Orderable>; its
minimum value is the same C<''> as its default value; it has no maximum
value; its ordering algorithm corresponds directly to that of C<String>,
pairwise as integer sequences.  Other programming languages may name their
corresponding types I<Str> or I<string> or I<varchar> or I<char>.

There are many defined character sets in the computing world that map
agreed upon sets of symbols to integers, and Muldis D is designed to be
implicitly compatible with all of them.  Officially speaking, C<Text>
values are just sequences of integers and any mapping between these
integers and commonly well-understood symbols is done externally to the
C<Text> type.  While the canonical C<Maximal_Chars> representation does
formally map symbols to integers in a well-defined way, this mapping is
proprietary, intended only for internal usage, and is subject to change
with different Muldis D versions.  All normal user interaction with the
internals of a C<Text> should just be done in terms of explicit mappings
with well-known public character sets such as 7-bit ASCII or Unicode.  As
it happens, C<Maximal_Chars> is formally a proper superset of Unicode 8.0,
itself a proper superset of 7-bit ASCII, so their corresponding codepoints
are identical, but for other character sets such as ISO Latin 1 or EBCDIC
or ISO/IEC 2022 or Mojikyo or HKSCS or others, they may not be.

=head2 String::Maximal_Chars

    ::MD::String::Maximal_Chars ::= alias of String;

The selection contract C<String::Maximal_Chars> is an alias of C<String>
which exists for convenient self-documentation of C<Text>-related code.

=head2 Text::Unicode

    ::MD::Text::Unicode ::= selection of Text
        where (String::Unicode_Codes::(\<0->Text_from_Maximal_Chars));

The selection contract C<Text::Unicode> represents the infinite type
consisting just of the C<Text> values for which every one of their member
characters is a member of the 0x10F7FF-character repertoire of Unicode.
This C<Text> subtype has is own canonical representation in terms of a
C<String> value named C<Unicode_Codes> where each member codepoint matches
the standard Unicode codepoints for the same symbols.

=head2 String::Unicode_Codes

    ::MD::String::Unicode_Codes ::= selection of String::Maximal_Chars
        where (\<0 all (function : (\<0 in ?..{0..0xD7FF,0xE000..0x10FFFF})));

The selection contract C<String::Unicode_Codes> represents the infinite type
consisting just of the C<String> values for which every one of their member
integers is in the range {0..0xD7FF,0xE000..0x10FFFF} inclusive.

=head2 Text::ASCII

    ::MD::Text::ASCII ::= selection of Text::Unicode
        where (String::ASCII_Chars::(\<0->Text_from_Unicode_Codes));

The selection contract C<Text::ASCII> represents the infinite type
consisting just of the C<Text> values for which every one of their member
characters is a member of the 128-character repertoire of 7-bit ASCII.
This C<Text> subtype has is own canonical representation in terms of a
C<String> value named C<ASCII_Chars> where each member codepoint matches
the standard ASCII codes for the same symbols.

=head2 String::ASCII_Chars

    ::MD::String::ASCII_Chars ::= selection of String::Unicode_Codes
        where (\<0 all (function : (\<0 in 0..127)));

The selection contract C<String::ASCII_Chars> represents the infinite type
consisting just of the C<String> values for which every one of their member
integers is in the range 0..127 inclusive.

=head2 in_order (Text)

    ::MD::in_order::Text ::= function --> Boolean <-- (Text, Text)
        implements 2::""
        : ((\<0->Text_to_Maximal_Chars) in_order (\<1->Text_to_Maximal_Chars));

The function C<in_order::Text> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Text>.

=head2 to_Boolean (Text)

    ::MD::to_Boolean::Text ::= function --> Boolean <-- (Text)
        implements 2::""
        : (\<0 != '');

The function C<to_Boolean::Text> results in C<True> iff its C<0> argument
is not C<''>, and in C<False> if it is C<''>.  This function implements the
C<Boolable> virtual function C<to_Boolean> aka C<so> aka C<?> for the
composing type C<Text>.

=head2 empty (Text)

    ::MD::empty::Text ::= function --> Text <-- (Text)
        implements 2::""
        : ('');

The function C<empty::Text> simply results in C<''>.  This function
implements the C<Emptyable> virtual function C<empty> for the composing
type C<Text>.

=head2 substring_of (Text)

    ::MD::substring_of::Text ::= function --> Boolean <-- (Text, Text)
        implements 2::""
        : ((\<0->Text_to_Maximal_Chars)
            substring_of (\<1->Text_to_Maximal_Chars));

The function C<substring_of::Text> implements the C<Stringy> virtual
function C<substring_of> for the composing type C<Text>.

=head2 overlaps_string (Text)

    ::MD::overlaps_string::Text ::= function --> Boolean <-- (Text, Text)
        implements 2::""
        is commutative
        : ((\<0->Text_to_Maximal_Chars)
            overlaps_string (\<1->Text_to_Maximal_Chars));

The function C<overlaps_string::Text> implements the C<Stringy> virtual
function C<overlaps_string> for the composing type C<Text>.

=head2 disjoint_string (Text)

    ::MD::disjoint_string::Text ::= function --> Boolean <-- (Text, Text)
        implements 2::""
        is commutative
        : ((\<0->Text_to_Maximal_Chars)
            disjoint_string (\<1->Text_to_Maximal_Chars));

The function C<disjoint_string::Text> implements the C<Stringy> virtual
function C<disjoint_string> for the composing type C<Text>.

=head2 catenate (Text)

    ::MD::catenate::Text ::= function --> Text <-- (Text, Text)
        implements 2::""
        is associative identity ('')
        repeater replicate::Text
        : (Text_from_Maximal_Chars::((\<0->Text_to_Maximal_Chars)
            ~ (\<1->Text_to_Maximal_Chars)));

The function C<catenate::Text> implements the C<Stringy> virtual function
C<catenate> aka C<~> for the composing type C<Text>.

=head2 replicate (Text)

    ::MD::replicate::Text ::= function --> Text <-- (Text, Integer_NN)
        implements 2::""
        : (Text_from_Maximal_Chars::((\<0->Text_to_Maximal_Chars) ~# \<1));

The function C<replicate::Text> implements the C<Stringy> virtual function
C<replicate> aka C<~#> for the composing type C<Text>.

=head2 to_Text (Text)

    ::MD::to_Text::Text ::= function --> Text <-- (Text)
        implements 2::""
        : (\<0);

The function C<to_Text::Text> simply results in its C<0> argument.
This function implements the C<Textual> virtual function C<to_Text>
for the composing type C<Text>.

=head2 Text_from_Maximal_Chars

    ::MD::Text_from_Maximal_Chars ::= function
        --> Text <-- (String::Maximal_Chars)
        : (\Text wrap \<0);

The function C<Text_from_Maximal_Chars> results in the C<Text> value
selected in terms of an integer sequence in the proprietary
C<Maximal_Chars> character mapping of its C<0> argument.

=head2 Text_to_Maximal_Chars

    ::MD::Text_to_Maximal_Chars ::= function
        --> String::Maximal_Chars <-- (Text)
        : (\<0->unwrap);

The function C<Text_to_Maximal_Chars> results in an integer sequence in the
proprietary C<Maximal_Chars> character mapping that corresponds to its
C<Text>-typed C<0> argument.

=head2 Text_from_Unicode_Codes

    ::MD::Text_from_Unicode_Codes ::= function
        --> Text::Unicode <-- (String::Unicode_Codes)
        : (\<0->Text_from_Maximal_Chars);

The function C<Text_from_Unicode_Codes> results in the C<Text> value selected
in terms of an integer sequence in the standard Unicode codepoint
mapping of its C<0> argument.

=head2 Text_to_Unicode_Codes

    ::MD::Text_to_Unicode_Codes ::= function
        --> String::Unicode_Codes <-- (Text::Unicode)
        : (\<0->Text_to_Maximal_Chars);

The function C<Text_to_Unicode_Codes> results in an integer sequence in the
standard Unicode codepoint mapping that corresponds to its
C<Text>-typed C<0> argument.

=head2 Text_from_ASCII_Chars

    ::MD::Text_from_ASCII_Chars ::= function
        --> Text::ASCII <-- (String::ASCII_Chars)
        : (\<0->Text_from_Unicode_Codes);

The function C<Text_from_ASCII_Chars> results in the C<Text> value selected
in terms of an integer sequence in the standard 7-bit ASCII character
mapping of its C<0> argument.

=head2 Text_to_ASCII_Chars

    ::MD::Text_to_ASCII_Chars ::= function
        --> String::ASCII_Chars <-- (Text::ASCII)
        : (\<0->Text_to_Unicode_Codes);

The function C<Text_to_ASCII_Chars> results in an integer sequence in the
standard 7-bit ASCII character mapping that corresponds to its
C<Text>-typed C<0> argument.

=head2 Blob_is_UTF_8

    ::MD::Blob_is_UTF_8 ::= function --> Boolean <-- (Blob)
        : (...);

I<TODO.  See also https://tools.ietf.org/html/rfc3629 for the UTF-8 definition.>

I<TODO.  Note that while the UTF-8 encoding scheme can represent all Unicode
codepoints in the range 0..0x1FFFFF with 4 octets (and all 0..0x7FFFFFFF
with 6 octets), the UTF-8 standard further restricts the range to
{0..0xD7FF,0xE000..0x10FFFF} to match the constraints of the limitations of UTF-16.>

I<TODO.  Note that we don't define a Blob::UTF_8 type as
it is superfluous with simply trying to decode one and see if it succeeded.>

=head2 Text_from_UTF_8_Blob

    ::MD::Text_from_UTF_8_Blob ::= function
        --> {Text::Unicode, Excuse::Unicode::..., ...} <-- (Blob)
        : (...);

I<TODO.  As a code/implementation comment, say the parallel design is
benefitting from the self-syncrhonizing nature that is a key feature of UTF-8.>

I<TODO.  Note, the multiple Excuse options are used to indicate the
different reasons why the Blob is not considered valid UTF-8, including
that it doesn't use the fewest bytes possible for a character, or it
represents codepoints greater than 0x10FFFF or it represents illegal
codepoints in the 0xD800..0xDFFF range of UTF-16 surrogates, or it has the
wrong number of continuation bytes following an ASCII char or starting byte
etc.  If a Blob contains multiple errors, the returned Excuse is for the
error closest to the start of the Blob; that is, chained and_then() is
used. TODO, perhaps declare a union type collecting the Unicode errors like
we have with rounding methods, or we actually may have multiple Unicode sets.>

=head2 Text_from_UTF_8_Blob_with_repl_Text

    ::MD::Text_from_UTF_8_Blob_with_repl_Text ::= function
        --> Text::Unicode <-- (Blob, Text::Unicode)
        : (...);

I<TODO.  Each invalid octet encountered is replaced by the substitution text
(which can be a single character, or several, or the empty string).  For
consistency, even if the sequence decodes fine in one sense but is an out
of range character, the instances of substitution are per count of octets
not one per character.>

=head2 Text_from_UTF_8_Blob_with_repl_char

    ::MD::Text_from_UTF_8_Blob_with_repl_char ::= function
        --> Text::Unicode <-- (Blob)
        : (Text_from_UTF_8_Blob_with_repl_Text::(\<0,'\\c<0xFFFD>'));

I<TODO.  The special Unicode char "REPLACEMENT CHARACTER" aka 0xFFFD is used.>

=head2 Text_to_UTF_8_Blob

    ::MD::Text_to_UTF_8_Blob ::= function --> Blob <-- (Text::Unicode)
        : (...);

I<TODO.  This should just work as Text::Unicode excludes the surrogate
pairs and out of range etc stuff.>

=head2 Blob_is_ASCII

    ::MD::Blob_is_ASCII ::= function --> Boolean <-- (Blob)
        : (String::ASCII_Chars(\<0->Blob_to_Octets));

I<TODO.>

=head2 Text_from_ASCII_Blob

    ::MD::Text_from_ASCII_Blob ::= function
        --> {Text::ASCII, Excuse::ASCII::High_Bit_Not_Zero} <-- (Blob)
    : (
        octets ::= \<0->Blob_to_Octets;
        <-- if String::ASCII_Chars(octets)
            then octets->Text_from_ASCII_Chars
            else Excuse::ASCII::High_Bit_Not_Zero();
    );

I<TODO.  Note, still have to define that Excuse.>

=head2 Text_from_ASCII_Blob_with_repl_Text

    ::MD::Text_from_ASCII_Blob_with_repl_Text ::= function
        --> Text::ASCII <-- (Blob, Text::ASCII)
    : (
        src_octets ::= (\<0->Blob_to_Octets);
        repl_chars ::= (\<1->Text_to_ASCII_Chars);
        result_chars ::= (
            given #repl_chars
                when 0 then
                    src_octets where (function : (\<0 in 0..127))
                when 1 then
                    src_octets
                        map (function : (\<0 in 0..127 ?? \<0 !! \<1))
                            \<-- (1 : repl_chars.0,)
                default
                    src_octets
                        map (function : (\<0 in 0..127 ?? [\<0] !! \<1))
                            \<-- (1 : repl_chars,)
                        reduce \catenate::()
        );
        <-- result_chars->Text_from_ASCII_Chars;
    );

I<TODO.  Each invalid octet encountered is replaced by the substitution text
(which can be a single character, or several, or the empty string).
Note there is no alternate with a predefined substitution char as there
is no good implicit default in ASCII, unlike with Unicode.>

=head2 Text_to_ASCII_Blob

    ::MD::Text_to_ASCII_Blob ::= function --> Blob <-- (Text::ASCII)
        : (\<0->Text_to_ASCII_Chars->Blob_from_Octets);

I<TODO.>

=head1 COLLECTIVE DATA TYPES OVERVIEW

A I<collective> value either is a generic regular aggregate of a
multiplicity of other, I<component>, values whose composition is
transparent to the user or is something that can act as such an aggregate.
The C<Core> package provides I<collective> types with a variety of
desirable alternative properties.

Some I<collective> values are fully I<discrete> and so their components can
be enumerated as individuals and counted, while other collective values are
at least partially I<continuous> and so at least some of their components
can not be enumerated or counted (the count is effectively an infinity);
however it is still possible to test the membership of a value in such a
collective.  C<Interval> is an example of a typically-continuous type while
most collective types provided by C<Core> are discrete; however, an
C<Interval> can be treated as a discrete type iff the types it ranges over
are C<Bicessable>.

Some I<collective> values are I<positional> and define an explicit total
order for their components which does not necessarily depend on any order
specific to the component values themselves, and which does not necessarily
place multiple same-valued components consecutively.  Such a collective
value can reliably and consistently enumerate its components in its defined
order, and the collective also supports integral index-based lookup of its
members where each member lives at a distinct index.  In contrast,
I<nonpositional> collective values simply track what values their
components are and don't provide index-based lookup; those that are
enumerable do not guarantee that components are returned in any particular
order.  An example positional type is C<Array> while example nonpositional
types are C<Set>, C<Bag>, C<Relation>, and C<Interval>.  Some I<positional>
types are I<sorted>, ensuring that components are organized in the
collection corresponding to a total order that is specific to the component
values themselves, meaning also that all same-valued components are
consecutive; I<nonsorted> positional types don't do this.

Some I<collective> values are I<setty>, ensuring that each of their
components is unique, while other collective values are I<baggy>,
permitting multiple components to be the same value.  Examples of setty
types are C<Set>, C<Relation>, and C<Interval>, while examples of baggy
types are C<Array> and C<Bag>.  Some setty types may silently avoid
duplicate values, where adding the same value twice has the same effect as
adding it once, while other setty types may raise an error if adding a
duplicate value is attempted.

The I<collective> types provided by the C<Core> package all speak to a
space having two orthogonal dimensions into which their components are
logically arranged, where one dimension is called I<homogeneous> and the
other dimension is called I<attributive>.  A I<collective> value's
components addressed in terms of their location along its I<homogeneous>
dimension are called I<members> of the collective, while components
addressed in terms of their location along its I<attributive> dimension are
called I<attributes>.  To be more accurate, a I<member> is a slice of the
space that includes all components with the same single location along the
homogeneous dimension, while an I<attribute> is a slice of the space that
includes all components with the same single location along the attributive
dimension; in many contexts, said slice is considered as a single value of
its own.  Every I<member> of a collective value is conceptually of a common
data type with its fellow members or should be interpreted logically in the
same way.  Every I<attribute> of a collective value is conceptually of its
own data type or should be interpreted logically in a distinct way from its
fellow attributes.

While many collective types just utilize one of the dimensions
I<homogeneous> or I<attributive>, some utilize both.  Values of the
C<Array>, C<Set>, C<Bag>, C<Interval> types each arrange their components
along just the I<homogeneous> dimension and ignore I<attributive>, so for
brevity we just say their components I<are> members.  Values of the
C<Tuple> type each arrange their components along just the I<attributive>
dimension and ignore I<homogeneous>, so for brevity we just say their
components I<are> attributes.  Values of the C<Relation> and C<Tuple_Bag>
types each arrange their components over both of the dimensions, so we say
they have both members and attributes.

Given that the I<homogeneous> and I<attributive> dimensions are to a large
extent isomorphic, and so there are a lot of corresponding operations that
apply to both, the C<Core> package uses different terminology and operator
names for corresponding things so it is clear what dimension is being acted
on.  For example, a C<Relation> value has no single concept of its
component count, rather we say I<cardinality> is a count of its members
while I<degree> is a count of its attributes.  When equally terse and
pleasant terminology isn't available for a pair of corresponding concepts,
the homogeneous dimension is given priority for the nicer API since that is
expected to be the dominant one for typical usage patterns.

See the C<Homogeneous> type which defines the common API for all collective
types utilizing the I<homogeneous> dimension, and see the C<Attributive>
type which defines the orthogonal common API for all collective types
utilizing the I<attributive> dimension.  See the C<Relational> type which
defines the common API for all collective types utilizing both dimensions.

See also the C<Accessible> type which provides an extra API that can be
applied on a type-by-type basis to either the I<homogeneous> dimension or
the I<attributive> dimension (but not both) as makes the most sense for the
composing types in question; example composers are C<Array> and C<Tuple>
respectively for said dimensions.

=head1 ACCESSIBLE DATA TYPES

=head2 Accessible

    ::MD::Accessible ::= interface
        requires_implements {has_any_at,has_mapping_at
            ,mapping_at,at,maybe_at
            ,replace_at,shiftless_insert_at,shiftless_remove_at
            ,replace_or_insert_at,shiftless_maybe_remove_at};

The interface contract C<Accessible> is infinite.  An C<Accessible> value
is an aggregate of other, I<mapping> values such that each I<mapping> is a
pair of associated other values, a I<key> and I<asset> respectively, such
that no 2 I<key> of an C<Accessible> value are the same value.  The primary
reason for C<Accessible> is to provide an easy consistent and terse
accessor API for individual components in a collection of key-asset pairs,
where the pair exists at a slot addressable by its key.  An C<Accessible>
value is isomorphic to a space in which 0..N slots can exist; possible
operations include testing if a slot exists, fetching the content of a
slot, replacing the content of a slot, inserting another slot, removing an
existing slot.  C<Accessible> does not have anything to say about other
qualities of its composers, such as on matters of enumerating components or
slicing a subset of components into a new collection, and so composers
might have little in common besides sharing certain operator names.

If an C<Accessible> value is also C<Positional>, then each of its
I<key>/I<asset> pairs is actually an I<index>/I<member> pair, and all of
its keys must be adjacent C<Integer>; therefore, since each C<Accessible>
operation may only affect 1 slot at a time, it is only valid to insert or
remove a slot at the C<first_unused_index> or C<last_index> respectively.
Other composers of C<Accessible> may have their own restrictions on
inserting or removing slots besides key uniqueness, but typically don't.

The default value of C<Accessible> is the C<Tuple> value with zero
attributes, C<()>.  C<Accessible> is composed, directly or indirectly, by:
C<Positional>, C<Array>, C<String>, C<Tuple_Array>, C<Structural>, C<Tuple>.
I<TODO: Also composed by Dictionary.>

Note that this interface contract could have as easily been mamed
I<Associative>, but it wasn't so that term could be reserved for the
C<associative> function trait which has a different meaning.

=head2 has_any_at .?

    ::MD::has_any_at::"" ::= function virtual
        --> Boolean <-- (Accessible, Any);

    ::MD::".?" ::= alias of has_any_at;

The virtual function C<has_any_at> aka C<.?> results in C<True> iff its
C<0> argument has a mapping whose key is equal to its C<1> argument;
otherwise it results in C<False>.  Other programming languages may name
their corresponding operators I<ContainsKey> or I<has_key?> or I<key?> or
I<exists> or I<in> or I<array_key_exists>.

=head2 has_mapping_at .:?

    ::MD::has_mapping_at::"" ::= function virtual
        --> Boolean <-- (Accessible, (Any, Any));

    ::MD::".:?" ::= alias of has_mapping_at;

The virtual function C<has_mapping_at> aka C<.:?> results in C<True> iff
its C<0> argument has a mapping that is equal to its C<1> argument;
otherwise it results in C<False>.  The C<1> argument is a binary C<Tuple>
whose C<0> and C<1> attributes are the mapping key and asset respectively.

=head2 mapping_at .:

    ::MD::mapping_at::"" ::= function virtual
        --> (Any, Any) <-- (Accessible, Any)
        requires (\<0 .? \<1);

    ::MD::".:" ::= alias of mapping_at;

The virtual function C<mapping_at> aka C<.:> results in a binary C<Tuple>
whose C<0> attribute is the function's C<1> argument and whose C<1>
attribute is the asset value of the mapping of its C<0> argument where that
mapping's key is equal to its C<1> argument.  Other programming languages
may name their corresponding operators I<assoc>.

=head2 at .

    ::MD::at::"" ::= function virtual --> Any <-- (Accessible, Any)
        requires (\<0 .? \<1);

    ::MD::"." ::= alias of at;

The virtual function C<at> aka C<.> results in the asset value of the
mapping of its C<0> argument where that mapping's key is equal to its C<1>
argument.  This function will fail if the C<0> argument doesn't have such a
mapping.  Other programming languages may name their corresponding
operators I<ElementAt> or I<fetch>; it is also common to use
subscript/postcircumfix syntax.

=head2 maybe_at .!

    ::MD::maybe_at::"" ::= function virtual --> Any <-- (Accessible, Any);

    ::MD::".!" ::= alias of maybe_at;

The virtual function C<maybe_at> aka C<.!> results in the asset value of
the mapping of its C<0> argument where that mapping's key is equal to its
C<1> argument, iff there is such a mapping; otherwise it results in an
C<Excuse>.  Other programming languages may name their corresponding
operators I<ElementAtOrDefault> or I<at> or I<get> or I<fetch>; it is also
common to use subscript/postcircumfix syntax.

=head2 replace_at .:=

    ::MD::replace_at::"" ::= function virtual
        --> Accessible <-- (Accessible, (Any, Any))
        requires (\<0 .? \>>0);

    ::MD::".:=" ::= alias of replace_at;

The virtual function C<replace_at> aka C<.:=> results in the value of its
C<0> argument's collection type that has all of the mappings of the
function's C<0> argument but that, for the 1 mapping of the C<0> argument
whose key I<K> is equal to the function's C<1> argument's C<0> attribute,
the result's mapping instead has an asset equal to the C<1> argument's C<1>
attribute.  This function will fail if the C<0> argument doesn't have a
mapping with the key I<K>.  Other programming languages commonly use
assignment syntax.

=head2 shiftless_insert_at .+

    ::MD::shiftless_insert_at::"" ::= function virtual
        --> Accessible <-- (Accessible, (Any, Any))
        requires (not \<0 .? \>>0);

    ::MD::".+" ::= alias of shiftless_insert_at;

The virtual function C<shiftless_insert_at> aka C<.+> results in the value
of its C<0> argument's collection type that has all of the mappings of the
function's C<0> argument plus 1 additional mapping that is equal to its
C<1> argument.  The C<1> argument is a binary C<Tuple> whose C<0> and C<1>
attributes are the mapping key and asset respectively.  This function will
fail if the C<0> argument already has a mapping with that key.  Other
programming languages may name their corresponding operators I<Add>; it is
also common to use assignment syntax.

=head2 shiftless_remove_at .-

    ::MD::shiftless_remove_at::"" ::= function virtual
        --> Accessible <-- (Accessible, Any)
        requires (\<0 .? \<1);

    ::MD::".-" ::= alias of shiftless_remove_at;

The virtual function C<shiftless_remove_at> aka C<.-> results in the value
of its C<0> argument's collection type that has all of the mappings of the
function's C<0> argument minus 1 existing mapping whose key is equal to its
C<1> argument.  This function will fail if the C<0> argument doesn't have
such a mapping.  Other programming languages may name their corresponding
operators I<del> or I<delete_at>.

=head2 replace_or_insert_at .=+

    ::MD::replace_or_insert_at::"" ::= function virtual
        --> Accessible <-- (Accessible, (Any, Any));

    ::MD::".=+" ::= alias of replace_or_insert_at;

The virtual function C<replace_or_insert_at> aka C<.=+> behaves identically
in turn to each of the functions C<replace_at> and C<shiftless_insert_at>
when given the same arguments, where the C<0> argument does or doesn't,
respectively, have a mapping whose key is equal to the C<1> argument's C<0>
attribute.  Other programming languages may name their corresponding
operators I<Item> or I<set> or I<put> or I<store> or I<update>; it is also
common to use subscript/postcircumfix syntax plus assignment syntax.

=head2 shiftless_maybe_remove_at .?-

    ::MD::shiftless_maybe_remove_at::"" ::= function virtual
        --> Accessible <-- (Accessible, Any);

    ::MD::".?-" ::= alias of shiftless_maybe_remove_at;

The virtual function C<shiftless_maybe_remove_at> aka C<.?-> behaves
identically to C<shiftless_remove_at> when given the same arguments but
that it simply results in its C<0> argument when that has no mapping whose
key matches its C<1> argument, rather than fail.  Other programming
languages may name their corresponding operators I<Remove> or I<remove> or
I<delete> or I<unset>.

=head1 HOMOGENEOUS DATA TYPES

=head2 Homogeneous

    ::MD::Homogeneous ::= interface
        composes Emptyable
        requires_implements {to_Boolean,empty
            ,singular,only_member
            ,has_n,multiplicity
            ,all_unique,unique
            ,subset_of,same_members,overlaps_members,disjoint_members
            ,any};

The interface contract C<Homogeneous> is infinite.  A C<Homogeneous> value
is a I<collective> value such that every one of its component I<members> is
conceptually of a common data type with its fellow members or should be
interpreted logically in the same way.  Idiomatically a C<Homogeneous> is a
generic collection which does not as a whole represent any kind of thing in
particular, such as a text or a graphic, and is simply the sum of its
I<members>; however some types which do represent such a particular kind of
thing may choose to compose C<Homogeneous> because it makes sense to
provide its operators.  The default value of C<Homogeneous> is the C<Array>
value with zero members, C<[]>.

If a C<Homogeneous> value is also C<Unionable>, then another value of its
collection type can be derived by either inserting new members whose values
are distinct from those already in the collection or by removing arbitrary
members from the collection; otherwise, that may not be possible.
If a C<Homogeneous> value is also C<Discrete>, all of its members can be
enumerated as individuals and counted; otherwise, that may not be possible.
If a C<Homogeneous> value is also C<Positional>, all of its members are
arranged in an explicit total order and can both be enumerated in that
order as well as be looked up by integral indexed-based position against
that order; otherwise, that may not be possible.  If a C<Homogeneous> value
is also C<Setty>, all of its members are guaranteed to be distinct values;
otherwise, duplication of values may occur amongst members.

C<Homogeneous> is composed, directly or indirectly, by: C<Unionable>,
C<Discrete>, C<Positional>, C<Array>, C<String>, C<Set>, C<Bag>,
C<Relational>, C<Tuple_Array>, C<Relation>, C<Tuple_Bag>, C<Intervalish>,
C<Interval>, C<Unionable_Intervalish>, C<Interval_Set>, C<Interval_Bag>.

I<TODO.  Note that for all the regular function-taking member-wise
Homogeneous operators that are logically supposed to work with each
collection member in isolation and/or shouldn't put significance on either
duplicate members or member position in the collection, including the likes
of {any, where, map} etc, but not including the likes of {reduce}, the
operators will only be passing the asset portion (where applicable) of the
member to the higher-order function, and not say the index-asset pair for a
Positional or the asset-count pair for a Baggy.  Note that for a Relation
or Tuple_Bag each entire Tuple is the member asset, and for a Dictionary
the pair is the asset.  (With the corresponding attribute-wise Tuple
operators, they are given the whole attribute name-value pair.)  The main
reason for this is to help ensure consistency of results while supporting a
variety of collection implementations including ones that are lazy, such as
by not eagerly counting duplicates, or that use distributed computation.
For that matter, the likes of {reduce} should probably be treated the same
way; see also the 'repeater' function trait that helps optimize it.
Surely, any time when one may think these operations need to know the
baggy count or positional index, its for a problem best solved differently.>

=head2 singular

    ::MD::singular::"" ::= function virtual --> Boolean <-- (Homogeneous);

The virtual function C<singular> results in C<True> iff its C<0> argument
has exactly 1 distinct member value, and C<False> otherwise.

=head2 only_member

    ::MD::only_member::"" ::= function virtual --> Any <-- (Homogeneous)
        requires (\<*args --> \singular::());

The virtual function C<only_member> results in its C<0> argument's only
distinct member value.  This function will fail if the argument doesn't
have exactly 1 distinct member value.  The general deterministic way to
select a single possibly-unknown member of a C<Homogeneous> value is to
first derive from the latter another C<Homogeneous> value with exactly 1
distinct member (using means such as filtering or mapping or reducing) and
then use this function on the derived one.  For types such as C<Set> or
C<Bag> one can't select a member using an index, say, like with an
C<Array>, and a general solution provided by other programming languages
for simply picking I<a> member would give an effectively random one.

I<TODO: See also the C# methods "Single" and "SingleOrDefault" etc.>

=head2 in ∈

    ::MD::in ::= function commutes has;

    ::MD::Unicode_Aliases::"∈" ::= alias of in;

The function C<in> aka C<∈> results in C<True> iff its C<0> argument is
equal to at least 1 member value of its C<1> argument; otherwise it results
in C<False>.  Note that this operation is also known as I<containment>.
Other programming languages may name their corresponding operators
I<in_array>.

=head2 not_in ∉

    ::MD::not_in ::= function commutes not_has;

    ::MD::Unicode_Aliases::"∉" ::= alias of not_in;

The function C<not_in> aka C<∉> results in C<True> iff its C<0> argument is
equal to no member value of its C<1> argument; otherwise it results in
C<False>.

=head2 has ∋

    ::MD::has ::= function --> Boolean <-- (Homogeneous, Any)
        : (has_n::(\<0, \<1, 1));

    ::MD::Unicode_Aliases::"∋" ::= alias of has;

The function C<has> aka C<∋> results in C<True> iff its C<0> argument has
at least 1 member whose value is equal to its C<1> argument; otherwise it
results in C<False>.  Other programming languages may name their
corresponding operators I<contains> or I<exists> or I<includes>.

=head2 not_has ∌

    ::MD::not_has ::= function negates has;

    ::MD::Unicode_Aliases::"∌" ::= alias of not_has;

The function C<not_has> aka C<∌> results in C<True> iff its C<0> argument
does not have any member whose value is equal to its C<1> argument;
otherwise it results in C<False>.

=head2 has_n

    ::MD::has_n::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Any, Integer_NN);

The virtual function C<has_n> results in C<True> iff its C<0> argument has
at least N members such that each is equal to its C<1> argument, where N is
defined by its C<2> argument; otherwise it results in C<False>.  The
result is always C<True> when the C<2> argument is zero.  Note that
having a C<2> argument greater than 1 in combination with a C<Setty> typed
C<0> argument will always result in C<False>.

=head2 multiplicity

    ::MD::multiplicity::"" ::= function virtual
        --> Integer_NN <-- (Homogeneous, Any);

The virtual function C<multiplicity> results in the integral count of
members of its C<0> argument such that each member value is equal to its
C<1> argument.  For a C<Setty> typed C<0> argument, the result is always
just 0 or 1.

=head2 all_unique

    ::MD::all_unique::"" ::= function virtual --> Boolean <-- (Homogeneous);

The virtual function C<all_unique> results in C<True> iff its C<0> argument
has no 2 members that are the same value, and C<False> otherwise.  The
result is always C<True> for a C<Setty> argument.

=head2 unique

    ::MD::unique::"" ::= function virtual --> Homogeneous <-- (Homogeneous);

The virtual function C<unique> results in the value of its C<0> argument's
collection type that has, for every distinct member value I<V> of the
function's C<0> argument, exactly 1 member whose value is equal to I<V>.
The result is always the same value as its argument when that is C<Setty>.
If the result's type is C<Positional>, then each retained member is the one
closest to the start of the argument out of those members sharing the
retained member's value.  See also the C<Positional> function C<squish>.

=head2 proper_subset_of ⊂

    ::MD::proper_subset_of ::= function
        --> Boolean <-- (Homogeneous, Homogeneous)
        : (\<*args --> \not_same::() and \<*args --> \subset_of::());

    ::MD::Unicode_Aliases::"⊂" ::= alias of proper_subset_of;

The function C<proper_subset_of> aka C<⊂> results in C<True> iff the
multiset of members of its C<0> argument is a proper subset of the
multiset of members of its C<1> argument; otherwise it results in C<False>.
Note that this operation is also known as I<strict multiset inclusion>.

=head2 not_proper_subset_of ⊄

    ::MD::not_proper_subset_of ::= function negates proper_subset_of;

    ::MD::Unicode_Aliases::"⊄" ::= alias of not_proper_subset_of;

The function C<not_proper_subset_of> aka C<⊄> results in C<True> iff the
multiset of members of its C<0> argument is not a proper subset of the
multiset of members of its C<1> argument; otherwise it results in C<False>.

=head2 proper_superset_of ⊃

    ::MD::proper_superset_of ::= function commutes proper_subset_of;

    ::MD::Unicode_Aliases::"⊃" ::= alias of proper_superset_of;

The function C<proper_superset_of> aka C<⊃> results in C<True> iff the
multiset of members of its C<0> argument is a proper superset of the
multiset of members of its C<1> argument; otherwise it results in C<False>.

=head2 not_proper_superset_of ⊅

    ::MD::not_proper_superset_of ::= function negates proper_superset_of;

    ::MD::Unicode_Aliases::"⊅" ::= alias of not_proper_superset_of;

The function C<not_proper_superset_of> aka C<⊅> results in C<True> iff the
multiset of members of its C<0> argument is not a proper superset of the
multiset of members of its C<1> argument; otherwise it results in C<False>.

=head2 subset_of ⊆

    ::MD::subset_of::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Homogeneous);

    ::MD::Unicode_Aliases::"⊆" ::= alias of subset_of;

The function C<subset_of> aka C<⊆> results in C<True> iff the multiset of
members of its C<0> argument is a subset of the multiset of members of
its C<1> argument; otherwise it results in C<False>.  Note that this
operation is also known as I<multiset inclusion>.

=head2 not_subset_of ⊈

    ::MD::not_subset_of ::= function negates subset_of;

    ::MD::Unicode_Aliases::"⊈" ::= alias of not_subset_of;

The function C<not_subset_of> aka C<⊈> results in C<True> iff the multiset
of members of its C<0> argument is not a subset of the multiset of
members of its C<1> argument; otherwise it results in C<False>.

=head2 superset_of ⊇

    ::MD::superset_of ::= function commutes subset_of;

    ::MD::Unicode_Aliases::"⊇" ::= alias of superset_of;

The function C<superset_of> aka C<⊇> results in C<True> iff the multiset of
members of its C<0> argument is a superset of the multiset of members of
its C<1> argument; otherwise it results in C<False>.

=head2 not_superset_of ⊉

    ::MD::not_superset_of ::= function negates superset_of;

    ::MD::Unicode_Aliases::"⊉" ::= alias of not_superset_of;

The function C<not_superset_of> aka C<⊉> results in C<True> iff the
multiset of members of its C<0> argument is not a superset of the multiset
of members of its C<1> argument; otherwise it results in C<False>.

=head2 same_members

    ::MD::same_members::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative;

The virtual function C<same_members> results in C<True> iff the multiset of
members of its C<0> argument is the same as the multiset of members of its
C<1> argument; otherwise it results in C<False>.  This function may result
in C<True> for some C<Positional> arguments for which C<same> would result
in C<False> because the latter considers member order significant while the
former doesn't; for non-C<Positional> arguments, the 2 functions are
typically the same.

=head2 proper_subset_or_superset

    ::MD::proper_subset_or_superset ::= function
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative
        : (not \<*args --> \same_members::() and \<*args --> \subset_or_superset::());

The function C<proper_subset_or_superset> results in C<True> iff the
multiset of members of one of its 2 arguments C<0> and C<1> is a proper
subset of the multiset of members of its other argument; otherwise it
results in C<False>.

=head2 subset_or_superset

    ::MD::subset_or_superset ::= function
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative
        : (\<*args --> \subset_of::() or \<*args --> \superset_of::());

The function C<subset_or_superset> results in C<True> iff the multiset of
members of one of its 2 arguments C<0> and C<1> is a subset of the multiset
of members of its other argument; otherwise it results in C<False>.

=head2 overlaps_members

    ::MD::overlaps_members::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative;

The virtual function C<overlaps_members> results in C<True> iff, given I<X> as the
multiset of members of its argument C<0> and I<Y> as the multiset of
members of its argument C<1>, there exists at least 1 member that both I<X>
and I<Y> have, and there also exists at least 1 other member each of I<X>
and I<Y> that the other doesn't have; otherwise it results in C<False>.

=head2 disjoint_members

    ::MD::disjoint_members::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative;

The virtual function C<disjoint_members> results in C<True> iff the multiset of
members of its C<0> argument has no member values in common with the
multiset of members of its C<1> argument; otherwise it results in C<False>.

=head2 any there_exists ∃

    ::MD::any::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Function_Call_But_0);

    ::MD::there_exists ::= alias of any;

    ::MD::Unicode_Aliases::"∃" ::= alias of any;

I<TODO.  Result is true when at least one member evaluates to true.
This is logically equivalent to testing if a same-source 'where' result is nonempty,
but 'any' is instead virtual with applicable Foundation-level functions to
aid efficiency with less-savvy optimizers that don't know to short-circuit.>

=head2 none there_does_not_exist ∄

    ::MD::none ::= function negates any;

    ::MD::there_does_not_exist ::= alias of none;

    ::MD::Unicode_Aliases::"∄" ::= alias of none;

I<TODO.  Result is true when no member evaluates to true.>

=head2 all for_all ∀

    ::MD::all ::= function --> Boolean <-- (Homogeneous, Function_Call_But_0)
        : (\<0 none ((function : (not \<1 <-- (\<0,))) \<-- (:<1,)));

    ::MD::for_all ::= alias of all;

    ::MD::Unicode_Aliases::"∀" ::= alias of all;

I<TODO.  Result is true when no member evaluates to false.>

I<Other languages: "TrueForAll".>

=head1 UNIONABLE DATA TYPES

=head2 Unionable

    ::MD::Unionable ::= interface
        composes Homogeneous
        requires_implements {to_Boolean,empty
            ,singular,only_member
            ,has_n,multiplicity
            ,all_unique,unique
            ,subset_of,same_members,overlaps_members,disjoint_members
            ,any
            ,insert_n,remove_n
            ,member_plus,except,intersect,union,exclusive
            ,nest,unnest,where,map,reduce,...};

The interface contract C<Unionable> is infinite.  A C<Unionable> value is a
C<Homogeneous> value such that another value of its collection type can be
derived by either inserting new members whose values are distinct from
those already in the collection or by removing arbitrary members from the
collection.  The default value of C<Unionable> is the C<Array> value with
zero members, C<[]>.

C<Unionable> is composed, directly or indirectly, by: C<Discrete>,
C<Positional>, C<Array>, C<String>, C<Set>, C<Bag>, C<Relational>,
C<Tuple_Array>, C<Relation>, C<Tuple_Bag>, C<Unionable_Intervalish>,
C<Interval_Set>, C<Interval_Bag>.  A key type that composes C<Homogeneous>
but not C<Unionable> is C<Interval>; use C<Interval_Set> instead for its
C<Unionable> closest analogy.

=head2 insert

    ::MD::insert ::= function --> Unionable <-- (Unionable, Any)
        : (insert_n::(\<0, \<1, 1));

The function C<insert> results in the value of its C<0> argument's
collection type that has all of the members of the function's C<0> argument
plus 1 additional member that is equal to its C<1> argument; its semantics
are identical to those of C<insert_n> where N is 1.  Other programming
languages may name their corresponding operators I<add>; it is also common
to use assignment syntax.

=head2 insert_n

    ::MD::insert_n::"" ::= function virtual
        --> Unionable <-- (Unionable, Any, Integer_NN);

The virtual function C<insert_n> results in the value of its C<0>
argument's collection type that has all of the members of the function's
C<0> argument plus N additional members that are each equal to its C<1>
argument, where N is defined by its C<2> argument; however, if the result's
type is C<Setty>, the result will have no more than 1 member equal to the
C<1> argument (any duplicates will be silently eliminated), so the result
may equal the C<0> argument even when the C<2> argument is nonzero.  If the
result's type is C<Positional>, then the result starts with all of the
members of C<0> in the same order and ends with any added instances of C<1>.

=head2 remove

    ::MD::remove ::= function --> Unionable <-- (Unionable, Any)
        : (remove_n::(\<0, \<1, 1));

The function C<remove> results in the value of its C<0> argument's
collection type that has all of the members of the function's C<0> argument
minus 1 existing member that is each equal to its C<1> argument; its
semantics are identical to those of C<remove_n> where N is 1.  Other
programming languages may name their corresponding operators I<delete>.

=head2 remove_n

    ::MD::remove_n::"" ::= function virtual
        --> Unionable <-- (Unionable, Any, Integer_NN);

The virtual function C<remove_n> results in the value of its C<0>
argument's collection type that has all of the members of the function's
C<0> argument minus N existing members that are each equal to its C<1>
argument, where N is defined as the lesser of its C<2> argument and the
count of members of C<0> equal to the C<1> argument, so the result may
equal the C<0> argument even when the C<2> argument is nonzero.  If the
result's type is C<Positional>, then the removed instances of C<1> are
those closest to the end of C<0>.  Note that C<remove_n> is designed to
mirror C<insert_n> and so the identity C<c = remove_n(insert_n(c,x,n),x,n)>
should hold for any C<Unionable> type, even a C<Positional> one, except
with a C<Setty> C<c> that already has an C<x> element with a nonzero C<n>.

=head2 member_plus ⊎

    ::MD::member_plus::"" ::= function virtual
        --> Unionable <-- (Unionable, Unionable)
        is associative;

    ::MD::Unicode_Aliases::"⊎" ::= alias of member_plus;

The virtual function C<member_plus> aka C<⊎> results in the I<multiset sum>
of its 2 arguments C<0> and C<1>.  The result is a value of the function's
C<0> argument's collection type that has all of the members of the
function's C<0> argument plus all of the members of its C<1> argument.  For
every distinct member value of the result, its multiplicity is the integral
sum of the multiplicities of that same member value of each of the 2
arguments; however, if the result's type is C<Setty>, the result will only
have 1 member per distinct member value (any duplicates will be silently
eliminated).  If the result's type is C<Positional>, then the result starts
with all of the members of C<0> and ends with the members of C<1>, the
members from both in the same order as in their respective arguments; that
is, this function then behaves identically to C<catenate> aka C<~> when
given the same arguments.  This operation has an identity value of a
collection with zero members.  For non-ordered types, this operation is
also commutative.  Other programming languages may name their corresponding
operators I<union all> or I<+>.

=head2 except ∖

    ::MD::except::"" ::= function virtual
        --> Unionable <-- (Unionable, Unionable);

    ::MD::Unicode_Aliases::"∖" ::= alias of except;

The virtual function C<except> aka C<∖> results in the I<multiset
difference> between its 2 arguments C<0> (I<minuend>) and C<1>
(I<subtrahend>).  The result is a value of the function's C<0> argument's
collection type that has all of the members of the function's C<0> argument
minus all of the matching members of its C<1> argument.  For every distinct
member value of the result, its multiplicity is the integral difference of
the multiplicities of that same member value of each of the 2 arguments
(when subtracting the I<subtrahend> from the I<minuend>); a multiplicity is
zero when it would otherwise be negative.  If the result's type is
C<Positional>, then the removed instances of any distinct member value are
those closest to the end of C<0>.  Note that C<except> is designed to
mirror C<member_plus> and so the identity C<x = except(member_plus(x,y),y)>
should hold for any C<Unionable> type, even a C<Positional> one, except
with C<Setty> C<x> and C<y> that have any members that are the same value.
Other programming languages may name their corresponding operators I<minus>
or I<-> or I<difference> or I<\\> or I<complement> or I<setdiff> or I<diff>
or I<--> etc or I<subtract>.

=head2 intersect ∩

    ::MD::intersect::"" ::= function virtual
        --> Unionable <-- (Unionable, Unionable)
        is {associative,idempotent};

    ::MD::Unicode_Aliases::"∩" ::= alias of intersect;

The virtual function C<intersect> aka C<∩> results in the I<multiset
intersection> of its 2 arguments C<0> and C<1>.  The result is a value of
the function's C<0> argument's collection type that has all of the members
of the function's C<0> argument that match their own members of its C<1>
argument.  For every distinct member value of the result, its multiplicity
is the integral minimum of the multiplicities of that same member value of
each of the 2 arguments (any nonmatched argument member does not appear in
the result).  If the result's type is C<Positional>, then the removed
instances of any distinct member value are those closest to the end of
C<0>.  This operation conceptually has an identity value of a collection
with an infinite number of members.  For non-ordered types, this operation
is also commutative.  Other programming languages may name their
corresponding operators I<&> or I<*>.

=head2 union ∪

    ::MD::union::"" ::= function virtual
        --> Unionable <-- (Unionable, Unionable)
        is idempotent;

    ::MD::Unicode_Aliases::"∪" ::= alias of union;

The virtual function C<union> aka C<∪> results in the I<multiset union> of
its 2 arguments C<0> and C<1>.  The result is a value of the function's
C<0> argument's collection type that has all of the members of the
function's C<0> argument plus all of the nonmatching members of its C<1>
argument.  For every distinct member value of the result, its multiplicity
is the integral maximum of the multiplicities of that same member value of
each of the 2 arguments.  If the result's type is C<Positional>, then the
result starts with all of the members of C<0> and ends with the nonmatching
members of C<1>, the members from both in the same order as in their
respective arguments; the removed (due to matching) instances of any
distinct member value are those closest to the end of C<1>.  Note that the
identity C<union(x,y) = member_plus(x,except(y,x))> should hold for any
C<Unionable> type, even a C<Positional> one.  This operation has an
identity value of a collection with zero members.  For non-ordered types,
this operation is also associative and commutative.  Other programming
languages may name their corresponding operators I<|> or I<+>.

=head2 exclusive symm_diff ∆

    ::MD::exclusive::"" ::= function virtual
        --> Unionable <-- (Unionable, Unionable);

    ::MD::symm_diff ::= alias of exclusive;

    ::MD::Unicode_Aliases::"∆" ::= alias of exclusive;

The virtual function C<exclusive> aka C<symm_diff> aka C<∆> results in the
I<multiset symmetric difference> of its 2 arguments C<0> and C<1>.  The
result is a value of the function's C<0> argument's collection type that
has all of the members of each of the function's C<0> and C<1> arguments
that do not have matching members of their counterpart argument.  For every
distinct member value of the result, its multiplicity is the integral
maximum of the multiplicities of that same member value of each of the 2
arguments, minus the integral minimum of the same.  If the result's type is
C<Positional>, then the result starts with the nonmatching members of C<0>
and ends with the nonmatching members of C<1>, the members from both in the
same order as in their respective arguments; the removed (due to matching)
instances of any distinct member value are those closest to the end of C<0>
or C<1> respectively.  Note that the identity C<exclusive(x,y) =
member_plus(except(x,y),except(y,x)) = except(union(x,y),intersect(x,y))>
should hold for any C<Unionable> type, even a C<Positional> one.  This
operation has an identity value of a collection with zero members.  For
non-ordered types, this operation is also associative and commutative.
Other programming languages may name their corresponding operators
I<symmdiff> or I<^> or I<%>.

=head2 nest group

    ::MD::nest::"" ::= function virtual --> Unionable <-- (Unionable)
        requires (...);

    ::MD::group ::= alias of nest;

I<TODO.>

=head2 unnest ungroup

    ::MD::unnest::"" ::= function virtual --> Unionable <-- (Unionable)
        requires (...);

    ::MD::ungroup ::= alias of unnest;

I<TODO.>

=head2 where σ

    ::MD::where::"" ::= function virtual
        --> Unionable <-- (Unionable, Function_Call_But_0);

    ::MD::Unicode_Aliases::"σ" ::= alias of where;

I<TODO.  The function-call is expected to be a Capsule with 2 asset attrs
named 'func' and 'args', which are a Function_Name and a Tuple respectively.
The 'args' can be any Tuple that doesn't have a '0' attr.
The function referenced by 'func' is expected to take a Tuple argument
whose '0' attr is a member of the collection and whose other attrs match
those given in 'args'.>
I<Ruby calls its version "select" (returns list) and a "keep_if" (mutates).>

I<Note: Ruby has a "reject" and a "delete_if" function that is like SQL's delete.>

=head2 filtering

    ::MD::filtering ::= function commutes where;

I<TODO.>

=head2 map

    ::MD::map::"" ::= function virtual
        --> Unionable <-- (Unionable, Function_Call_But_0);

I<TODO.  The function-call is as per that of 'where'.>
I<Ruby calls its version "collect".>

=head2 reduce

    ::MD::reduce::"" ::= function virtual
        --> Any <-- (Unionable, Function_Call_But_0_1);

I<TODO.  The function-call is expected to be a Capsule with 2 asset attrs
named 'func' and 'args', which are a Function_Name and a Tuple respectively.
The 'args' can be any Tuple that doesn't have either '0' or '1' attrs.
The function referenced by 'func' is expected to take a Tuple argument
whose '0' and '1' attrs are members of the collection and whose other attrs match
those given in 'args'.
Depending on the collection subtype, order of 0,1 may or may not be significant.
If collection is unordered, func must be both associative and commutative,
and reduce can always be parallelized.
If collection is ordered, reduce can be parallelized if func is associative;
otherwise the reduce is a serial operation, at least naively.>

=head1 DISCRETE DATA TYPES

=head2 Discrete

    ::MD::Discrete ::= interface
        composes Unionable and_provides_its_default
        requires_implements {to_Boolean,empty
            ,singular,only_member
            ,has_n,multiplicity
            ,all_unique,unique
            ,subset_of,same_members,overlaps_members,disjoint_members
            ,any
            ,insert_n,remove_n
            ,member_plus,except,intersect,union,exclusive
            ,nest,unnest,where,map,reduce,...
            ,to_Set,to_Bag,count,unique_count,order_using};

The interface contract C<Discrete> is infinite.  A C<Discrete> value is a
C<Unionable> value such that all of its members can be enumerated as
individuals and counted.  The default value of C<Discrete> is the C<Array>
value with zero members, C<[]>.

C<Discrete> is composed, directly or indirectly, by: C<Positional>,
C<Array>, C<String>, C<Set>, C<Bag>, C<Relational>, C<Tuple_Array>,
C<Relation>, C<Tuple_Bag>.

=head2 to_Set ?|

    ::MD::to_Set::"" ::= function virtual --> Set <-- (Discrete);

    ::MD::"?|" ::= alias of to_Set;

The virtual function C<to_Set> aka C<?|> results in the C<Set> value
that represents the same set of distinct member values as its C<0>
argument.  The purpose of C<to_Set> is to canonicalize C<Discrete> values
so they can be treated abstractly as sets of discrete values, for
operations where neither multiplicity nor order is significant.

=head2 to_Bag +|

    ::MD::to_Bag::"" ::= function virtual --> Bag <-- (Discrete);

    ::MD::"+|" ::= alias of to_Bag;

The virtual function C<to_Bag> aka C<+|> results in the C<Bag> value
that represents the same multiset of members as its C<0> argument.  The
purpose of C<to_Bag> is to canonicalize C<Discrete> values so they can be
treated abstractly as multisets of discrete values, for operations where
multiplicity possibly is significant but order doesn't.

=head2 count cardinality #

    ::MD::count::"" ::= function virtual --> Integer_NN <-- (Discrete);

    ::MD::cardinality ::= alias of count;
    ::MD::"#"         ::= alias of count;

The virtual function C<count> aka C<cardinality> aka C<#> results in the
integral count of the members of its C<0> argument; when multiple members
have the same member value, every member counts as 1 towards the total.

=head2 unique_count

    ::MD::unique_count::"" ::= function virtual --> Integer_NN <-- (Discrete);

The virtual function C<unique_count> results in the integral count of the
distinct member values of its C<0> argument.

=head2 order

    ::MD::order ::= function --> Positional <-- (Discrete)
        : (\<0 order_using \in_order::());

The function C<order> results in the C<Positional> value that represents
the same multiset of members as its C<0> argument but that the members are
arranged into a sequence in accordance with a total order defined by the
function C<in_order>.  This function will succeed iff C<in_order> is
defined for the types of the members or they are of an C<Orderable> type.

=head2 order_using

    ::MD::order_using::"" ::= function virtual
        --> Positional <-- (Discrete, Function_Call_But_0_1);

The virtual function C<order_using> results in the C<Positional> value that
represents the same multiset of members as its C<0> argument but that the
members are arranged into a sequence in accordance with a total order
defined by the function given in its C<1> argument.  Iff the members of the
C<0> argument are all of the same C<Orderable>-composing type, then the
generic C<in_order> function may be used as the C<1> argument; regardless,
the C<1> argument can define any total order it likes for members that are
of any type, both C<Orderable> or not.

=head1 POSITIONAL DATA TYPES

=head2 Positional

    ::MD::Positional ::= interface
        composes {Stringy, Discrete and_provides_its_default, Accessible}
        requires_implements {in_order,to_Boolean,empty
            ,substring_of,overlaps_string,disjoint_string
            ,catenate,replicate
            ,has_n,multiplicity
            ,all_unique,unique
            ,any
            ,insert_n,remove_n
            ,except,intersect,union,exclusive
            ,nest,unnest,where,map,reduce,...
            ,to_Set,to_Bag,count,order_using
            ,at
            ,to_Array
            ,first_possible_index,slice_n,index_succ_all_matches,...};

The interface contract C<Positional> is infinite.  A C<Positional> value is
both a C<Stringy> value and a C<Discrete> value; it is a homogeneous
aggregate of other, I<member> values that are arranged in an explicit total
order and can both be enumerated in that order as well as be looked up by
integral indexed-based position against that order; there is a single
canonical interpretation of where each I<member> begins and ends within the
aggregate.  A C<Positional> value is dense, meaning that every one of its
members exists at a distinct adjacent integral position; a C<Positional>
preserves the identity that the count of its members is equal to one plus
the difference of its first and last index positions.  Idiomatically, a
C<Positional> value is zero-based, meaning its first-ordered member is at
index position C<0>, but that doesn't have to be the case.  C<Positional>
requires that for every composing contract I<T> there is a single integral
value I<I> such that the first index position of every value of I<T> is
I<I>; as such, any catenation or slice of C<Positional> values would have
well-definined shifting of member values between index positions.

The default value of C<Positional> is the C<Array> value with zero members,
C<[]>.  C<Positional> is C<Orderable> in the general case conditionally
depending on whether all of its member values are mutually C<Orderable>
themselves; its minimum value is the same C<[]> as its default value; it
has no maximum value.  The ordering algorithm of C<Positional> is based on
pairwise comparison of its members by matching index starting at the lowest
index; iff C<Positional> value X is a leading sub-sequence of C<Positional>
value Y, then X is ordered before Y; otherwise, the mutual ordering of the
lowest-indexed non-matching members of X and Y determines that the ordering
of X and Y as a whole are the same as said members.  C<Positional> is
composed, directly or indirectly, by: C<Array>, C<String>, C<Tuple_Array>.

=head2 Excuse::No_Such_Index

    ::MD::Excuse::No_Such_Index ::= constant composes Excuse;

The constant C<Excuse::No_Such_Index> represents the I<undefined> result of
attempting to use a member index I<I> of C<Positional> value I<V> while
assuming incorrectly that I<V> already has a member whose index is I<I>.

=head2 singular (Positional)

    ::MD::singular::Positional ::= function --> Boolean <-- (Positional)
        implements 2::""
        : ((\<0->unique_count) = 1);

The function C<singular::Positional> results in C<True> iff its C<0>
argument has exactly 1 distinct member value, and C<False> otherwise.  This
function implements the C<Homogeneous> virtual function C<singular> for the
composing type C<Positional>.

=head2 only_member (Positional)

    ::MD::only_member::Positional ::= function --> Any <-- (Positional)
        implements 2::""
        requires (\<*args --> \singular::())
        : (\<*args --> \first::());

The function C<only_member::Positional> results in its C<0> argument's only
distinct member value.  This function will fail if the argument doesn't
have exactly 1 distinct member value.  This function implements the
C<Homogeneous> virtual function C<only_member> for the composing type
C<Positional>.

=head2 subset_of (Positional)

    ::MD::subset_of::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
        : ((\<0->to_Bag) subset_of (\<1->to_Bag));

The function C<subset_of::Positional> results in C<True> iff the multiset
of members of its C<0> argument is a subset of the multiset of members of
its C<1> argument; otherwise it results in C<False>.  This function
implements the C<Homogeneous> virtual function C<subset_of> aka C<⊆> for
the composing type C<Positional>.

=head2 same_members (Positional)

    ::MD::same_members::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
        is commutative
        : ((\<0->to_Bag) same_members (\<1->to_Bag));

The function C<same_members::Positional> results in C<True> iff the
multiset of members of its C<0> argument is the same as the multiset of
members of its C<1> argument; otherwise it results in C<False>.  This
function may result in C<True> for some arguments for which C<same> would
result in C<False> because the latter considers member order significant
while the former doesn't.  This function implements the C<Homogeneous>
virtual function C<same_members> for the composing type C<Positional>.

=head2 overlaps_members (Positional)

    ::MD::overlaps_members::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
        is commutative
        : ((\<0->to_Bag) overlaps_members (\<1->to_Bag));

The function C<overlaps_members::Positional> results in C<True> iff, given
I<X> as the multiset of members of its argument C<0> and I<Y> as the
multiset of members of its argument C<1>, there exists at least 1 member
that both I<X> and I<Y> have, and there also exists at least 1 other member
each of I<X> and I<Y> that the other doesn't have; otherwise it results in
C<False>.  This function implements the C<Homogeneous> virtual function
C<overlaps_members> for the composing type C<Positional>.

=head2 disjoint_members (Positional)

    ::MD::disjoint_members::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
        is commutative
        : ((\<0->to_Bag) disjoint_members (\<1->to_Bag));

The function C<disjoint_members::Positional> results in C<True> iff the
multiset of members of its C<0> argument has no member values in common
with the multiset of members of its C<1> argument; otherwise it results in
C<False>.  This function implements the C<Homogeneous> virtual function
C<disjoint_members> for the composing type C<Positional>.

=head2 member_plus (Positional)

    ::MD::member_plus::Positional ::= function
        --> Positional <-- (Positional, Positional)
        implements 2::""
        is associative
        : (\<*args --> \catenate::());

The function C<member_plus::Positional> results in the I<multiset sum> of
its 2 arguments C<0> and C<1>; it behaves identically to C<catenate> aka
C<~> when given the same arguments.  This function implements the
C<Unionable> virtual function C<member_plus> aka C<⊎> for the composing
type C<Positional>.

=head2 unique_count (Positional)

    ::MD::unique_count::Positional ::= function --> Integer_NN <-- (Positional)
        implements 2::""
        : (\<0->to_Set->count);

The function C<unique_count::Positional> results in the integral count of
the distinct member values of its C<0> argument.  This function implements
the C<Discrete> virtual function C<unique_count> for the composing type
C<Positional>.

=head2 has_any_at (Positional)

    ::MD::has_any_at::Positional ::= function
        --> Boolean <-- (Positional, Integer)
        implements 2::""
        : (\<1 >= first_possible_index::(\<0)
            and \<1 < first_unused_index::(\<0));

The function C<has_any_at::Positional> results in C<True> iff its C<0>
argument has a member whose index position is equal to its C<1> argument;
otherwise it results in C<False>.  This function implements the
C<Accessible> virtual function C<has_any_at> aka C<.?> for the composing
type C<Positional>.

=head2 has_mapping_at (Positional)

    ::MD::has_mapping_at::Positional ::= function
        --> Boolean <-- (Positional, (Integer, Any))
        implements 2::""
        : (if \<0 .? \>>0 then \<0.\>>0 = \>>1 else False);

The function C<has_mapping_at::Positional> results in C<True> iff its C<0>
argument has a member that is equal to its C<1> argument's C<1> attribute,
where the index position of that member is equal to the C<1> argument's
C<0> attribute; otherwise it results in C<False>.  This function implements
the C<Accessible> virtual function C<has_mapping_at> aka C<.:?> for the
composing type C<Positional>.

=head2 mapping_at (Positional)

    ::MD::mapping_at::Positional ::= function
        --> (Integer, Any) <-- (Positional, Integer)
        implements 2::""
        requires (\<0 .? \<1)
        : ((\<1, \<0.\<1));

The function C<mapping_at::Positional> results in a binary C<Tuple> whose
C<0> attribute is the function's C<1> argument and whose C<1> attribute is
the member value of the function's C<0> argument whose index position is
equal to its C<1> argument.  This function will fail if the C<0> argument
doesn't have such a member.  This function implements the C<Accessible>
virtual function C<mapping_at> aka C<.:> for the composing type
C<Positional>.

=head2 maybe_at (Positional)

    ::MD::maybe_at::Positional ::= function
        --> Any <-- (Positional, Integer)
        implements 2::""
        : (if \<0 .? \<1 then \<0.\<1 else Excuse::No_Such_Index());

The function C<maybe_at::Positional> results in the member value of its
C<0> argument whose index position is equal to its C<1> argument, iff there
is such a member; otherwise it results in an C<Excuse>.  This function
implements the C<Accessible> virtual function C<maybe_at> aka C<.!> for the
composing type C<Positional>.

=head2 replace_at (Positional)

    ::MD::replace_at::Positional ::= function
        --> Positional <-- (Positional, (Integer, Any))
        implements 2::""
        requires (\<0 .? \>>0)
    : (
        src ::= \<0;
        ri ::= \>>0;
        repl_member ::= \>>1;
        fi ::= first_index src;
        li ::= last_index src;
        emp ::= empty src;
        <-- (if ri > fi then slice_range::(src, fi, --ri) else emp)
            insert repl_member
            catenate (if ri < li then slice_range::(src, ++ri, li) else emp);
    );

The function C<replace_at::Positional> results in the value of its C<0>
argument's collection type that has all of the members of the function's
C<0> argument in the same order but that, for the 1 member of the C<0>
argument whose index position I<K> is equal to the function's C<1>
argument's C<0> attribute, the result instead has at index position I<K> a
member whose value is equal to the C<1> argument's C<1> attribute.  This
function will fail if the C<0> argument doesn't have a member with the
index position I<K>.  This function implements the C<Accessible> virtual
function C<replace_at> aka C<.:=> for the composing type C<Positional>.

=head2 shiftless_insert_at (Positional)

    ::MD::shiftless_insert_at::Positional ::= function
        --> Positional <-- (Positional, (Integer, Any))
        implements 2::""
        requires (\>>0 = first_unused_index::(\<0))
        : (\<0 insert \>>1);

The function C<shiftless_insert_at::Positional> results in the value of its
C<0> argument's collection type that has all of the members of the
function's C<0> argument in the same order, plus 1 additional member I<M>
that is equal to its C<1> argument's C<1> attribute, where the index
position I<K> in the result of I<M> is equal to the C<1> argument's C<0>
attribute.  This function will fail if I<K> is not equal to the C<0>
argument's C<first_unused_index>.  This function implements the
C<Accessible> virtual function C<shiftless_insert_at> aka C<.+> for the
composing type C<Positional>.

=head2 shiftless_remove_at (Positional)

    ::MD::shiftless_remove_at::Positional ::= function
        --> Positional <-- (Positional, Integer)
        implements 2::""
        requires (\<1 >= first_possible_index::(\<0)
            and \<1 = --first_unused_index::(\<0))
        : (nonlast \<0);

The function C<shiftless_remove_at::Positional> results in the value of its
C<0> argument's collection type that has all of the members of the
function's C<0> argument in the same order minus 1 existing element whose
index position I<K> is equal to its C<1> argument.  This function will fail
if either the C<0> argument doesn't have any members or if I<K> is not
equal to the C<0> argument's C<last_index>.  This function implements the
C<Accessible> virtual function C<shiftless_remove_at> aka C<.->  for the
composing type C<Positional>.

=head2 replace_or_insert_at (Positional)

    ::MD::replace_or_insert_at::Positional ::= function
        --> Positional <-- (Positional, (Integer, Any))
        implements 2::""
        requires (\<1 >= first_possible_index::(\<0)
            and \<1 <= first_unused_index::(\<0))
        : (if \<0 .? \>>0 then \<0 .:= \>>0 else \<0 .+ \>>0);

The function C<replace_or_insert_at::Positional> behaves identically in
turn to each of the functions C<replace_at> and C<shiftless_insert_at> when
given the same arguments, where the C<0> argument does or doesn't,
respectively, have a member whose index position is equal to the C<1>
argument's C<0> attribute.  This function implements the C<Accessible>
virtual function C<replace_or_insert_at> aka C<.=+> for the composing type
C<Positional>.

=head2 shiftless_maybe_remove_at (Positional)

    ::MD::shiftless_maybe_remove_at::Positional ::= function
        --> Positional <-- (Positional, Integer)
        implements 2::""
        requires (\<1 >= first_possible_index::(\<0)
            and \<1 >= --first_unused_index::(\<0))
        : (if \<1 = --first_unused_index::(\<0) then nonlast \<0 else \<0);

The function C<shiftless_maybe_remove_at::Positional> behaves identically
to C<shiftless_remove_at> when given the same arguments but that it simply
results in its C<0> argument when that has no member whose index position
matches its C<1> argument, rather than fail.  This function implements the
C<Accessible> virtual function C<shiftless_maybe_remove_at> aka C<.?-> for
the composing type C<Positional>.

=head2 to_Array ~|

    ::MD::to_Array::"" ::= function virtual --> Array <-- (Positional);

    ::MD::"~|" ::= alias of to_Array;

The virtual function C<to_Array> aka C<~|> results in the C<Array>
value that represents the same sequence of members as its C<0> argument.
The purpose of C<to_Array> is to canonicalize C<Positional> values so they
can be treated abstractly as sequences of discrete values with minimal
effort.

=head2 squish

    ::MD::squish ::= function --> Positional <-- (Positional)
        : (\<0 map (function : (( group : \<0, member : False )))
            ->nest map (function : (\<<group)));

The function C<squish> results in the value of its C<0> argument's
ordered collection type that has all of the members of the function's C<0>
argument but that, for every run of 2 or more consecutive members that are
all the same value, that run retains only 1 of those members.  Iff the
argument is such that all appearances of each distinct value are adjacent
members, the result of C<squish> is the same as that of C<unique>.

=head2 first_possible_index

    ::MD::first_possible_index::"" ::= function virtual
        --> Integer <-- (Positional);

The virtual function C<first_possible_index> results in the integral first
possible index position I<I> that every value of its C<0> argument's
collection type has in common.  Iff the C<0> argument I<C> is nonempty then
the result is also equal to the actual index position of I<C>'s first
member; otherwise I<I> is the index position that a subsequently-added
first member of I<C> would have.

=head2 first_unused_index

    ::MD::first_unused_index ::= function --> Integer <-- (Positional)
        : (first_possible_index::(\<0) + #\<0);

The function C<first_unused_index> results in the integral first unused
index position of its C<0> argument, which is the index position that the
first subsequently-appended member would have.  Iff the C<0> argument I<C>
is nonempty then the result is one greater than the last index position of
I<C>; otherwise the result is equal to the first possible index.  For a
zero-based C<Positional>, the result is equal to its C<count>.

=head2 first_index

    ::MD::first_index ::= function --> Integer <-- (Positional)
        requires (?\<0)
        : (first_possible_index::(\<0));

The function C<first_index> results in the integral index position of its
nonempty C<0> argument's first member.

=head2 last_index

    ::MD::last_index ::= function --> Integer <-- (Positional)
        requires (?\<0)
        : (--first_unused_index::(\<0));

The function C<last_index> results in the integral index position of its
nonempty C<0> argument's last member.

=head2 slice_n

    ::MD::slice_n::"" ::= function virtual
        --> Positional <-- (Positional, Integer, NN_Integer)
        requires (\<1 >= first_possible_index::(\<0)
            and \<1 + \<2 <= first_unused_index::(\<0));

The virtual function C<slice_n> results in the value of its C<0> argument's
ordered collection type that has exactly I<N> consecutive members of the
function's C<0> argument I<C>, in the same order, such that the first
member existed at index position I<F> of I<C> where I<F> and I<N> are equal
to the function's C<1> and C<2> arguments respectively.  The taken members
do not necessarily occupy the same index positions in the result as they
did in I<C>.  This function will fail if I<C> does not have members at any
of the index positions requested.  Other programming languages may name
their corresponding operators I<array_slice>.

=head2 slice_range

    ::MD::slice_range ::= function
        --> Positional <-- (Positional, Integer, Integer)
        requires (?\<0 and \<1 >= first_possible_index::(\<0)
            and \<2 < first_unused_index::(\<0))
        : (slice_n::(\<0, \<1, \<2 - \<1 + 1));

The function C<slice_range> results in the value of its C<0> argument's
ordered collection type that has all of the members of the function's C<0>
argument I<C>, in the same order, such that the first and last members
existed at index positions equal to the function's C<1> and C<2> arguments
respectively.  The taken members do not necessarily occupy the same index
positions in the result as they did in I<C>.  This function will fail if
I<C> does not have members at any of the index positions requested.  Other
programming languages may name their corresponding operators I<slice> or
may instead overload their array element subscripting syntax.

=head2 first

    ::MD::first ::= function --> Any <-- (Positional)
        requires (?\<0)
        : (\<0 . first_index::(\<0));

The function C<first> results in its nonempty C<0> argument's first member.

=head2 nonfirst

    ::MD::nonfirst ::= function --> Positional <-- (Positional)
        requires (?\<0)
        : (slice_range::(\<0, ++first_index::(\<0), last_index::(\<0)));

The function C<nonfirst> results in the value of its C<0> argument's
ordered collection type that has all of the members of the function's
nonempty C<0> argument, in the same order, except for its very first one.
The taken members occupy index positions of exactly 1 less in the result as
they did in the argument.

=head2 last

    ::MD::last ::= function --> Any <-- (Positional)
        requires (?\<0)
        : (\<0 . last_index::(\<0));

The function C<last> results in its nonempty C<0> argument's last member.

=head2 nonlast

    ::MD::nonlast ::= function --> Positional <-- (Positional)
        requires (?\<0)
        : (slice_range::(\<0, first_index::(\<0), --last_index::(\<0)));

The function C<nonlast> results in the value of its C<0> argument's ordered
collection type that has all of the members of the function's nonempty C<0>
argument, in the same order, except for its very last one.  The taken
members occupy the exact same index positions in the result as they did in
the argument.

=head2 index_succ_all_matches

    ::MD::index_succ_all_matches::"" ::= function virtual
        --> Integer <-- (Positional, Positional)
        is commutative;

I<TODO.  Also consider index_first_diff_elem or index_succ_common_prefix as name.>

=head1 ARRAY DATA TYPES

=head2 Array

    ::MD::Array ::= selection where (\<*args -->^ FDN__is_a_Array)
        default ([])
        composes Positional and_provides_its_default;

The selection contract C<Array> represents the infinite Muldis D Foundation
type I<FDN__Array>.  An C<Array> value is a general purpose
arbitrarily-long ordered sequence of any other, I<member> values, which
explicitly does not represent any kind of thing in particular, and is
simply the sum of its members.  An C<Array> value is dense; iff it has any
members, then its first-ordered member is at index position C<0>, and its
last-indexed member is at the index position that is one less than the
count of its members.  An C<Array> in the general case may have
multiple members that are the same value, and any duplicates may or may not
exist at consecutive indexes.  The default value of C<Array> is C<[]>, the
only zero-member C<Array> value.  C<Array> is C<Orderable>; its minimum
value is the same C<[]> as its default value; it has no maximum value; its
ordering algorithm is defined by C<Positional>.  Other programming
languages may name their corresponding types I<List>.

=head2 String

    ::MD::String::"" ::= selection of Array where (\<0 all \Integer::());

The selection contract C<String> represents the infinite type consisting
just of the C<Array> values having just C<Integer> members.  A C<String>
value is a general purpose integer string, which explicitly does not
represent any kind of thing in particular, neither octets nor characters
nor anything else, simply a sequence of generic integers.  A C<String>
value is isomorphic to an C<Attr_Name> value, and values of proper subtypes
of C<String> are isomorphic to C<Bits> and C<Blob> and C<Text> values.

Other programming languages don't necessarily have a dedicated type
representing a string of generic integers, but rather they may have generic
arrays, or bit arrays with names like I<bit> or I<bit varying>,
or octet arrays with names like I<byte[]> or I<bytea>, or character
arrays with names like I<string> or I<text> or I<varchar>, or types like
I<string> that may represent either octets or characters.

=head2 empty_Array ~∅

    ::MD::empty_Array ::= constant ([]);

    ::MD::Unicode_Aliases::"~∅" ::= alias of empty_Array;

The constant C<empty_Array> aka C<~∅> represents the only zero-member
C<Array> value, C<[]>.

=head2 in_order (Array)

    ::MD::in_order::Array ::= function --> Boolean <-- (Array, Array)
        implements 2::""
    : (
        i ::= (\<*args --> \index_succ_all_matches::());
      <--
        if not \<0 .? i then
            e1 ::= True
        else if not \<1 .? i then
            False
        else
            e2 ::= (\<0.i in_order \<1.i);

        e1 ::?= 'This is the case where LHS is a leading subsequence of or is equal to RHS.';
        e2 ::?= 'This will succeed iff in_order() is defined for the member type.';
    );

The function C<in_order::Array> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Array>.  This function
will succeed iff C<in_order> is also defined for the types of the members.

=head2 to_Boolean (Array)

    ::MD::to_Boolean::Array ::= function --> Boolean <-- (Array)
        implements 2::""
        : (\<0 != []);

The function C<to_Boolean::Array> results in C<True> iff its C<0> argument
has any members, and in C<False> iff it has no members.  This function
implements the C<Boolable> virtual function C<to_Boolean> aka C<so> aka
C<?> for the composing type C<Array>.

=head2 empty (Array)

    ::MD::empty::Array ::= function --> Array <-- (Array)
        implements 2::""
        : ([]);

The function C<empty::Array> results in the only zero-member C<Array>
value.  This function implements the C<Emptyable> virtual function C<empty>
aka C<∅> for the composing type C<Array>.

=head2 substring_of (Array)

    ::MD::substring_of::Array ::= function --> Boolean <-- (Array, Array)
        implements 2::""
        : (\<*args -->^ FDN__Array_substring_of);

The function C<substring_of::Array> results in C<True> iff the sequence of
members of its C<0> argument is a substring of the sequence of members of
its C<1> argument; otherwise it results in C<False>.  This function
implements the C<Stringy> virtual function C<substring_of> for the
composing type C<Array>.

=head2 overlaps_string (Array)

    ::MD::overlaps_string::Array ::= function --> Boolean <-- (Array, Array)
        implements 2::""
        is commutative
        : (\<*args -->^ FDN__Array_overlaps_string);

The function C<overlaps_string::Array> results in C<True> iff, given I<X>
as the sequence of members of its argument C<0> and I<Y> as the sequence of
members of its argument C<1>, when I<X> and I<Y> are overlapped to the
greatest possible extent such that every corresponding member pair has 2 of
the same value, the overlap of I<X> and I<Y> has at least 1 member, and
each of I<X> and I<Y> has at least 1 member that is not overlapped;
otherwise it results in C<False>.  This function implements the C<Stringy>
virtual function C<overlaps_string> for the composing type C<Array>.

=head2 disjoint_string (Array)

    ::MD::disjoint_string::Array ::= function --> Boolean <-- (Array, Array)
        implements 2::""
        is commutative
        : (\<*args -->^ FDN__Array_disjoint_string);

The function C<disjoint_string::Array> results in C<True> iff the sequence
of members of its C<0> argument can not be overlapped with the sequence of
members of its C<1> argument by at least 1 member such that every
corresponding member pair has 2 of the same value; otherwise it results in
C<False>.  This function implements the C<Stringy> virtual function
C<disjoint_string> for the composing type C<Array>.

=head2 catenate (Array)

    ::MD::catenate::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        is associative identity ([])
        repeater replicate::Array
        : (\<*args -->^ FDN__Array_catenate);

The function C<catenate::Array> results in the catenation of its 2
arguments C<0> and C<1> such that the result starts with the members of
C<0> and ends with the members of C<1>.  This function implements the
C<Stringy> virtual function C<catenate> aka C<~> for the composing type
C<Array>.

=head2 replicate (Array)

    ::MD::replicate::Array ::= function --> Array <-- (Array, Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Array_replicate);

The function C<replicate::Array> results in the catenation of N instances
of its C<0> argument where N is defined by its C<1> argument.  If the C<1>
argument is zero then the result is the only zero-member C<Array>.  This
function implements the C<Stringy> virtual function C<replicate> aka C<~#>
for the composing type C<Array>.

=head2 has_n (Array)

    ::MD::has_n::Array ::= function --> Boolean <-- (Array, Any, Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Array_has_n);

The function C<has_n::Array> results in C<True> iff its C<0> argument has
at least N members at any indexes such that each is equal to its C<1>
argument, where N is defined by its C<2> argument; otherwise it results in
C<False>.  This function implements the C<Homogeneous> virtual function
C<has_n> for the composing type C<Array>.

=head2 multiplicity (Array)

    ::MD::multiplicity::Array ::= function --> Integer_NN <-- (Array, Any)
        implements 2::""
        : (\<*args -->^ FDN__Array_multiplicity);

The function C<multiplicity::Array> results in the integral count
of members of its C<0> argument such that each member value is equal to its
C<1> argument.  This function implements the C<Homogeneous> virtual
function C<multiplicity> for the composing type C<Array>.

=head2 all_unique (Array)

    ::MD::all_unique::Array ::= function --> Boolean <-- (Array)
        implements 2::""
        : (\<*args -->^ FDN__Array_all_unique);

The function C<all_unique::Array> results in C<True> iff its C<0> argument
has no 2 members that are the same value, and C<False> otherwise.  This
function implements the C<Homogeneous> virtual function C<all_unique> for
the composing type C<Array>.

=head2 unique (Array)

    ::MD::unique::Array ::= function --> Array <-- (Array)
        implements 2::""
        : (\<*args -->^ FDN__Array_unique);

The function C<unique::Array> results in the C<Array> value that has, for
every distinct member value I<V> of the function's C<0> argument, exactly 1
member whose value is equal to I<V>.  Each retained member is the one
closest to the start of the argument out of those members sharing the
retained member's value.  This function implements the C<Homogeneous>
virtual function C<unique> for the composing type C<Array>.

=head2 any (Array)

    ::MD::any::Array ::= function --> Boolean <-- (Array, Function_Call_But_0)
        implements 2::""
        : (\<*args -->^ FDN__Array_any);

I<TODO.>

=head2 insert_n (Array)

    ::MD::insert_n::Array ::= function --> Array <-- (Array, Any, Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Array_insert_n);

The function C<insert_n::Array> results in the C<Array> value that has all
of the members of the function's C<0> argument plus N additional members
that are each equal to its C<1> argument, where N is defined by its C<2>
argument.  The result starts with all of the members of C<0> in the same
order and ends with any added instances of C<1>.  This function implements
the C<Unionable> virtual function C<insert_n> for the composing type
C<Array>.

=head2 remove_n (Array)

    ::MD::remove_n::Array ::= function --> Array <-- (Array, Any, Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Array_remove_n);

The function C<remove_n::Array> results in the C<Array> value that has all
of the members of the function's C<0> argument minus N existing members
that are each equal to its C<1> argument, where N is defined as the lesser
of its C<2> argument and the count of members of C<0> equal to the C<1>
argument.  The removed instances of C<1> are those closest to the end of
C<0>.  This function implements the C<Unionable> virtual function
C<remove_n> for the composing type C<Array>.

=head2 except (Array)

    ::MD::except::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        : (\<*args -->^ FDN__Array_except);

The function C<except::Array> results in the I<multiset difference> between
its 2 arguments C<0> (I<minuend>) and C<1> (I<subtrahend>).  The result is
the C<Array> value that has all of the members of the function's C<0>
argument minus all of the matching members of its C<1> argument.  The
removed instances of any distinct member value are those closest to the end
of C<0>.  This function implements the C<Unionable> virtual function
C<except> aka C<∖> for the composing type C<Array>.

=head2 intersect (Array)

    ::MD::intersect::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        is {associative,idempotent}
        : (\<*args -->^ FDN__Array_intersect);

The function C<intersect::Array> results in the I<multiset intersection> of
its 2 arguments C<0> and C<1>.  The result is the C<Array> value that has
all of the members of the function's C<0> argument that match their own
members of its C<1> argument.  The removed instances of any distinct member
value are those closest to the end of C<0>.  This operation conceptually
has an identity value of a collection with an infinite number of members.
This function implements the C<Unionable> virtual function C<intersect>
aka C<∩> for the composing type C<Array>.

=head2 union (Array)

    ::MD::union::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        is idempotent identity ([])
        : (\<*args -->^ FDN__Array_union);

The function C<union::Array> results in the I<multiset union> of its 2
arguments C<0> and C<1>.  The result is the C<Array> value that has all of
the members of the function's C<0> argument plus all of the nonmatching
members of its C<1> argument.  The result starts with all of the members of
C<0> and ends with the nonmatching members of C<1>, the members from both
in the same order as in their respective arguments; the removed (due to
matching) instances of any distinct member value are those closest to the
end of C<1>.  This function implements the C<Unionable> virtual function
C<union> aka C<∪> for the composing type C<Array>.

=head2 exclusive (Array)

    ::MD::exclusive::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        identity ([])
        : (\<*args -->^ FDN__Array_exclusive);

The function C<exclusive::Array> results in the I<multiset symmetric
difference> of its 2 arguments C<0> and C<1>.  The result is the C<Array>
value that has all of the members of each of the function's C<0> and C<1>
arguments that do not have matching members of their counterpart argument.
The result starts with the nonmatching members of C<0> and ends with the
nonmatching members of C<1>, the members from both in the same order as in
their respective arguments; the removed (due to matching) instances of any
distinct member value are those closest to the end of C<0> or C<1>
respectively.  This function implements the C<Unionable> virtual function
C<exclusive> aka C<symm_diff> aka C<∆> for the composing type C<Array>.

=head2 nest (Array)

    ::MD::nest::Array ::= function --> Array <-- (Array)
        implements 2::""
        requires (...)
        : (\<*args -->^ FDN__Array_nest);

I<TODO.>

=head2 unnest (Array)

    ::MD::unnest::Array ::= function --> Array <-- (Array)
        implements 2::""
        requires (...)
        : (\<*args -->^ FDN__Array_unnest);

I<TODO.>

=head2 where (Array)

    ::MD::where::Array ::= function --> Array <-- (Array, Function_Call_But_0)
        implements 2::""
        : (\<*args -->^ FDN__Array_where);

I<TODO.>

=head2 map (Array)

    ::MD::map::Array ::= function --> Array <-- (Array, Function_Call_But_0)
        implements 2::""
        : (\<*args -->^ FDN__Array_map);

I<TODO.>

=head2 reduce (Array)

    ::MD::reduce::Array ::= function --> Any <-- (Array, Function_Call_But_0_1)
        implements 2::""
        : (\<*args -->^ FDN__Array_reduce);

I<TODO.>

=head2 to_Set (Array)

    ::MD::to_Set::Array ::= function --> Set <-- (Array)
        implements 2::""
        : (\<0->to_Bag->to_Set);

The function C<to_Set::Array> results in the C<Set> value that has, for
every distinct member value I<V> of the function's C<0> argument, exactly 1
member whose value is equal to I<V>.  This function implements the
C<Discrete> virtual function C<to_Set> aka C<?|> for the composing type
C<Array>.

=head2 to_Bag (Array)

    ::MD::to_Bag::Array ::= function --> Bag <-- (Array)
        implements 2::""
        : (\<*args -->^ FDN__Array_to_Bag);

The function C<to_Bag::Array> results in the C<Bag> value that has all of
the members of the function's C<0> argument.  This function implements the
C<Discrete> virtual function C<to_Bag> aka C<+|> for the composing type
C<Array>.

=head2 count (Array)

    ::MD::count::Array ::= function --> Integer_NN <-- (Array)
        implements 2::""
        : (\<*args -->^ FDN__Array_count);

The function C<count::Array> results in the integral count of the members
of its C<0> argument.  This function implements the C<Discrete> virtual
function C<count> aka C<cardinality> aka C<#> for the composing type
C<Array>.

=head2 order_using (Array)

    ::MD::order_using::Array ::= function --> Array <-- (Array, Function_Call_But_0_1)
        implements 2::""
        : (\<*args -->^ FDN__Array_order_using);

The function C<order_using::Array> results in the C<Array> value that
represents the same multiset of members as its C<0> argument but that the
members are arranged into a sequence in accordance with a total order
defined by the function given in its C<1> argument.  This function
implements the C<Discrete> virtual function C<order_using> for the composing
type C<Array>.

=head2 at (Array)

    ::MD::at::Array ::= function --> Any <-- (Array, Integer_NN)
        implements 2::""
        requires (\<0 .? \<1)
        : (\<*args -->^ FDN__Array_at);

The function C<at::Array> results in the member value of its C<0> argument
whose index position is equal to its C<1> argument.  This function will
fail if the C<0> argument doesn't have such a member.  This function
implements the C<Accessible> virtual function C<at> aka C<.> for the
composing type C<Array>.

=head2 to_Array (Array)

    ::MD::to_Array::Array ::= function --> Array <-- (Array)
        implements 2::""
        : (\<0);

The function C<to_Array::Array> simply results in its C<0> argument.  This
function implements the C<Positional> virtual function C<to_Array> aka
C<~|> for the composing type C<Array>.

=head2 first_possible_index (Array)

    ::MD::first_possible_index::Array ::= function --> Integer_NN <-- (Array)
        implements 2::""
        : (0);

The function C<first_possible_index::Array> simply results in C<0>.  This
function implements the C<Positional> virtual function
C<first_possible_index> for the composing type C<Array>.

=head2 slice_n (Array)

    ::MD::slice_n::Array ::= function
        --> Array <-- (Array, NN_Integer, NN_Integer)
        implements 2::""
        requires (\<1 + \<2 <= #\<0)
        : (\<*args -->^ FDN__Array_slice_n);

The function C<slice_n::Array> results in the C<Array> value that has
exactly I<N> consecutive members of the function's C<0> argument I<C>, in
the same order, such that the first member existed at index position I<F>
of I<C> where I<F> and I<N> are equal to the function's C<1> and C<2>
arguments respectively.  The taken members do not necessarily occupy the
same index positions in the result as they did in I<C>.  This function will
fail if I<C> does not have members at any of the index positions requested.
This function implements the C<Positional> virtual function C<slice_n> for
the composing type C<Array>.

=head2 index_succ_all_matches (Array)

    ::MD::index_succ_all_matches::Array ::= function
        --> Integer_NN <-- (Array, Array)
        implements 2::""
        is commutative
        : (\<*args -->^ FDN__Array_index_succ_all_matches);

I<TODO.  While conceivably implementable at a higher level, make low level
for perceived efficiency.>

=head1 SETTY DATA TYPES

=head2 Setty

    ::MD::Setty ::= interface;

The interface contract C<Setty> is infinite.  A C<Setty> value is a
I<collective> value such that every one of its component I<members> is a
distinct value.  The default value of C<Setty> is the C<Set> value with
zero members, C<{}>.  C<Setty> is composed, directly or indirectly, by:
C<Set>, C<Relation>, C<Interval>, C<Interval_Set>.

=head1 SET DATA TYPES

=head2 Set

    ::MD::Set ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Set, \1::_Asset() ))
            default ({})
            composes {Discrete, Setty and_provides_its_default};

        _Asset ::= selection of Bag
            where (all_unique \<0);
    };

The selection contract C<Set> is infinite.  A C<Set> value is a general
purpose arbitrarily-large unordered collection of any other, I<member>
values, which explicitly does not represent any kind of thing in
particular, and is simply the sum of its members.  A C<Set> ensures that no
2 of its members are the same value.  The default value of C<Set> is C<{}>,
the only zero-member C<Set> value.

=head2 empty_Set ?∅

    ::MD::empty_Set ::= constant ({});

    ::MD::Unicode_Aliases::"?∅" ::= alias of empty_Set;

The constant C<empty_Set> aka C<?∅> represents the only zero-member
C<Set> value, C<{}>.

=head2 to_Boolean (Set)

    ::MD::to_Boolean::Set ::= function --> Boolean <-- (Set)
        implements 2::""
        : (\<0 != {});

The function C<to_Boolean::Set> results in C<True> iff its C<0> argument
has any members, and in C<False> iff it has no members.  This function
implements the C<Boolable> virtual function C<to_Boolean> aka C<so> aka
C<?> for the composing type C<Set>.

=head2 empty (Set)

    ::MD::empty::Set ::= function --> Set <-- (Set)
        implements 2::""
        : ({});

The function C<empty::Set> results in the only zero-member C<Set>
value.  This function implements the C<Emptyable> virtual function C<empty>
aka C<∅> for the composing type C<Set>.

=head2 singular (Set)

    ::MD::singular::Set ::= function --> Boolean <-- (Set)
        implements 2::""
        : (\<0->unwrap->singular);

The function C<singular::Set> results in C<True> iff its C<0> argument has
exactly 1 member value, and C<False> otherwise.  This function implements
the C<Homogeneous> virtual function C<singular> for the composing type
C<Set>.

=head2 only_member (Set)

    ::MD::only_member::Set ::= function --> Any <-- (Set)
        implements 2::""
        requires (\<*args --> \singular::())
        : (\<0->unwrap->only_member);

The function C<only_member::Set> results in its C<0> argument's only member
value.  This function will fail if the argument doesn't have exactly 1
member value.  This function implements the C<Homogeneous> virtual function
C<only_member> for the composing type C<Set>.

=head2 has_n (Set)

    ::MD::has_n::Set ::= function --> Boolean <-- (Set, Any, Integer_NN)
        implements 2::""
        : (has_n::(\<0->unwrap, \<1, \<2));

The function C<has_n::Set> results in C<True> iff either its C<2> argument
is zero or its C<0> argument has a member equal to its C<1> argument and
its C<2> argument is 1; otherwise it results in C<False>.  This function
implements the C<Homogeneous> virtual function C<has_n> for the composing
type C<Set>.

=head2 multiplicity (Set)

    ::MD::multiplicity::Set ::= function --> Integer_NN <-- (Set, Any)
        implements 2::""
        : (\<0->unwrap multiplicity \<1);

The function C<multiplicity::Set> results in 1 if its C<0> argument
has a member equal to its C<1> argument; otherwise it results in 0.  This
function implements the C<Homogeneous> virtual function C<multiplicity> for
the composing type C<Set>.

=head2 all_unique (Set)

    ::MD::all_unique::Set ::= function --> Boolean <-- (Set)
        implements 2::""
        : (True);

The function C<all_unique::Set> simply results in C<True>.  This function
implements the C<Homogeneous> virtual function C<all_unique> for the
composing type C<Set>.

=head2 unique (Set)

    ::MD::unique::Set ::= function --> Set <-- (Set)
        implements 2::""
        : (\<0);

The function C<unique::Set> simply results in its C<0> argument.  This
function implements the C<Homogeneous> virtual function C<unique> for the
composing type C<Set>.

=head2 subset_of (Set)

    ::MD::subset_of::Set ::= function --> Boolean <-- (Set, Set)
        implements 2::""
        : ((\<0->unwrap) subset_of (\<1->unwrap));

The function C<subset_of::Set> results in C<True> iff the set of members of
its C<0> argument is a subset of the set of members of its C<1> argument;
otherwise it results in C<False>.  This function implements the
C<Homogeneous> virtual function C<subset_of> aka C<⊆> for the composing
type C<Set>.

=head2 same_members (Set)

    ::MD::same_members::Set ::= function --> Boolean <-- (Set, Set)
        implements 2::""
        is commutative
        : (\<*args --> \same::());

The function C<same_members::Set> results in C<True> iff its 2 arguments
C<0> and C<1> are exactly the same C<Set> value, and C<False> otherwise;
its behaviour is identical to that of the function C<same> when given the
same arguments.  This function implements the C<Homogeneous> virtual
function C<same_members> for the composing type C<Set>.

=head2 overlaps_members (Set)

    ::MD::overlaps_members::Set ::= function --> Boolean <-- (Set, Set)
        implements 2::""
        is commutative
        : ((\<0->unwrap) overlaps_members (\<1->unwrap));

The function C<overlaps_members::Set> results in C<True> iff, given
I<X> as the set of members of its argument C<0> and I<Y> as the
set of members of its argument C<1>, there exists at least 1 member
that both I<X> and I<Y> have, and there also exists at least 1 other member
each of I<X> and I<Y> that the other doesn't have; otherwise it results in
C<False>.  This function implements the C<Homogeneous> virtual function
C<overlaps_members> for the composing type C<Set>.

=head2 disjoint_members (Set)

    ::MD::disjoint_members::Set ::= function --> Boolean <-- (Set, Set)
        implements 2::""
        is commutative
        : ((\<0->unwrap) disjoint_members (\<1->unwrap));

The function C<disjoint_members::Set> results in C<True> iff the
set of members of its C<0> argument has no member values in common
with the set of members of its C<1> argument; otherwise it results in
C<False>.  This function implements the C<Homogeneous> virtual function
C<disjoint_members> for the composing type C<Set>.

=head2 any (Set)

    ::MD::any::Set ::= function --> Boolean <-- (Set, Function_Call_But_0)
        implements 2::""
        : (\<0->unwrap any \<1);

I<TODO.>

=head2 insert_n (Set)

    ::MD::insert_n::Set ::= function --> Set <-- (Set, Any, Integer_NN)
        implements 2::""
        : (\<0 has \<1 or \<2 = 0 ?? \<0
            !! \Set wrap insert_n::(\<0->unwrap, \<1, 1));

The function C<insert_n::Set> results in the C<Set> value that has all of
the members of the function's C<0> argument; but, if the C<2> argument is
nonzero then the result has a member equal to the C<1> argument, whether or
not C<0> had it.  This function implements the C<Unionable> virtual
function C<insert_n> for the composing type C<Set>.

=head2 remove_n (Set)

    ::MD::remove_n::Set ::= function --> Set <-- (Set, Any, Integer_NN)
        implements 2::""
        : (\Set wrap remove_n::(\<0->unwrap, \<1, \<2));

The function C<remove_n::Set> results in the C<Set> value that has all of
the members of the function's C<0> argument; but, if the C<2> argument is
nonzero and C<0> had a member equal to the C<1> argument, the result lacks
that member.  This function implements the C<Unionable> virtual function
C<remove_n> for the composing type C<Set>.

=head2 member_plus (Set)

    ::MD::member_plus::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        is {associative,commutative,idempotent} identity ({})
        : (\<*args --> \union::());

The function C<member_plus::Set> results in the I<set union> of its 2
arguments C<0> and C<1>; it behaves identically to C<union> aka C<∪> when
given the same arguments.  This function implements the C<Unionable>
virtual function C<member_plus> aka C<⊎> for the composing type C<Set>.

=head2 except (Set)

    ::MD::except::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        : (\Set wrap ((\<0->unwrap) except (\<1->unwrap)));

The function C<except::Set> results in the I<set difference> between
its 2 arguments C<0> (I<minuend>) and C<1> (I<subtrahend>).  The result is
the C<Set> value that has all of the members of the function's C<0>
argument minus all of the matching members of its C<1> argument.  This
function implements the C<Unionable> virtual function C<except> aka C<∖>
for the composing type C<Set>.

=head2 intersect (Set)

    ::MD::intersect::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        is {associative,commutative,idempotent}
        : (\Set wrap ((\<0->unwrap) intersect (\<1->unwrap)));

The function C<intersect::Set> results in the I<set intersection> of
its 2 arguments C<0> and C<1>.  The result is the C<Set> value that has all
of the members of the function's C<0> argument that match their own members
of its C<1> argument.  This function implements the C<Unionable> virtual
function C<intersect> aka C<∩> for the composing type C<Set>.

=head2 union (Set)

    ::MD::union::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        is {associative,commutative,idempotent} identity ({})
        : (\Set wrap ((\<0->unwrap) union (\<1->unwrap)));

The function C<union::Set> results in the I<set union> of its 2
arguments C<0> and C<1>.  The result is the C<Set> value that has all of
the members of the function's C<0> argument plus all of the nonmatching
members of its C<1> argument.  This function implements the C<Unionable>
virtual function C<union> aka C<∪> for the composing type C<Set>.

=head2 exclusive (Set)

    ::MD::exclusive::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        is {associative,commutative} identity ({})
        : (\Set wrap ((\<0->unwrap) exclusive (\<1->unwrap)));

The function C<exclusive::Set> results in the I<set symmetric
difference> of its 2 arguments C<0> and C<1>.  The result is the C<Set>
value that has all of the members of each of the function's C<0> and C<1>
arguments that do not have matching members of their counterpart argument.
This function implements the C<Unionable> virtual function C<exclusive>
aka C<symm_diff> aka C<∆> for the composing type C<Set>.

=head2 nest (Set)

    ::MD::nest::Set ::= function --> Set <-- (Set)
        implements 2::""
        requires (...)
        : (\Set wrap (\<0->unwrap->nest));

I<TODO.>

=head2 unnest (Set)

    ::MD::unnest::Set ::= function --> Set <-- (Set)
        implements 2::""
        requires (...)
        : (\Set wrap (\<0->unwrap->unnest));

I<TODO.>

=head2 where (Set)

    ::MD::where::Set ::= function --> Set <-- (Set, Function_Call_But_0)
        implements 2::""
        : (\Set wrap (\<0->unwrap where \<1));

I<TODO.>

=head2 map (Set)

    ::MD::map::Set ::= function --> Set <-- (Set, Function_Call_But_0)
        implements 2::""
        : (\Set wrap (\<0->unwrap map \<1));

I<TODO.>

=head2 reduce (Set)

    ::MD::reduce::Set ::= function --> Any <-- (Set, Function_Call_But_0_1)
        implements 2::""
        : (\Set wrap (\<0->unwrap reduce \<1));

I<TODO.>

=head2 to_Set (Set)

    ::MD::to_Set::Set ::= function --> Set <-- (Set)
        implements 2::""
        : (\<0);

The function C<to_Set::Set> simply results in its C<0> argument.  This
function implements the C<Discrete> virtual function C<to_Set> aka
C<?|> for the composing type C<Set>.

=head2 to_Bag (Set)

    ::MD::to_Bag::Set ::= function --> Bag <-- (Set)
        implements 2::""
        : (\<0->unwrap);

The function C<to_Bag::Set> results in the C<Bag> value that has all of the
members of the function's C<0> argument.  This function implements the
C<Discrete> virtual function C<to_Bag> aka C<+|> for the composing type
C<Set>.

=head2 count (Set)

    ::MD::count::Set ::= function --> Integer_NN <-- (Set)
        implements 2::""
        : (\<0->unwrap->count);

The function C<count::Set> results in the integral count of the members
of its C<0> argument.  This function implements the C<Discrete> virtual
function C<count> aka C<cardinality> aka C<#> for the composing type C<Set>.

=head2 unique_count (Set)

    ::MD::unique_count::Set ::= function --> Integer_NN <-- (Set)
        implements 2::""
        : (\<0->count);

The function C<unique_count::Set> results in the integral count of the
members of its C<0> argument; its behavior is identical to C<count> given
the same argument.  This function implements the C<Discrete> virtual
function C<unique_count> for the composing type C<Set>.

=head2 order_using (Set)

    ::MD::order_using::Set ::= function --> Array <-- (Set, Function_Call_But_0_1)
        implements 2::""
        : (\Set wrap (\<0->unwrap order_using \<1));

The function C<order_using::Set> results in the C<Array> value that represents
the same set of members as its C<0> argument but that the members are
arranged into a sequence in accordance with a total order defined by the
function given in its C<1> argument.  This function implements the
C<Discrete> virtual function C<order_using> for the composing type C<Set>.

=head1 BAG DATA TYPES

=head2 Bag

    ::MD::Bag ::= selection where (\<*args -->^ FDN__is_a_Bag)
        default (\+{})
        composes Discrete;

The selection contract C<Bag> represents the infinite Muldis D Foundation
type I<FDN__Bag>.  A C<Bag> value is a general purpose arbitrarily-large
unordered collection of any other, I<member> values, which explicitly does
not represent any kind of thing in particular, and is simply the sum of its
members.  A C<Bag> in the general case may have multiple members that are
the same value.  The default value of C<Bag> is C<\+{}>, the only
zero-member C<Bag> value.  Other programming languages may name their
corresponding types I<Multiset>.

=head2 empty_Bag +∅

    ::MD::empty_Bag ::= constant (\+{});

    ::MD::Unicode_Aliases::"+∅" ::= alias of empty_Bag;

The constant C<empty_Bag> aka C<+∅> represents the only zero-member
C<Bag> value, C<\+{}>.

=head2 to_Boolean (Bag)

    ::MD::to_Boolean::Bag ::= function --> Boolean <-- (Bag)
        implements 2::""
        : (\<0 != \+{});

The function C<to_Boolean::Bag> results in C<True> iff its C<0> argument
has any members, and in C<False> iff it has no members.  This function
implements the C<Boolable> virtual function C<to_Boolean> aka C<so> aka
C<?> for the composing type C<Bag>.

=head2 empty (Bag)

    ::MD::empty::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        : (\+{});

The function C<empty::Bag> results in the only zero-member C<Bag>
value.  This function implements the C<Emptyable> virtual function C<empty>
aka C<∅> for the composing type C<Bag>.

=head2 singular (Bag)

    ::MD::singular::Bag ::= function --> Boolean <-- (Bag)
        implements 2::""
        : (\<*args -->^ FDN__Bag_singular);

The function C<singular::Bag> results in C<True> iff its C<0> argument has
exactly 1 distinct member value, and C<False> otherwise.  This function
implements the C<Homogeneous> virtual function C<singular> for the
composing type C<Bag>.

=head2 only_member (Bag)

    ::MD::only_member::Bag ::= function --> Any <-- (Bag)
        implements 2::""
        requires (\<*args --> \singular::())
        : (\<*args -->^ FDN__Bag_only_member);

The function C<only_member::Bag> results in its C<0> argument's only
distinct member value.  This function will fail if the argument doesn't
have exactly 1 distinct member value.  This function implements the
C<Homogeneous> virtual function C<only_member> for the composing type
C<Bag>.

=head2 has_n (Bag)

    ::MD::has_n::Bag ::= function --> Boolean <-- (Bag, Any, Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Bag_has_n);

The function C<has_n::Bag> results in C<True> iff its C<0> argument has at
least N members such that each is equal to its C<1> argument, where N is
defined by its C<2> argument; otherwise it results in C<False>.  This
function implements the C<Homogeneous> virtual function C<has_n> for the
composing type C<Bag>.

=head2 multiplicity (Bag)

    ::MD::multiplicity::Bag ::= function --> Integer_NN <-- (Bag, Any)
        implements 2::""
        : (\<*args -->^ FDN__Bag_multiplicity);

The function C<multiplicity::Bag> results in the integral count
of members of its C<0> argument such that each member value is equal to its
C<1> argument.  This function implements the C<Homogeneous> virtual
function C<multiplicity> for the composing type C<Bag>.

=head2 all_unique (Bag)

    ::MD::all_unique::Bag ::= function --> Boolean <-- (Bag)
        implements 2::""
        : (\<*args -->^ FDN__Bag_all_unique);

The function C<all_unique::Bag> results in C<True> iff its C<0> argument
has no 2 members that are the same value, and C<False> otherwise.  This
function implements the C<Homogeneous> virtual function C<all_unique> for
the composing type C<Bag>.

=head2 unique (Bag)

    ::MD::unique::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        : (\<*args -->^ FDN__Bag_unique);

The function C<unique::Bag> results in the C<Bag> value that has, for every
distinct member value I<V> of the function's C<0> argument, exactly 1
member whose value is equal to I<V>.  This function implements the
C<Homogeneous> virtual function C<unique> for the composing type C<Bag>.

=head2 subset_of (Bag)

    ::MD::subset_of::Bag ::= function --> Boolean <-- (Bag, Bag)
        implements 2::""
        : (\<*args -->^ FDN__Bag_subset_of);

The function C<subset_of::Bag> results in C<True> iff the multiset of
members of its C<0> argument is a subset of the multiset of members of its
C<1> argument; otherwise it results in C<False>.  This function implements
the C<Homogeneous> virtual function C<subset_of> aka C<⊆> for the composing
type C<Bag>.

=head2 same_members (Bag)

    ::MD::same_members::Bag ::= function --> Boolean <-- (Bag, Bag)
        implements 2::""
        is commutative
        : (\<*args --> \same::());

The function C<same_members::Bag> results in C<True> iff its 2 arguments
C<0> and C<1> are exactly the same C<Bag> value, and C<False> otherwise;
its behaviour is identical to that of the function C<same> when given the
same arguments.  This function implements the C<Homogeneous> virtual
function C<same_members> for the composing type C<Bag>.

=head2 overlaps_members (Bag)

    ::MD::overlaps_members::Bag ::= function --> Boolean <-- (Bag, Bag)
        implements 2::""
        is commutative
        : (\<*args -->^ FDN__Bag_overlaps_members);

The function C<overlaps_members::Bag> results in C<True> iff, given
I<X> as the multiset of members of its argument C<0> and I<Y> as the
multiset of members of its argument C<1>, there exists at least 1 member
that both I<X> and I<Y> have, and there also exists at least 1 other member
each of I<X> and I<Y> that the other doesn't have; otherwise it results in
C<False>.  This function implements the C<Homogeneous> virtual function
C<overlaps_members> for the composing type C<Bag>.

=head2 disjoint_members (Bag)

    ::MD::disjoint_members::Bag ::= function --> Boolean <-- (Bag, Bag)
        implements 2::""
        is commutative
        : (\<*args -->^ FDN__Bag_disjoint_members);

The function C<disjoint_members::Bag> results in C<True> iff the
multiset of members of its C<0> argument has no member values in common
with the multiset of members of its C<1> argument; otherwise it results in
C<False>.  This function implements the C<Homogeneous> virtual function
C<disjoint_members> for the composing type C<Bag>.

=head2 any (Bag)

    ::MD::any::Bag ::= function --> Boolean <-- (Bag, Function_Call_But_0)
        implements 2::""
        : (\<*args -->^ FDN__Bag_any);

I<TODO.>

=head2 insert_n (Bag)

    ::MD::insert_n::Bag ::= function --> Bag <-- (Bag, Any, Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Bag_insert_n);

The function C<insert_n::Bag> results in the C<Bag> value that has all of
the members of the function's C<0> argument plus N additional members that
are each equal to its C<1> argument, where N is defined by its C<2>
argument.  This function implements the C<Unionable> virtual function
C<insert_n> for the composing type C<Bag>.

=head2 remove_n (Bag)

    ::MD::remove_n::Bag ::= function --> Bag <-- (Bag, Any, Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Bag_remove_n);

The function C<remove_n::Bag> results in the C<Bag> value that has all of
the members of the function's C<0> argument minus N existing members that
are each equal to its C<1> argument, where N is defined as the lesser of
its C<2> argument and the count of members of C<0> equal to the C<1>
argument.  This function implements the C<Unionable> virtual function
C<remove_n> for the composing type C<Bag>.

=head2 member_plus (Bag)

    ::MD::member_plus::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        is {associative,commutative} identity (\+{})
        : (\<*args -->^ FDN__Bag_member_plus);

The function C<member_plus::Bag> results in the I<multiset sum> of its 2
arguments C<0> and C<1>.  The result is the C<Bag> value that has all of
the members of the function's C<0> argument plus all of the members of its
C<1> argument.  This function implements the C<Unionable> virtual
function C<member_plus> aka C<⊎> for the composing type C<Bag>.

=head2 except (Bag)

    ::MD::except::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        : (\<*args -->^ FDN__Bag_except);

The function C<except::Bag> results in the I<multiset difference> between
its 2 arguments C<0> (I<minuend>) and C<1> (I<subtrahend>).  The result is
the C<Bag> value that has all of the members of the function's C<0>
argument minus all of the matching members of its C<1> argument.  This
function implements the C<Unionable> virtual function C<except> aka C<∖>
for the composing type C<Bag>.

=head2 intersect (Bag)

    ::MD::intersect::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        is {associative,commutative,idempotent}
        : (\<*args -->^ FDN__Bag_intersect);

The function C<intersect::Bag> results in the I<multiset intersection> of
its 2 arguments C<0> and C<1>.  The result is the C<Bag> value that has all
of the members of the function's C<0> argument that match their own members
of its C<1> argument.  This function implements the C<Unionable> virtual
function C<intersect> aka C<∩> for the composing type C<Bag>.

=head2 union (Bag)

    ::MD::union::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        is {associative,commutative,idempotent} identity (\+{})
        : (\<*args -->^ FDN__Bag_union);

The function C<union::Bag> results in the I<multiset union> of its 2
arguments C<0> and C<1>.  The result is the C<Bag> value that has all of
the members of the function's C<0> argument plus all of the nonmatching
members of its C<1> argument.  This function implements the C<Unionable>
virtual function C<union> aka C<∪> for the composing type C<Bag>.

=head2 exclusive (Bag)

    ::MD::exclusive::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        is {associative,commutative} identity (\+{})
        : (\<*args -->^ FDN__Bag_exclusive);

The function C<exclusive::Bag> results in the I<multiset symmetric
difference> of its 2 arguments C<0> and C<1>.  The result is the C<Bag>
value that has all of the members of each of the function's C<0> and C<1>
arguments that do not have matching members of their counterpart argument.
This function implements the C<Unionable> virtual function C<exclusive>
aka C<symm_diff> aka C<∆> for the composing type C<Bag>.

=head2 nest (Bag)

    ::MD::nest::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        requires (...)
        : (\<*args -->^ FDN__Bag_nest);

I<TODO.>

=head2 unnest (Bag)

    ::MD::unnest::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        requires (...)
        : (\<*args -->^ FDN__Bag_unnest);

I<TODO.>

=head2 where (Bag)

    ::MD::where::Bag ::= function --> Bag <-- (Bag, Function_Call_But_0)
        implements 2::""
        : (\<*args -->^ FDN__Bag_where);

I<TODO.>

=head2 map (Bag)

    ::MD::map::Bag ::= function --> Bag <-- (Bag, Function_Call_But_0)
        implements 2::""
        : (\<*args -->^ FDN__Bag_map);

I<TODO.>

=head2 reduce (Bag)

    ::MD::reduce::Bag ::= function --> Any <-- (Bag, Function_Call_But_0_1)
        implements 2::""
        : (\<*args -->^ FDN__Bag_reduce);

I<TODO.>

=head2 to_Set (Bag)

    ::MD::to_Set::Bag ::= function --> Set <-- (Bag)
        implements 2::""
        : (\Set wrap (\<0->unique));

The function C<to_Set::Bag> results in the C<Set> value that has, for every
distinct member value I<V> of the function's C<0> argument, exactly 1
member whose value is equal to I<V>.  This function implements the
C<Discrete> virtual function C<to_Set> aka C<?|> for the composing type
C<Bag>.

=head2 to_Bag (Bag)

    ::MD::to_Bag::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        : (\<0);

The function C<to_Bag::Bag> simply results in its C<0> argument.  This
function implements the C<Discrete> virtual function C<to_Bag> aka
C<+|> for the composing type C<Bag>.

=head2 count (Bag)

    ::MD::count::Bag ::= function --> Integer_NN <-- (Bag)
        implements 2::""
        : (\<*args -->^ FDN__Bag_count);

The function C<count::Bag> results in the integral count of the members
of its C<0> argument.  This function implements the C<Discrete> virtual
function C<count> aka C<cardinality> aka C<#> for the composing type C<Bag>.

=head2 unique_count (Bag)

    ::MD::unique_count::Bag ::= function --> Integer_NN <-- (Bag)
        implements 2::""
        : (\<*args -->^ FDN__Bag_unique_count);

The function C<unique_count::Bag> results in the integral count of the
distinct member values of its C<0> argument.  This function implements the
C<Discrete> virtual function C<unique_count> for the composing type C<Bag>.

=head2 order_using (Bag)

    ::MD::order_using::Bag ::= function --> Array <-- (Bag, Function_Call_But_0_1)
        implements 2::""
        : (\<*args -->^ FDN__Bag_order_using);

The function C<order_using::Bag> results in the C<Array> value that represents
the same multiset of members as its C<0> argument but that the members are
arranged into a sequence in accordance with a total order defined by the
function given in its C<1> argument.  This function implements the
C<Discrete> virtual function C<order_using> for the composing type C<Bag>.

=head1 ATTRIBUTIVE DATA TYPES

=head2 Attributive

    ::MD::Attributive ::= interface
        requires_implements {has_any_attrs,nullary
            ,is_unary,degree,heading,rename
            ,can_project_matching,on,update,extend
            ,has_attrs,has_just_attrs};

The interface contract C<Attributive> is infinite.  An C<Attributive> value
is a I<collective> value such that every one of its component I<attributes>
is conceptually of its own data type or should be interpreted logically in
a distinct way from its fellow attributes.  Idiomatically an C<Attributive>
is a generic collection which does not as a whole represent any kind of
thing in particular, such as a text or a graphic, and is simply the sum of
its I<attributes>; however some types which do represent such a particular
kind of thing may choose to compose C<Attributive> because it makes sense
to provide its operators.  The default value of C<Attributive> is the
C<Tuple> value with zero attributes, C<()>.

An C<Attributive> value either is a C<Tuple> or is isomorphic to a C<Tuple>
or is isomorphic to a C<Homogeneous> collection each of whose I<members> is
a C<Tuple>.  An C<Attributive> value is always I<discrete> in its
I<attributive> dimension such that all of its attributes can be enumerated
as individuals and counted.  However, an C<Attributive> value is not
necessarily I<discrete> in its I<homogeneous> dimension, depending on the
specific collection type in question.  If an C<Attributive> value is also
C<Discrete>, then it is I<discrete> in both dimensions.

Every attribute of an C<Attributive> value has a distinct I<attribute name>
by which it can be looked up.  An C<Attributive> value has a I<heading>
which is a set of distinct attribute names; corresponding to this, an
C<Attributive> value has a I<body> which has the zero or more other values
that can be looked up using the attribute names.  Each attribute then is
conceptually a name-asset pair.  An I<attribute name> is isomorphic to a
C<String> value and is conceptually a character string that is not a
C<Text> value.  More precisely, an I<attribute name> is an unqualified
program identifier and forms the basis for Muldis D identifiers.

If an C<Attributive> value is also C<Structural>, it has exactly 1 member,
meaning the value is or is isomorphic to a C<Tuple>, meaning each attribute
name has exactly 1 corresponding attribute asset; otherwise, that may not
be the case.  If an C<Attributive> value is also C<Relational>, it
potentially has any number of members, zero or more, meaning the value is
isomorphic to a C<Homogeneous> collection each of whose I<members> is a
C<Tuple>; otherwise, that may not be the case.

C<Attributive> is composed, directly or indirectly, by: C<Structural>,
C<Tuple>, C<Relational>, C<Tuple_Array>, C<Relation>, C<Tuple_Bag>.

=head2 Excuse::No_Such_Attr_Name

    ::MD::Excuse::No_Such_Attr_Name ::= constant composes Excuse;

The constant C<Excuse::No_Such_Attr_Name> represents the I<undefined>
result of attempting to use an attribute named I<N> of C<Attributive> value
I<V> while assuming incorrectly that I<V> already has an attribute whose
name is I<N>.

=head2 has_any_attrs ?@

    ::MD::has_any_attrs::"" ::= function virtual --> Boolean <-- (Attributive);

    ::MD::"?@" ::= alias of has_any_attrs;

The virtual function C<has_any_attrs> aka C<?@> results in C<True> iff its
C<0> argument has any attributes, and in C<False> iff it has no attributes.

=head2 is_nullary !?@

    ::MD::is_nullary ::= function negates has_any_attrs;

    ::MD::"!?@" ::= alias of is_nullary;

The function C<is_nullary> aka C<!?@> results in C<True> iff its C<0>
argument has no attributes, and in C<False> iff it has any attributes.

=head2 nullary

    ::MD::nullary::"" ::= function virtual --> Attributive <-- (Attributive);

The virtual function C<nullary> results in the value of its C<0> argument's
collection type that has zero attributes.  For C<Structural> types like
C<Tuple>, this is a constant value, but for types like C<Tuple_Bag>, there
is a distinct result for each I<cardinality>; for types like C<Relation>
there are exactly 2 possible result values.

=head2 is_unary

    ::MD::is_unary::"" ::= function virtual --> Boolean <-- (Attributive);

The virtual function C<is_unary> results in C<True> iff its C<0> argument
has exactly 1 attribute, and C<False> otherwise.

=head2 degree #@

    ::MD::degree::"" ::= function virtual --> Integer_NN <-- (Attributive);

    ::MD::"#@" ::= alias of degree;

The virtual function C<degree> aka C<#@> results in the integral count of
the attributes of its C<0> argument.

=head2 heading @

    ::MD::heading::"" ::= function virtual --> Heading <-- (Attributive);

    ::MD::"@" ::= alias of heading;

The virtual function C<heading> aka C<@> results in the
relational I<heading> of its C<0> argument, that is its set of distinct
attribute names.  The form that this takes is a C<Tuple> having just the
same attribute names where every one of its assets is the value C<True>.
The purpose of C<heading> is to canonicalize C<Attributive> values such
that their headings can be reasoned about in isolation from their bodies.

=head2 subheading_of ⊆@

    ::MD::subheading_of ::= function
        --> Boolean <-- (Attributive, Attributive)
        : ((@\<0, @\<1) -->^ FDN__Tuple_subheading_of);

    ::MD::Unicode_Aliases::"⊆@" ::= alias of subheading_of;

The function C<subheading_of> aka C<⊆@> results in C<True> iff the heading
of its C<0> argument is a subset of the heading of its C<1> argument;
otherwise it results in C<False>.

=head2 superheading_of has_subheading @? ⊇@

    ::MD::superheading_of ::= function commutes subheading_of;

    ::MD::has_subheading ::= alias of superheading_of;
    ::MD::"@?"           ::= alias of superheading_of;

    ::MD::Unicode_Aliases::"⊇@" ::= alias of superheading_of;

The function C<superheading_of> aka C<has_subheading> aka C<@?> aka C<⊇@>
results in C<True> iff the heading of its C<0> argument is a superset of
the heading of its C<1> argument; otherwise it results in C<False>.  Note
that using this function with a C<Heading> as its C<1> argument is the
idiomatic way to test if an C<Attributive> has all of a specific set of
attribute names; whereas the C<.?> function is idiomatic for testing for
exactly 1 name.

=head2 same_heading =@

    ::MD::same_heading ::= function
        --> Boolean <-- (Attributive, Attributive)
        is commutative
        : (@\<0 = @\<1);

    ::MD::"=@" ::= alias of same_heading;

The function C<same_heading> aka C<=@> results in C<True> iff the heading
of its C<0> argument is the same as the heading of its C<1> argument;
otherwise it results in C<False>.

=head2 proper_subheading_or_superheading

    ::MD::proper_subheading_or_superheading ::= function
        --> Boolean <-- (Attributive, Attributive)
        is commutative
        : (@\<0 != @\<1 and \<*args --> \subheading_or_superheading::());

The function C<proper_subheading_or_superheading> results in C<True> iff
the heading of one of its 2 arguments C<0> and C<1> is a proper subset of
the heading of its other argument; otherwise it results in C<False>.

=head2 subheading_or_superheading

    ::MD::subheading_or_superheading ::= function
        --> Boolean <-- (Attributive, Attributive)
        is commutative
        : (\<*args --> \subheading_of::() or \<*args --> \superheading_of::());

The function C<subheading_or_superheading> results in C<True> iff the
heading of one of its 2 arguments C<0> and C<1> is a subset of the heading
of its other argument; otherwise it results in C<False>.

=head2 overlaps_heading

    ::MD::overlaps_heading ::= function
        --> Boolean <-- (Attributive, Attributive)
        is commutative
        : ((@\<0, @\<1) -->^ FDN__Tuple_overlaps_heading);

The function C<overlaps_heading> results in C<True> iff, given I<X> as the
heading of its argument C<0> and I<Y> as the heading of its argument C<1>,
there exists at least 1 attribute name that both I<X> and I<Y> have, and
there also exists at least 1 other attribute name each of I<X> and I<Y>
that the other doesn't have; otherwise it results in C<False>.

=head2 disjoint_heading

    ::MD::disjoint_heading ::= function
        --> Boolean <-- (Attributive, Attributive)
        is commutative
        : ((@\<0, @\<1) -->^ FDN__Tuple_disjoint_heading);

The function C<disjoint_heading> results in C<True> iff the heading of its
C<0> argument has no attribute names in common with the heading of its C<1>
argument; otherwise it results in C<False>.

=head2 except_heading ∖@

    ::MD::except_heading ::= function
        --> Heading <-- (Attributive, Attributive)
        : ((@\<0, @\<1) -->^ FDN__Tuple_except_heading);

    ::MD::Unicode_Aliases::"∖@" ::= alias of except_heading;

The function C<except_heading> aka C<∖@> results in the I<set difference>
between the I<headings> of its 2 arguments C<0> (I<minuend>) and C<1>
(I<subtrahend>).  The result is the C<Heading> value that just has every
attribute name that exists in the heading of the function's C<0> argument
but not in the heading of its C<1> argument.

=head2 intersect_heading ∩@

    ::MD::intersect_heading ::= function
        --> Heading <-- (Attributive, Attributive)
        is {associative,commutative,idempotent}
        : ((@\<0, @\<1) -->^ FDN__Tuple_intersect_heading);

    ::MD::Unicode_Aliases::"∩@" ::= alias of intersect_heading;

The function C<intersect_heading> aka C<∩@> results in the I<set
intersection> of the I<headings> of its 2 arguments C<0> and C<1>.  The
result is the C<Heading> value that just has every attribute name that
exists in both of the headings of the function's C<0> and C<1> arguments.
This operation conceptually has an identity value of a C<Heading> with an
infinite number of attribute names.

=head2 union_heading ∪@

    ::MD::union_heading ::= function
        --> Heading <-- (Attributive, Attributive)
        is {associative,commutative,idempotent} identity (())
        : ((@\<0, @\<1) -->^ FDN__Tuple_union_heading);

    ::MD::Unicode_Aliases::"∪@" ::= alias of union_heading;

The function C<union_heading> aka C<∪@> results in the I<set union> of the
I<headings> of its 2 arguments C<0> and C<1>.  The result is the C<Heading>
value that just has every attribute name that exists in either or both of
the headings of the function's C<0> and C<1> arguments.

=head2 exclusive_heading symm_diff_heading ∆@

    ::MD::exclusive ::= function
        --> Heading <-- (Attributive, Attributive)
        is {associative,commutative} identity (())
        : ((@\<0, @\<1) -->^ FDN__Tuple_exclusive_heading);

    ::MD::symm_diff_heading ::= alias of exclusive_heading;

    ::MD::Unicode_Aliases::"∆@" ::= alias of exclusive_heading;

The function C<exclusive_heading> aka C<symm_diff_heading> aka C<∆@>
results in the I<set symmetric difference> of the I<headings> of its 2
arguments C<0> and C<1>.  The result is the C<Heading> value that just has
every attribute name that exists in the heading of exactly one of the
function's C<0> or C<1> arguments.

=head2 rename @:= ρ

    ::MD::rename::"" ::= function virtual
        --> Attributive <-- (Attributive, Renaming)
        requires (...);

    ::MD::"@:=" ::= alias of rename;

    ::MD::Unicode_Aliases::"ρ" ::= alias of rename;

The virtual function C<rename> aka C<@:=> aka C<ρ> results results in the
I<relational rename> of its C<0> argument in terms of its C<1> argument.
The result is a value of the function's C<0> argument's collection type
that has all of the attributes of the function's C<0> argument but that,
for each attribute of the C<0> argument whose attribute name matches a
I<before> element of its C<1> argument, the result's corresponding
attribute instead has an attribute name that matches the corresponding
I<after> element of the C<1> argument.  The I<degree> and the
I<cardinality> of the result are both equal to the degree and cardinality
of the C<0> argument, respectively.  This function will fail if any
I<before> element of the C<1> argument does not match the name of an
attribute name of the C<0> argument, or if any I<after> element of the
former does match an attribute name of the latter that isn't being renamed.

I<TODO: Revisit the Outdated docs of this operator after the Renaming type
is fully defined, for additional useful language for describing "rename".>

=head2 renaming

    ::MD::renaming ::= function commutes rename;

The function C<renaming> behaves identically to the function C<rename> when
given the same arguments in swapped positions.

=head2 can_project_matching %=?

    ::MD::can_project_matching::"" ::= function virtual
        --> Boolean <-- (Attributive, Structural);

    ::MD::"%=?" ::= alias of can_project_matching;

The virtual function C<can_project_matching> aka C<%=?> results in C<True>
iff the heading of its C<0> argument is a superset of the heading of its
C<1> argument and every commonly-named attribute of the two arguments also
has the same attribute asset; otherwise it results in C<False>.  Note that
by definition, the identity C<can_project_matching(update(a,s),s) = True>
aka C<a %:= s %=? s = True> should hold for all valid C<a> and C<s>.

=head2 on project %= π

    ::MD::on::"" ::= function virtual
        --> Attributive <-- (Attributive, Heading)
        requires (\<0 @? \<1);

    ::MD::project ::= alias of on;
    ::MD::"%="    ::= alias of on;

    ::MD::Unicode_Aliases::"π" ::= alias of on;

The virtual function C<on> aka C<project> aka C<%=> aka C<π> results in the
I<relational projection> of its C<0> argument in terms of its C<1>
argument.  The result is a value of the function's C<0> argument's
collection type that has all of the attributes of the function's C<0>
argument whose names match the names of attributes of its C<1> argument.
The I<degree> of the result is equal to the degree of the C<1> argument,
and the I<cardinality> of the result is either equal to or less than the
cardinality of the C<0> argument; a lesser cardinality would be the result
of duplicate result member elimination for a I<setty> type.  For every
member tuple or isomorphism I<X> in the C<0> argument, the result has a
member tuple or isomorphism I<Y> that is equal to the result of projecting
I<X> on all of the attribute names of the C<1> argument.  This function
will fail if the I<heading> of the C<1> argument is not a subset of the
I<heading> of the C<0> argument.  Other programming languages may name
their corresponding operators I<over> or I<select>; it is also common to
use subscript/postcircumfix syntax.

=head2 from

    ::MD::from ::= function commutes on;

The function C<from> behaves identically to the function C<on>
when given the same arguments in swapped positions.

=head2 maybe_on %!

    ::MD::maybe_on ::= function --> Attributive <-- (Attributive, Heading)
        : (\<0 on (\<0 intersect_heading \<1));

    ::MD::"%!" ::= alias of maybe_on;

The function C<maybe_on> aka C<%!> behaves identically to C<on>
when given the same arguments but that it simply ignores the existence of
attributes of its C<1> argument whose names don't match attributes of its
C<0> argument rather than failing.

=head2 update %:=

    ::MD::update::"" ::= function virtual
        --> Attributive <-- (Attributive, Structural)
        requires (\<0 @? \<1);

    ::MD::"%:=" ::= alias of update;

The virtual function C<update> aka C<%:=> results in the value of its C<0>
argument's collection type that has all of the attributes of the function's
C<0> argument but that, for each attribute of the C<0> argument whose
attribute name I<K> matches the name of an attribute of its C<1> argument,
the result takes its corresponding attribute from the C<1> argument rather
than from the C<0> argument.  The I<degree> of the result is equal to the
degree of the C<0> argument, and the I<cardinality> of the result is either
equal to or less than the cardinality of the C<0> argument; a lesser
cardinality would be the result of duplicate result member elimination for
a I<setty> type.  For every member tuple or isomorphism I<X> in the C<0>
argument, the result has a member tuple or isomorphism I<Y> that is equal
to I<X> but that, for each attribute name I<K> of I<X>, the asset of the
attribute named I<K> of I<Y> is equal to the asset of the attribute named
I<K> of the C<1> argument rather than its value from I<X>.  This function
will fail if the I<heading> of the C<1> argument is not a subset of the
I<heading> of the C<0> argument.  Other programming languages may name
their corresponding operators I<update ... set>; it is also common to use
subscript/postcircumfix syntax plus assignment syntax.

=head2 extend %+

    ::MD::extend::"" ::= function virtual
        --> Attributive <-- (Attributive, Structural)
        requires (\<0 disjoint_heading \<1);

    ::MD::"%+" ::= alias of extend;

The virtual function C<extend> aka C<%+> results in the I<relational
extension> of its C<0> argument in terms of its C<1> argument.  The result
is a value of the function's C<0> argument's collection type that has all
of the attributes of the function's C<0> argument plus all of the
attributes of its C<1> argument.  The I<degree> of the result is equal to
the integral sum of the degrees of the 2 arguments, and the I<cardinality>
of the result is equal to the cardinality of the C<0> argument.  There is a
bijection between the C<0> argument and the result with respect to their
I<members>; for every tuple or isomorphism I<X> in the C<0> argument, the
result has a tuple or isomorphism I<Y> that is equal to the result of
extending I<X> with all of the attributes (names and assets) of the C<1>
argument.  This function will fail if the I<headings> of the 2 arguments
are not disjoint.  Other programming languages may name their corresponding
operators I<join>.

I<TODO.  There is no version of 'extend' that takes a routine; one can just
use the above version plus an eg-tuple selector. In the case of relation
extend, one can do the aforementioned within a 'map' routine, for the
routine version; they can use join/cross-product for the static version.
Also, this is analogous to set union (disjoint).
The Structural version is commutative and associative, but not Attributive in general.>

=head2 but project_all_but %-

    ::MD::but ::= function --> Attributive <-- (Attributive, Heading)
        requires (\<0 @? \<1)
        : (\<0 on (\<0 except_heading \<1));

    ::MD::project_all_but ::= alias of but;
    ::MD::"%-"            ::= alias of but;

The function C<but> aka C<project_all_but> aka C<%-> results in the
I<relational projection> of its C<0> argument in terms of its C<1>
argument.  The result is a value of the function's C<0> argument's
collection type that has all of the attributes of the function's C<0>
argument whose names do not match the names of attributes of its C<1>
argument.  The I<degree> of the result is equal to the integral difference
of the degrees of the 2 arguments, and the I<cardinality> of the result is
either equal to or less than the cardinality of the C<0> argument; a lesser
cardinality would be the result of duplicate result member elimination for
a I<setty> type.  For every member tuple or isomorphism I<X> in the C<0>
argument, the result has a member tuple or isomorphism I<Y> that is equal
to the result of projecting I<X> on all of its attribute names except for
those in common with the C<1> argument.  This function will fail if the
I<heading> of the C<1> argument is not a subset of the I<heading> of the
C<0> argument.  Other programming languages may name their corresponding
operators I<remove>.

=head2 update_or_extend %=+

    ::MD::update_or_extend ::= function
        --> Attributive <-- (Attributive, Structural)
        : (\<0 on (\<0 except_heading \<1) extend \<1);

    ::MD::"%=+" ::= alias of update_or_extend;

The function C<update_or_extend> aka C<%=+> is a hybrid of the 2
functions C<update> and C<extend>.  The result is a value of the function's
C<0> argument's collection type that has attribute assets substituted with
those from the function's C<1> argument where the attribute names match,
and the result has new attributes added from the C<1> argument where the
latter's names don't match.

=head2 maybe_but %?-

    ::MD::maybe_but ::= function --> Attributive <-- (Attributive, Heading)
        : (\<0 but (\<0 intersect_heading \<1));

    ::MD::"%?-" ::= alias of maybe_but;

The function C<maybe_but> aka C<%?-> behaves identically to C<but>
when given the same arguments but that it simply ignores the existence of
attributes of its C<1> argument whose names don't match attributes of its
C<0> argument rather than failing.

=head2 has_attrs

    ::MD::has_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, Signature);

I<TODO.>

=head2 has_just_attrs

    ::MD::has_just_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, Signature);

I<TODO.>

=head1 STRUCTURAL DATA TYPES

=head2 Structural

    ::MD::Structural ::= interface
        composes {Attributive and_provides_its_default,
            Accessible and_provides_its_default}
        requires_implements {has_any_attrs,nullary
            ,is_unary,degree,heading,rename
            ,on,update,extend
            ,has_attrs,has_just_attrs
            ,at
            ,to_Tuple};

The interface contract C<Structural> is infinite.  A C<Structural> value is
an C<Attributive> value that has exactly 1 member, meaning the value is or
is isomorphic to a C<Tuple>, meaning each attribute name has exactly 1
corresponding attribute asset.  The default value of C<Structural> is the
C<Tuple> value with zero attributes, C<()>.  C<Structural> is composed by
C<Tuple>.

=head2 can_project_matching (Structural)

    ::MD::can_project_matching::Structural ::= function
        --> Boolean <-- (Structural, Structural)
        implements 2::""
        : (if \<0 @? \<1 then \<0 %= @\<1 = \<1 else False);

The function C<can_project_matching::Structural> results in C<True> iff the
heading of its C<0> argument is a superset of the heading of its C<1>
argument and every commonly-named attribute of the two arguments also has
the same attribute asset; otherwise it results in C<False>.  Note that by
definition, the identity C<can_project_matching(update(a,s),s) = True> aka
C<a %:= s %=? s = True> should hold for all valid C<a> and C<s>.  This
function implements the C<Attributive> virtual function
C<can_project_matching> aka C<%=?> for the composing type C<Structural>.

=head2 has_any_at (Structure)

    ::MD::has_any_at::Structure ::= function
        --> Boolean <-- (Structure, Attr_Name)
        implements 2::""
        : (\<0 @? \<1);

The function C<has_any_at::Structure> results in C<True> iff its C<0>
argument has an attribute whose attribute name is equal to its C<1>
argument; otherwise it results in C<False>.  This function implements the
C<Accessible> virtual function C<has_any_at> aka C<.?> for the composing
type C<Structure>.

=head2 has_mapping_at (Structural)

    ::MD::has_mapping_at::Structural ::= function
        --> Boolean <-- (Structural, (Attr_Name, Any))
        implements 2::""
        : (if \<0 .? \>>0 then \<0.\>>0 = \>>1 else False);

The function C<has_mapping_at::Structural> results in C<True> iff its C<0>
argument has an attribute whose name and asset are equal to the function's
C<1> argument's C<0> and C<1> attribute assets, respectively; otherwise it
results in C<False>.  This function implements the C<Accessible> virtual
function C<has_mapping_at> aka C<.:?> for the composing type C<Structural>.

=head2 mapping_at (Structural)

    ::MD::mapping_at::Structural ::= function
        --> (Attr_Name, Any) <-- (Structural, Attr_Name)
        implements 2::""
        requires (\<0 .? \<1)
        : ((\<1, \<0.\<1));

The function C<mapping_at::Structural> results in a binary C<Tuple> whose
C<0> attribute is the function's C<1> argument and whose C<1> attribute is
the attribute asset value of the function's C<0> argument whose attribute
name is equal to its C<1> argument.  This function will fail if the C<0>
argument doesn't have such an attribute.  This function implements the
C<Accessible> virtual function C<mapping_at> aka C<.:> for the composing
type C<Structural>.

=head2 maybe_at (Structural)

    ::MD::maybe_at::Structural ::= function
        --> Any <-- (Structural, Attr_Name)
        implements 2::""
        : (if \<0 .? \<1 then \<0.\<1 else Excuse::No_Such_Attr_Name());

The function C<maybe_at::Structural> results in the attribute asset value
of its C<0> argument whose attribute name is equal to its C<1> argument,
iff there is such an attribute; otherwise it results in an C<Excuse>.  This
function implements the C<Accessible> virtual function C<maybe_at> aka
C<.!> for the composing type C<Structural>.

=head2 replace_at (Structure)

    ::MD::replace_at::Structure ::= function
        --> Structure <-- (Structure, (Attr_Name, Any))
        implements 2::""
        requires (\<0 .? \>>0)
    : (\<0 update \<1 --> \D1::());

The function C<replace_at::Structure> results in the value of its C<0>
argument's collection type that has all of the attributes of the function's
C<0> argument but that, for the 1 attribute of the C<0> argument whose
attribute name is equal to the function's C<1> argument's C<0> attribute
asset, the result's attribute instead has an asset equal to the C<1>
argument's C<1> attribute asset.  This function will fail if the C<0>
argument doesn't have an attribute with that name.  This function
implements the C<Accessible> virtual function C<replace_at> aka C<.:=> for
the composing type C<Structure>.

=head2 shiftless_insert_at (Structure)

    ::MD::shiftless_insert_at::Structure ::= function
        --> Structure <-- (Structure, (Attr_Name, Any))
        implements 2::""
        requires (not \<0 .? \>>0)
        : (\<0 extend \<1 --> \D1::());

The function C<shiftless_insert_at::Structure> results in the value of its
C<0> argument's collection type that has all of the attributes of the
function's C<0> argument plus 1 additional attribute whose name and asset
are equal to the function's C<1> argument's C<0> and C<1> attribute assets,
respectively.  This function will fail if the C<0> argument already has an
attribute with that name.  This function implements the C<Accessible>
virtual function C<shiftless_insert_at> aka C<.+> for the composing type
C<Structure>.

=head2 shiftless_remove_at (Structure)

    ::MD::shiftless_remove_at::Structure ::= function
        --> Structure <-- (Structure, Attr_Name)
        implements 2::""
        requires (\<0 .? \<1)
        : (\<0 but \<1);

The function C<shiftless_remove_at::Structure> results in the value of its
C<0> argument's collection type that has all of the attributes of the
function's C<0> argument minus 1 existing attribute whose name is equal to
its C<1> argument.  This function will fail if the C<0> argument doesn't
have such an attribute.  This function implements the C<Accessible> virtual
function C<shiftless_remove_at> aka C<.-> for the composing type
C<Structure>.

=head2 replace_or_insert_at (Structural)

    ::MD::replace_or_insert_at::Structural ::= function
        --> Structural <-- (Structural, (Attr_Name, Any))
        implements 2::""
        : (\<0 update_or_extend \<1 --> \D1::());

The function C<replace_or_insert_at::Structural> behaves identically in
turn to each of the functions C<replace_at> and C<shiftless_insert_at> when
given the same arguments, where the C<0> argument does or doesn't,
respectively, have an attribute whose attribute name is equal to the C<1>
argument's C<0> attribute.  This function implements the C<Accessible>
virtual function C<replace_or_insert_at> aka C<.=+> for the composing type
C<Structural>.

=head2 shiftless_maybe_remove_at (Structural)

    ::MD::shiftless_maybe_remove_at::Structural ::= function
        --> Structural <-- (Structural, Attr_Name)
        implements 2::""
        : (\<0 maybe_but \<1);

The function C<shiftless_maybe_remove_at::Structural> behaves identically
to C<shiftless_remove_at> when given the same arguments but that it simply
results in its C<0> argument when that has no attribute whose attribute
name matches its C<1> argument, rather than fail.  This function implements
the C<Accessible> virtual function C<shiftless_maybe_remove_at> aka C<.?->
for the composing type C<Structural>.

=head2 to_Tuple %

    ::MD::to_Tuple::"" ::= function virtual --> Tuple <-- (Structural);

    ::MD::"%" ::= alias of to_Tuple;

The virtual function C<to_Tuple> aka C<%> results in the C<Tuple> value
that represents the same set of attributes as its C<0> argument.  The
purpose of C<to_Tuple> is to canonicalize C<Structural> values so they can
be treated abstractly as sets of attributes with minimal effort.

=head1 TUPLE DATA TYPES

=head2 Tuple

    ::MD::Tuple::"" ::= selection where (\<*args -->^ FDN__is_a_Tuple)
        default (())
        composes Structural and_provides_its_default;

The selection contract C<Tuple> represents the infinite Muldis D Foundation
type I<FDN__Tuple>.  A C<Tuple> value is a general purpose
arbitrarily-large unordered heterogeneous collection of named
I<attributes>, such that no 2 attributes have the same I<attribute name>,
which explicitly does not represent any kind of thing in particular, and is
simply the sum of its attributes.  An attribute is conceptually a
name-asset pair, the name being used to look up the attribute in a
C<Tuple>.  An I<attribute name> is an unqualified program identifier,
isomorphic to a C<String> value, and is conceptually a character string
that is not a C<Text> value; it forms the basis for Muldis D identifiers.
In the general case each attribute of a tuple is of a distinct data type,
though multiple attributes often have the same type.  The set of attribute
names of a C<Tuple> is called its I<heading>, and the corresponding
attribute assets are called its I<body>.  With respect to the relational
model of data, a I<heading> represents a predicate, for which each
I<attribute name> is a free variable, and a C<Tuple> as a whole represents
a derived proposition, where the corresponding attribute asset values
substitute for the free variables; however, any actual predicate/etc is
defined by the context of a C<Tuple> value and a C<Tuple> in isolation
explicitly does not represent any proposition in particular.  The default
value of C<Tuple> is C<()>, the only zero-attribute C<Tuple> value.  Other
programming languages may name their corresponding types I<Capture> or
I<Stash> or I<record> or I<struct> or I<row> or I<DataRow> or I<Hash>.

=head2 Tuple_D0 D0

    ::MD::Tuple_D0 ::= constant (());

    ::MD::D0 ::= alias of Tuple_D0;

The constant C<Tuple_D0> aka C<D0> represents the only zero-attribute
C<Tuple> value.

=head2 Tuple_D1

    ::MD::Tuple_D1 ::= selection of Tuple
        where (is_unary \<0)
        default ((False));

The selection contract C<Tuple_D1> represents the infinite type consisting
just of the C<Tuple> values having exactly 1 attribute.  Its default value
has just the attribute with the name C<0> and asset value of C<False>.

=head2 D1

    ::MD::D1 ::= function --> Tuple_D1 <-- (Attr_Name, Any)
        : (\<*args -->^ FDN__Tuple_D1_select);

The function C<D1> results in the C<Tuple_D1> value whose sole attribute's
name is is specified in its C<0> argument and that attribute's value is
specified in its C<1> argument.

=head2 has_any_attrs (Tuple)

    ::MD::has_any_attrs::Tuple ::= function --> Boolean <-- (Tuple)
        implements 2::""
        : (\<0 != ());

The function C<has_any_attrs::Tuple> results in C<True> iff its C<0>
argument has any attributes, and in C<False> iff it has no attributes.
This function implements the C<Attributive> virtual function
C<has_any_attrs> aka C<?@> for the composing type C<Tuple>.

=head2 nullary (Tuple)

    ::MD::nullary::Tuple ::= function --> Tuple <-- (Tuple)
        implements 2::""
        : (());

The function C<nullary::Tuple> results in the only zero-attribute C<Tuple>
value.  This function implements the C<Attributive> virtual function
C<nullary> for the composing type C<Tuple>.

=head2 is_unary (Tuple)

    ::MD::is_unary::Tuple ::= function --> Boolean <-- (Tuple)
        implements 2::""
        : (degree::(\<0) = 1);

The function C<is_unary::Tuple> results in C<True> iff its C<0> argument
has exactly 1 attribute, and C<False> otherwise.  This function implements
the C<Attributive> virtual function C<is_unary> for the composing type
C<Tuple>.

=head2 degree (Tuple)

    ::MD::degree::Tuple ::= function --> Integer_NN <-- (Tuple)
        implements 2::""
        : (\<*args -->^ FDN__Tuple_degree);

The function C<degree::Tuple> results in the integral count of the
attributes of its C<0> argument.  This function implements the
C<Attributive> virtual function C<degree> aka C<#@> for the composing type
C<Tuple>.

=head2 heading (Tuple)

    ::MD::heading::Tuple ::= function --> Heading <-- (Tuple)
        implements 2::""
        : (\<*args -->^ FDN__Tuple_heading);

The function C<heading::Tuple> results in the relational I<heading> of its
C<0> argument, that is its set of distinct attribute names.  This function
implements the C<Attributive> virtual function C<heading> aka C<@> for the
composing type C<Tuple>.

=head2 rename (Tuple)

    ::MD::rename::Tuple ::= function --> Tuple <-- (Tuple, Renaming)
        implements 2::""
        requires (...)
        : (\<*args -->^ FDN__Tuple_rename);

The function C<rename::Tuple> results results in the I<relational rename>
of its C<0> argument in terms of its C<1> argument.  The result is a
C<Tuple> value that has all of the attributes of the function's C<0>
argument but that, for each attribute of the C<0> argument whose attribute
name matches a I<before> element of its C<1> argument, the result's
corresponding attribute instead has an attribute name that matches the
corresponding I<after> element of the C<1> argument.  The I<degree> of the
result is equal to the degree of the C<0> argument.  This function will
fail if any I<before> element of the C<1> argument does not match the name
of an attribute name of the C<0> argument, or if any I<after> element of
the former does match an attribute name of the latter that isn't being
renamed.  This function implements the C<Attributive> virtual function
C<rename> aka C<@:=> aka C<ρ> for the composing type C<Tuple>.

=head2 on (Tuple)

    ::MD::on::Tuple ::= function --> Tuple <-- (Tuple, Heading)
        implements 2::""
        requires (\<0 @? \<1)
        : (\<*args -->^ FDN__Tuple_on);

The function C<on::Tuple> results in the I<relational projection> of its
C<0> argument in terms of its C<1> argument.  The result is a C<Tuple>
value that has all of the attributes of the function's C<0> argument whose
names match the names of attributes of its C<1> argument. The I<degree> of
the result is equal to the degree of the C<1> argument.  This function will
fail if the I<heading> of the C<1> argument is not a subset of the
I<heading> of the C<0> argument.  This function implements the
C<Attributive> virtual function C<on> aka C<project> aka C<%=> aka C<π> for
the composing type C<Tuple>.

=head2 update (Tuple)

    ::MD::update::Tuple ::= function --> Tuple <-- (Tuple, Tuple)
        implements 2::""
        requires (\<0 @? \<1)
        : (\<*args -->^ FDN__Tuple_update);

The function C<update::Tuple> results in a C<Tuple> value that has all of
the attributes of the function's C<0> argument but that, for each attribute
of the C<0> argument whose attribute name I<K> matches the name of an
attribute of its C<1> argument, the result takes its corresponding
attribute from the C<1> argument rather than from the C<0> argument.  The
I<degree> of the result is equal to the degree of the C<0> argument.  This
function will fail if the I<heading> of the C<1> argument is not a subset
of the I<heading> of the C<0> argument.  This function implements the
C<Attributive> virtual function C<update> aka C<%:=> for the composing type
C<Tuple>.

=head2 extend (Tuple)

    ::MD::extend::Tuple ::= function --> Tuple <-- (Tuple, Tuple)
        implements 2::""
        requires (\<0 disjoint_heading \<1)
        is {associative,commutative} identity (())
        : (\<*args -->^ FDN__Tuple_extend);

The function C<extend::Tuple> results in the I<relational extension> of its
C<0> argument in terms of its C<1> argument.  The result is a C<Tuple>
value that has all of the attributes of the function's C<0> argument plus
all of the attributes of its C<1> argument.  The I<degree> of the result is
equal to the integral sum of the degrees of the 2 arguments.  This function
will fail if the I<headings> of the 2 arguments are not disjoint.  This
function implements the C<Attributive> virtual function C<extend> aka C<%+>
for the composing type C<Tuple>.

=head2 has_attrs (Tuple)

    ::MD::has_attrs::Tuple ::= function --> Boolean <-- (Tuple, Signature)
        implements 2::""
        : (...);

I<TODO.>
I<TODO.  Like, we should be able to implement these in pure Muldis D simply.>

=head2 has_just_attrs (Tuple)

    ::MD::has_just_attrs::Tuple ::= function --> Boolean <-- (Tuple, Signature)
        implements 2::""
        : (...);

I<TODO.>

=head2 at (Tuple)

    ::MD::at::Tuple ::= function --> Any <-- (Tuple, Attr_Name)
        implements 2::""
        requires (\<0 .? \<1)
        : (\<*args -->^ FDN__Tuple_at);

The function C<at::Tuple> results in the attribute asset value of its C<0>
argument whose attribute name is equal to its C<1> argument.  This function
will fail if the C<0> argument doesn't have such an attribute.  This
function implements the C<Accessible> virtual function C<at> aka C<.> for
the composing type C<Tuple>.

=head2 to_Tuple (Tuple)

    ::MD::to_Tuple::Tuple ::= function --> Tuple <-- (Tuple)
        implements 2::""
        : (\<0);

The function C<to_Tuple::Tuple> simply results in its C<0> argument.  This
function implements the C<Structural> virtual function C<to_Tuple> aka C<%>
for the composing type C<Tuple>.

=head2 any_attrs

    ::MD::any_attrs ::= function --> Boolean <-- (Tuple, Function_Call_But_0)
        : (\<*args -->^ FDN__Tuple_any_attrs);

I<TODO.>

=head2 none_of_attrs

    ::MD::none_of_attrs ::= function negates any_attrs;

I<TODO.>

=head2 all_attrs

    ::MD::all_attrs ::= function --> Boolean <-- (Tuple, Function_Call_But_0)
        : (\<0 none_of_attrs ((function : (not \<1 <-- (\<0,))) \<-- (:<1,)));

I<TODO.>

=head2 attrs_where

    ::MD::attrs_where ::= function --> Tuple <-- (Tuple, Function_Call_But_0)
        : (\<*args -->^ FDN__Tuple_attrs_where);

I<TODO.>

=head2 attrs_map

    ::MD::attrs_map ::= function --> Tuple <-- (Tuple, Function_Call_But_0)
        : (\<*args -->^ FDN__Tuple_attrs_map);

I<TODO.>

=head2 attrs_reduce

    ::MD::attrs_reduce ::= function --> Any <-- (Tuple, Function_Call_But_0_1)
        : (\<*args -->^ FDN__Tuple_attrs_reduce);

I<TODO.>

=head1 RELATIONAL DATA TYPES

=head2 Relational

    ::MD::Relational ::= interface
        composes {Unionable, Attributive}
        requires_implements {...};

I<TODO.>

=head1 TUPLE-ARRAY DATA TYPES

=head2 Tuple_Array

    ::MD::Tuple_Array ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Tuple_Array, \1::_Asset() ))
            default (~%@())
            composes {Relational, Positional};

        _Asset ::= selection of Tuple where
        (
            if \<0 has_just_attrs ( heading : \Heading::(), body : \Array::() ) then
                if \<<body all \Tuple::() then
                    \<<body all (function : (\has_just_attrs::() \<-- \<<heading))
                else
                    False
            else
                False
        );
    };

I<TODO.>

I<Note:  The in_order(TA,TA) inherited via Positional, which Tuple_Array
implements just for convenience and consistency with Array but doesn't
expect to be meaningful any more than say the Boolean version...
It needs to inline the in_order(Tuple,Tuple) used for its heading and for
its first nonmatching member, rather than Tuple implementing an in_order(),
since we don't want to infect the generic Tuple with all the Orderable ops.>
I<Note: This type structurally resembles a spreadsheet or a .Net DataTable,
or a subtype of it does.>

=head2 Tuple_Array_D0C0

    ::MD::Tuple_Array_D0C0 ::= constant (~%@());

The constant C<Tuple_Array_D0C0> represents the only zero-attribute,
zero-tuple C<Tuple_Array> value.

=head2 Tuple_Array_D0C1

    ::MD::Tuple_Array_D0C1 ::= constant (~%[()]);

The constant C<Tuple_Array_D0C1> represents the only zero-attribute,
single-tuple C<Tuple_Array> value.

=head1 RELATION DATA TYPES

=head2 Relation

    ::MD::Relation ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Relation, \1::_Asset() ))
            default (?%@())
            composes {Relational and_provides_its_default, Discrete, Setty};

        _Asset ::= selection of Tuple_Bag
            where (all_unique \<0);
    };

I<TODO.  See also definition of Set in terms of Bag, which Relation mirrors.>

=head2 Relation_D0C0 D0C0

    ::MD::Relation_D0C0 ::= constant (?%@());

    ::MD::D0C0 ::= alias of Relation_D0C0;

The constant C<Relation_D0C0> aka C<D0C0> represents the only
zero-attribute, zero-tuple C<Relation> value.  Note that I<The Third
Manifesto> also refers to this value by the special name I<TABLE_DUM>.

=head2 Relation_D0C1 D0C1

    ::MD::Relation_D0C1 ::= constant (?%{()});

    ::MD::D0C1 ::= alias of Relation_D0C1;

The constant C<Relation_D0C1> aka C<D0C1> represents the only
zero-attribute, single-tuple C<Relation> value.  Note that I<The Third
Manifesto> also refers to this value by the special name I<TABLE_DEE>.

=head1 TUPLE-BAG DATA TYPES

=head2 Tuple_Bag

    ::MD::Tuple_Bag ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Tuple_Bag, \1::_Asset() ))
            default (+%@())
            composes {Relational, Discrete};

        _Asset ::= selection of Tuple where
        (
            if \<0 has_just_attrs ( heading : \Heading::(), body : \Bag::() ) then
                if \<<body all \Tuple::() then
                    \<<body all (function : (\has_just_attrs::() \<-- \<<heading))
                else
                    False
            else
                False
        );
    };

I<TODO.>

=head2 Tuple_Bag_D0C0

    ::MD::Tuple_Bag_D0C0 ::= constant (+%@());

The constant C<Tuple_Bag_D0C0> represents the only zero-attribute,
zero-tuple C<Tuple_Bag> value.

=head2 Tuple_Bag_D0C1

    ::MD::Tuple_Bag_D0C1 ::= constant (+%{()});

The constant C<Tuple_Bag_D0C1> represents the only zero-attribute,
single-tuple C<Tuple_Bag> value.

I<TODO: Note, yes, a Set rather than Bag arg is ok since multiplicity=1 here.>

=head1 INTERVALISH DATA TYPES

=head2 Intervalish

    ::MD::Intervalish ::= interface
        composes Homogeneous
        requires_implements {...};

I<TODO.>

=head1 INTERVAL DATA TYPES

=head2 Interval

    ::MD::Interval ::= selection of Capsule
        where (has_wrapped::( \<0, \Interval, \Tuple::Interval() ))
        default ((-∞)..(+∞))
        composes {Intervalish, Setty};

I<TODO.>

=head2 Tuple::Interval

    ::MD::Tuple::Interval ::= selection of Tuple
        where (...);

I<TODO.>

=head1 UNIONABLE INTERVALISH DATA TYPES

=head2 Unionable_Intervalish

    ::MD::Unionable_Intervalish ::= interface
        composes {Intervalish, Unionable}
        requires_implements {...};

I<TODO.>

=head1 INTERVAL-SET DATA TYPES

=head2 Interval_Set

    ::MD::Interval_Set ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Interval_Set, \1::_Asset() ))
            default (...)
            composes {Unionable_Intervalish, Setty};

        _Asset ::= selection of Interval_Bag
            where (all_unique \<0);
    };

I<TODO.  See also definition of Set in terms of Bag, which Interval_Set mirrors.>

=head1 INTERVAL-BAG DATA TYPES

=head2 Interval_Bag

    ::MD::Interval_Bag ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Interval_Bag, \1::_Asset() ))
            default (...)
            composes Unionable_Intervalish;

        _Asset ::= selection of Tuple_Bag where
        (
            ...
        );
    };

I<TODO.>

=head1 QUANTITATIVE DATA TYPES

=head2 Quantitative

    ::MD::Quantitative ::= interface
        composes Numerical
        requires_implements {...};

I<TODO.>

=head1 QUANTITY DATA TYPES

=head2 Quantity

    ::MD::Quantity ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Quantity, \1::_Asset() ))
            default (...)
            composes Quantitative;

        _Asset ::= selection of Relation where
        (
            ...
        );
    };

I<TODO.>

=head1 CAPSULE DATA TYPES

=head2 Capsule

    ::MD::Capsule::"" ::= selection where (\<*args -->^ FDN__is_a_Capsule)
        default (False wrap False);

The selection contract C<Capsule> represents the infinite Muldis D
Foundation type I<FDN__Capsule>.  An C<Capsule> value is ...

I<TODO.  Candidate literal syntax is `\:(wrapper,asset)`.>

Given that almost every selection contract is a subset of
C<Capsule>, the latter intentionally does not compose any interface
contracts, and only has the minimal set of its own operators, so to
minimize interference with other types' interfaces.

=head2 Capsule::wrap

    ::MD::Capsule::wrap ::= function --> Capsule <-- (Any, Any)
        : (\<*args -->^ FDN__Capsule_wrap);

I<TODO.>

=head2 Capsule::wrapper

    ::MD::Capsule::wrapper ::= function --> Any <-- (Capsule)
        : (\<*args -->^ FDN__Capsule_wrapper);

I<TODO.>

=head2 Capsule::unwrap

    ::MD::Capsule::unwrap ::= function --> Any <-- (Capsule)
        : (\<*args -->^ FDN__Capsule_unwrap);

I<TODO.>

=head2 Capsule::has_wrapped

    ::MD::Capsule::has_wrapped ::= function
        --> Boolean <-- (Capsule, Any, Function_Call_But_0)
        : ((wrapper \<0) = \<1 and (unwrap \<0,) --> \<2);

I<TODO.  Says wrapper equals a value and asset passes a filter.>

=head1 EXTERNAL DATA TYPES

=head2 External

    ::MD::External::"" ::= selection where (\<*args -->^ FDN__is_a_External)
        default (() -->^ FDN__default_External);

The selection contract C<External> represents the infinite Muldis D
Foundation type I<FDN__External>.  An C<External> value is an opaque and
transient reference to an entity that is defined and managed externally to
the Muldis D language environment, either internally to the Muldis D host
implementation or in some peer language that it mediates.  Its default
value is implementation-defined.

As C<External> values are black boxes to Muldis D, it is the responsibility
of their external manager to at the very least implement the C<same>
function for them in a fully deterministic manner, as well as externally
define any other operators for them that users may wish to invoke for those
values from Muldis D code, including any to map with or marshal with Muldis
D values.

=head2 External::call_function

    ::MD::External::call_function ::= function --> Any <-- (Any)
        : (FDN__External_call_function ^<-- \<*args);

The function C<External::call_function> is a proxy for invoking a function
that is defined and managed externally to the Muldis D language
environment.  Muldis D will assume said function is completely
deterministic, and there would likely be problems if it isn't.  Using
C<External::call_function> as a foundation, it is possible to define an
arbitrarily complex type graph involving C<External> values.

=head1 SOURCE CODE BEHAVIOURAL DATA TYPES

I<TODO.>

=head2 Source_Code::Package_List

    ::MD::Source_Code::Package_List ::= selection of Array
        where (\<0 all (selection of {Package, Decoration}));

I<TODO.>

=head2 Source_Code::Package

    ::MD::Source_Code::Package ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Package, \1::_Asset() ))
            default (\Package wrap 1::_Asset());

        _Asset ::= selection of Tuple where
        (
            if
                \<0 has_just_attrs (
                    identity : (selection of Pkg_Decl_Map where (is_unary \<0)),
                    foundation : ...,
                    uses : \Pkg_Decl_Map::(),
                    entry : ...,
                    floating : ...,
                    materials : ...,
                    annotation : ...,
                    decoration : ...,
                )
            then
                \<<uses disjoint_heading \<<identity
            else
                False
        );
    };

I<TODO.>
I<Remember that "floating" can't search inside a binder, can only resolve to a binder or parent.>

=head2 Source_Code::Pkg_Decl_Map

    ::MD::Source_Code::Pkg_Decl_Map ::= selection of Tuple
        where (\<0 all_attrs (function : (Pkg_Canon_Name \<<asset)));

I<TODO.>

=head2 Source_Code::Heading

    ::MD::Source_Code::Heading ::= selection of Tuple
        where (\<0 all_attrs (function : (\<<asset = True)));

I<TODO.>

I<TODO.  For the likes of all_attrs etc consider making \<0 a unary tuple
instead whereupon keywords analagous to name/asset are used, if we had such
a thing for opening tuples as for creating them.>

=head2 Source_Code::Attr_Name

    ::MD::Source_Code::Attr_Name ::= selection of Heading
        where (is_unary \<0);

I<TODO.>

=head2 Source_Code::Key_Asset_Pair

    ::MD::Source_Code::Key_Asset_Pair ::= selection of Tuple
        where (@\<0 = \@(key,asset));

I<TODO.>

=head1 SOURCE CODE ANNOTATION DATA TYPES

I<TODO.>

=head2 Source_Code::Annotation

    ::MD::Source_Code::Annotation::"" ::= interface;

I<TODO.>

I<Annotations can include what otherwise would be a separate special table
for higher level DBMS mappers such as Entity Framework or DBIx::Class to
track their own metadata within a database, such as an easy way to tell if
the database schema version matches what the application expects.>

=head1 SOURCE CODE DECORATION DATA TYPES

I<TODO.  Generally speaking, all Decoraction types are declared by a
package that is not Core, such as in some Core::Plain_Text/etc package.>

I<TODO:  The decoration data types may loosely resemble template defs so
that decorations don't necessarily have to be attached to all
behavioral/annotation nodes they are conceptually adjacent / apply to but
rather can be in some nearby parent context and refer to behavioral/etc
nodes by name.>

I<When representing extra info used by eg EF/DBIC, that should be split
between Annotation and Decoration depending on whether it affects behavior
in any way / would cause a problem if missing, or if it is purely cosmetic
and would not cause a problem if missing.>

=head2 Source_Code::Decoration

    ::MD::Source_Code::Decoration::"" ::= interface;

I<TODO.>

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::See_Also> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the B<Muldis D Standard
Library> (B<MDSL>) primary component of the B<Muldis D> language
specification.  MDSL substantially comprises executable code as well.

MDSL is Copyright © 2002-2016, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D::Standard_Library> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
