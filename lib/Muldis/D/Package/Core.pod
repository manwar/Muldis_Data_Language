=pod

=encoding utf8

=head1 NAME

Muldis::D::Package::Core -
Muldis D core data types and operators

=head1 VERSION

This document is Muldis::D::Package::Core version 0.201.0.-9.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document
before you read this one, which provides subservient details.

=head1 SYNOPSIS

    Muldis_D:Plain_Text:"http://muldis.com":"0.201.0.-9";
    script ASCII;
    package
    {
        identity My_App ::= My_App:"http://mycorp.com":"0";
        foundation "http://muldis.com":"0.201.0.-9";
        uses MD ::= Core:"http://muldis.com":"0.201.0.-9";
        floating {::My_App, ::MD};
        `TODO: Put example routines etc here.`
    };

=head1 DESCRIPTION

This document defines the Muldis D Plain Text package
C<Core:"http://muldis.com":"0.201.0.-9"> which provides the common core
system-defined data types and operators that regular users of the language
would employ directly in their applications and schemas.

This document I<also> defines the Muldis D Plain Text package
C<Core::Aliases:"http://muldis.com":"0.201.0.-9"> which adds trans-ASCII
Unicode aliases to C<Core> package entities.

=head1 PACKAGES

From one source:

    Muldis_D:Plain_Text:"http://muldis.com":"0.201.0.-9";
    script ASCII;
    package
    {
        identity MD ::= Core:"http://muldis.com":"0.201.0.-9";
        foundation "http://muldis.com":"0.201.0.-9";
        floating {::MD, ::MD::Round_Meth, ::MD::Capsule, ::MD::Source_Code};
        ...
    };

From a separate source:

    Muldis_D:Plain_Text:"http://muldis.com":"0.201.0.-9";
    script Unicode:8.0:UTF-8:canon;
    package
    {
        identity MDA ::= Core::Aliases:"http://muldis.com":"0.201.0.-9";
        foundation "http://muldis.com":"0.201.0.-9";
        uses MD ::= Core:"http://muldis.com":"0.201.0.-9";
        floating {::MD, ::MDA};
        ...
    };

=head1 MAXIMAL AND MINIMAL DATA TYPES

=head2 Any

    ::MD::Any ::= selection default (False);

The selection contract C<Any> represents the infinite
I<universal type>, which is the maximal data type of the entire Muldis D
type system and consists of all values which can possibly exist.  It also
represents the infinite Muldis D Foundation type I<FDN__Any>.  Its
default value is C<False>.  Other programming languages may name their
corresponding types I<Object> or I<Universal>.

=head2 None

    ::MD::None ::= selection of {};

The selection contract C<None> represents the finite I<empty type>,
which is the minimal data type of the entire Muldis D type system and
consists of exactly zero values.  It can not have any default value.

=head2 same =

    ::MD::same ::= function --> Boolean <-- (Any, Any)
        is commutative
        : (topic -->^ FDN__same);

    ::MD::"=" ::= alias of same;

The function C<same> aka C<=> results in C<True> iff its 2 arguments C<0>
and C<1> are exactly the same value, and C<False> otherwise.  Other
programming languages may name their corresponding operators I<==> or
I<===> or I<eq>.

Note that C<same> is guaranteed to result in C<False> when exactly one of
its 2 arguments is an C<External> value but beyond that its behavior when
both of its arguments are C<External> values is implementation defined, in
that implementations are expected to make it completely deterministic
according to appropriate rules of value distinctness for the external
environment in question; for example, if the external entity referenced by
an C<External> value is considered a mutable container, then 2 C<External>
should only be considered I<same> if they both point to the same container,
and not if two distinct containers have the same content.

=head2 not_same != ≠

    ::MD::not_same ::= function negates same
        is commutative;

    ::MD::"!=" ::= alias of not_same;
    ::MDA::"≠" ::= alias of not_same;

The function C<not_same> aka C<!=> aka C<≠> results in C<False> iff its 2
arguments C<0> and C<1> are exactly the same value, and C<True> otherwise.
Other programming languages may name their corresponding operators
I<< <> >> or I<!===> or or I<~=> or I<^=> or I<ne>.

=head2 is_a

    ::MD::is_a ::= function --> Boolean <-- (Any, Reference)
        : (\.0 --> \.1);

The function C<is_a> results in C<True> iff its C<0> argument is a
member of the type specified by its C<1> argument, and C<False> otherwise.

=head2 not_is_a

    ::MD::not_is_a ::= function negates is_a;

The function C<not_is_a> results in C<False> iff its C<0> argument is a
member of the type specified by its C<1> argument, and C<True> otherwise.

=head2 default

    ::MD::default ::= function --> Any <-- (Reference)
        : (--> \.0);

The function C<default> results in the default value of the not-empty type
specified by its C<0> argument.

=head1 EXCUSE DATA TYPES

=head2 Excuse

    ::MD::Excuse::"" ::= interface;

The semantic contract C<Excuse> is infinite.  An C<Excuse> value is an
explicitly stated reason for why, given some particular problem domain, a
value is not being used that is ordinary for that domain.  For example, the
typical integer division operation is not defined to give an integer result
when the divisor is zero, and so a Muldis D function for integer division
could be defined to result in an C<Excuse> value rather than throw an
exception in that case.  For another example, an C<Excuse> value could be
used to declare that the information we are storing about a person is
missing certain details and why those are missing, such as because the
person left the birthdate field blank on their application form.  Its
default value is C<Excuse::No_Reason>.  An C<Excuse> is isomorphic to an
C<Exception> but that use of the former is not meant to terminate execution
of code early unlike the latter which is.  Other programming languages that
have typed exceptions are analogous.

=head2 Excuse::No_Reason

    ::MD::Excuse::No_Reason ::= constant (\@0)
        composes Excuse and_provides_its_default;

The constant C<Excuse::No_Reason> represents the C<Excuse> value which
simply says that an ordinary value for any given domain is missing and that
there is simply no excuse that has been given for this; in other words,
something has gone wrong without the slightest hint of an explanation.
This is conceptually the most generic C<Excuse> value there is and it can
be used by lazy programmers as a fallback for when they don't have even a
semblance of a better explanation for why an ordinary value is missing.
Other programming languages may name their corresponding values or
quasi-values I<null> or I<nil> or I<none> or I<nothing> or I<undef> or
I<unknown>; but unlike some of those languages, C<No_Reason> equals itself.

=head2 or_else coalesce

    ::MD::or_else ::= function --> Any <-- (Any, Any)
        is {associative,idempotent}
        : (\.0 --> \@Excuse ?? \.1 !! \.0);

    ::MD::coalesce ::= alias of or_else;

The function C<or_else> aka C<coalesce> results in its C<0>
argument iff the latter is not an C<Excuse>, and results in its C<1>
argument otherwise.  This function is designed to be chained for any number
of sequenced values in order to pick the first non-C<Excuse> in a list.
Other programming languages may name their corresponding operators
I<??> or I<//>.

=head2 and_then

    ::MD::and_then ::= function --> Any <-- (Any, Any)
        is {associative,idempotent}
        : (\.0 --> \@Excuse ?? \.0 !! \.1);

The function C<and_then> results in its C<0> argument iff the latter is an
C<Excuse>, and results in its C<1> argument otherwise.  This function is
designed to be chained for any number of sequenced values in order to pick
the first C<Excuse> in a list.

=head1 ORDERABLE DATA TYPES

=head2 Orderable

    ::MD::Orderable ::= interface
        requires_implements in_order;

The interface contract C<Orderable> is infinite.  An C<Orderable> value has
all of the traditional comparison operators defined for it such that values
of its type I<T> can be deterministically sorted by Muldis D into a
canonical total order.  But I<T> otherwise does not necessarily have
conceptually a total order in the normal sense or that order is different
than what the provided comparison operators give you.  An C<Orderable> type
is a type for which one can take all of its values and place them on a line
such that each value is definitively considered I<before> all of the values
one one side and I<after> all of the values on the other side.  Other
programming languages may name their corresponding types I<IComparable> or
I<Ord> or I<ordered> or I<ordinal>.

The default value of C<Orderable> is the C<Integer> value C<0>.  The
minimum and maximum values of C<Orderable> are C<Neg_Inf> and C<Pos_Inf>,
respectively; these 2 C<Excuse> values are canonically considered to be
before and after, respectively, I<every> other value of the Muldis D type
system, regardless of whether those values are members a type for which an
C<Orderable>-composing contract exists.  The primary reason for having
these values C<Neg_Inf> and C<Pos_Inf> is so Muldis D has an easy
consistent way to define an C<Interval> that is partially or completely
unbounded, and to use as identity values for chained order-comparisons.

C<Orderable> is composed, directly or indirectly, by: C<Neg_Inf>,
C<Pos_Inf>, C<Bicessable>, C<Boolean>, C<Integral>, C<Integer>,
C<Positional>, C<Array>, C<String>, C<Blob>, C<Text>.

=head2 Neg_Inf -∞

    ::MD::Neg_Inf ::= constant (\@0) composes {Orderable, Excuse};

    ::MDA::"-∞" ::= alias of Neg_Inf;

The constant C<Neg_Inf> aka C<-∞> represents the type-agnostic concept of
negative infinity, an C<Orderable> value that sorts I<before> all other
values in the Muldis D type system.  This value is also an C<Excuse> that
says the result of some operation is infinite in the negative direction.
Note that IEEE floating-point standards define a negative infinity value.

=head2 Pos_Inf +∞

    ::MD::Pos_Inf ::= constant (\@0) composes {Orderable, Excuse};

    ::MDA::"+∞" ::= alias of Pos_Inf;

The constant C<Pos_Inf> aka C<-∞> represents the type-agnostic concept of
positive infinity, an C<Orderable> value that sorts I<after> all other
values in the Muldis D type system.  This value is also an C<Excuse> that
says the result of some operation is infinite in the positive direction.
Note that IEEE floating-point standards define a positive infinity value.

=head2 in_order

    ::MD::in_order::"" ::= function virtual
        --> Boolean <-- (Orderable, Orderable);

The virtual function C<in_order> results in C<True> iff its 2 arguments are
considered to already be I<in order> as given to the function, meaning that
either both arguments are exactly the same value or otherwise that the C<0>
argument value is definitively considered I<before> the C<1> argument
value; if C<0> is considered I<after> C<1> then C<in_order> results in
C<False>.  The primary reason for C<in_order> is to underlie all
order-determination or value sorting operations in an easy consistent way;
an C<Orderable>-composing contract only has to implement C<in_order> and
then values of its type can be compared, sorted on, and have intervals
defined in terms of them.

Other programming languages may instead typically use a three-way
comparison operator for this role, where its possible result values are
I<before>, I<same>, and I<after>, and those 3 are typically represented by
either the integers {-1,0,1} or a special 3-valued enumeration type.  Said
operators may be named I<< <=> >> or I<cmp> or I<compare> or I<CompareTo>
or I<memcmp> or I<strcmp>.  But Muldis D uses a C<Boolean> result instead
partly to keep its core type system simpler (it would have gone the
enumeration route) and partly because the logic for doing sorting or
comparisons or validation is typically much simpler with this foundation.

=head2 in_order (Neg_Inf, Pos_Inf)

    ::MD::in_order::Neg_Inf_L ::= function --> Boolean <-- (Neg_Inf, Orderable)
        implements 2::""
        : (True);

    ::MD::in_order::Neg_Inf_R ::= function --> Boolean <-- (Orderable, Neg_Inf)
        implements 2::""
        : (topic --> \@same);

    ::MD::in_order::Pos_Inf_L ::= function --> Boolean <-- (Pos_Inf, Orderable)
        implements 2::""
        : (topic --> \@same);

    ::MD::in_order::Pos_Inf_R ::= function --> Boolean <-- (Orderable, Pos_Inf)
        implements 2::""
        : (True);

The 4 functions {C<in_order::Neg_Inf_L>, C<in_order::Neg_Inf_R>,
C<in_order::Pos_Inf_L>, C<in_order::Pos_Inf_R>} implement the C<Orderable>
virtual function C<in_order> for the composing types C<Neg_Inf> and
C<Pos_Inf>, specifically for comparing either value with any C<Orderable>.

=head2 before <

    ::MD::before ::= function commutes after;

    ::MD::"<" ::= alias of before;

The function C<before> aka C<< < >> results in C<True> iff its C<0>
argument is I<before> its C<1> argument; otherwise it results in C<False>.
Other programming languages may name this operator I<lt>.

=head2 after >

    ::MD::after ::= function negates before_or_same;

    ::MD::">" ::= alias of after;

The function C<after> aka C<< > >> results in C<True> iff its C<0>
argument is I<after> its C<1> argument; otherwise it results in C<False>.
Other programming languages may name this operator I<gt>.

=head2 before_or_same <= ≤

    ::MD::before_or_same ::= alias of in_order;

    ::MD::"<=" ::= alias of before_or_same;
    ::MDA::"≤" ::= alias of before_or_same;

The function C<before_or_same> aka C<< <= >> aka C<≤> results in C<True>
iff its C<0> argument is I<before> its C<1> argument or they are the same
value; otherwise it results in C<False>.  Other programming languages may
name this operator I<le>.

=head2 after_or_same >= ≥

    ::MD::after_or_same ::= function commutes before_or_same;

    ::MD::">=" ::= alias of after_or_same;
    ::MDA::"≥" ::= alias of after_or_same;

The function C<after_or_same> aka C<< >= >> aka C<≥> results in C<True>
iff its C<0> argument is I<after> its C<1> argument or they are the same
value; otherwise it results in C<False>.  Other programming languages may
name this operator I<ge>.

=head2 min

    ::MD::min ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity (Pos_Inf())
        : (topic --> \@in_order ?? \.0 !! \.1);

The function C<min> results in whichever of its 2 arguments is first when
the 2 are sorted I<in order>.  This function is designed to be chained for
any number of values in order to pick the one that sorts
I<before> all of the others.

=head2 max

    ::MD::max ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity (Neg_Inf())
        : (topic --> \@in_order ?? \.1 !! \.0);

The function C<max> results in whichever of its 2 arguments is last when
the 2 are sorted I<in order>.  This function is designed to be chained for
any number of values in order to pick the one that sorts
I<after> all of the others.

=head2 minmax

    ::MD::minmax ::= function
        --> (Orderable, Orderable) <-- (Orderable, Orderable)
        is commutative
        : (topic --> \@in_order ?? topic !! \%(\.1, \.0));

The function C<minmax> results in a binary C<Tuple> containing its 2
arguments sorted I<in order>; the function's result is the same as its
topic when the arguments are already in order, and the reverse of that
otherwise, meaning the values of C<0> and C<1> are swapped.

=head1 SUCCESSABLE DATA TYPES

=head2 Successable

    ::MD::Successable ::= interface
        requires_implements {asset,succ};

The interface contract C<Successable> is infinite.  A C<Successable> value
is a member of a conceptually noncontiguous totally ordered type; it has a
definitive I<successor> value of that type, at least where the given value
isn't the last value.

The primary reason for C<Successable> is to provide an easy consistent and
terse API for a generator of arbitrary sequences of values of any type.  In
this context, a C<Successable> value defines a complete self-contained
I<state> for a sequence generator, which is everything the generator needs
to know to both emit a I<current> value, which we call the I<asset>, as
well as determine all subsequent values of the sequence without any further
input.  To keep the fundamental general case API simple, there is just the
a monadic function to derive the next state from the current one, and a
monadic function to extract the asset from the current state, so actually
reading a sequence of values requires 2 function calls per value in the
general case.  For some trivial cases of C<Successable>, the I<state> and
I<asset> are one and the same, so just 1 function call per value is needed.
Keep in mind that asset values may repeat in a sequence, so it is not them
but rather the state values that have the total order property.  Other
programming languages may name their corresponding types I<sequence> or
I<iterator> or I<enumerator>.

C<Successable> is a less rigorous analogy to C<Bicessable>, where the
latter also requires the ability to produce the I<predecessor> value of the
given value, as well as the ability to determine if 2 arbitrary values are
in order.  While conceptually a C<Successable> has those features, formally
it is not required to because for some types it may be onerous or
unnecessary for its mandate to support those features; for example,
producing a successor state may disgard information otherwise needed to
recall any of its predecessors.

The default and minimum and maximum values of C<Successable> are the same
as those of C<Orderable>.  C<Successable> is composed, directly or
indirectly, by: C<Bicessable>, C<Boolean>, C<Integral>, C<Integer>,
C<Positional>, C<Array>, C<Interval>.

C<Successable> is intended to be a generalized tool for performing I<list
comprehension> or I<set comprehension>.  The typically idiomatic and more
efficient way to do many kinds of such I<comprehensions> is to use the
features of various C<Homogeneous> types to map an existing list or set to
another using generic element mapping and filtering functions, such as a
list of even integers less than a hundred.  With those cases, the
map/filter approach can permit processing elements in any order or in
parallel, and avoiding unnecessary intermediate values.  In contrast, the
primary intended uses of C<Successable> is when either you want to produce
or process a potentially infinite-sized list (lazily) or especially produce
a sequence with uneven step sizes, such as an arbitrary number of
Fibonacci.  This is for cases where it may be necessary to calculate all
the intermediate values in order to arrive at a desired nth one, and doing
them out of sequence or in parallel may not be an option.

=head2 asset

    ::MD::asset::"" ::= function virtual --> Any <-- (Successable);

The virtual function C<asset> results in the I<asset> of its C<0> argument,
which for trivial cases may simply be that same argument.

=head2 succ

    ::MD::succ::"" ::= function virtual
        --> {Successable, Pos_Inf} <-- (Successable);

The virtual function C<succ> results in the I<successor> value of its
C<0> argument, or in C<Pos_Inf> if there is none.  Other programming
languages may name their corresponding operators I<next>.

=head2 nth_succ

    ::MD::nth_succ ::= function
        --> {Successable, Pos_Inf} <-- (Successable, Integer_NN)
    : (
        if !?\.1 then
            \.0
        else
            if (s ::= succ \.0) --> \@Excuse then
                s
            else
                s nth_succ --\.1
    );

The function C<nth_succ> results in the Nth I<successor> value of its C<0>
argument, where N is its C<1> argument, or in C<Pos_Inf> if there is none.

=head1 BICESSABLE DATA TYPES

=head2 Bicessable

    ::MD::Bicessable ::= interface
        composes {Orderable and_provides_its_default,
            Successable and_provides_its_default}
        requires_implements {in_order,asset,pred,succ};

The interface contract C<Bicessable> is infinite.  A C<Bicessable> value
is an C<Orderable> value for which, using the same canonical total order
for its type, there exists definitive I<predecessor> and I<successor>
values, at least where the given value isn't the first or last value on the
line respectively.  Similarly, one can take any two values of a
C<Bicessable> type and produce an ordered list of all of that type's values
which are on the line between those two values.  A primary quality of a
type that is C<Orderable> but not C<Bicessable> is that you can take any
two values of that type and then find a third value of that type which lies
between the first two on the line; by definition for a C<Bicessable> type,
there is no third value between one of its values and that value's
predecessor or successor value.  Other programming languages may name their
corresponding types I<ordinal> or categorically as I<enum>.  Note that
while a generic rational numeric type may qualify as an ordinal type by
some definitions of I<ordinal>, since it is possible to count all the
rationals if arranged a particular way, these types would not qualify as
C<Bicessable> here when that ordering is not the same as the one used for
the same type's C<Orderable> comparisons.  The default and minimum and
maximum values of C<Bicessable> are the same as those of C<Orderable>.
C<Bicessable> is composed, directly or indirectly, by: C<Boolean>,
C<Integral>, C<Integer>.

For some C<Bicessable> types, there is the concept of a I<quantum> or
I<step size>, where every consecutive pair of values on that type's value
line are conceptually spaced apart at equal distances; this distance would
be the quantum, and all steps along the value line are at exact multiples
of that quantum.  However, C<Bicessable> types in general don't need to be
like this, and there can be different amounts of conceivable distance
between consecutive values; a C<Bicessable> type is just required to know
where all the values are.  For example, C<Integer> has a quantum while a
type consisting just of prime integers does not.

Note that while mathematics formally defines I<predecessor> and
I<successor> for non-negative integers only, and some other programming
languages extend this concept to real numbers with the meaning I<minus one>
and I<plus one> respectively, Muldis D only formally associates these terms
with the quantum of I<one> for types specifically representing integers;
for C<Bicessable> types in general, the terms just mean prior or next
values and should not be conceptualized as mathematical operations.

=head2 pred

    ::MD::pred::"" ::= function virtual
        --> {Bicessable, Neg_Inf} <-- (Bicessable);

The virtual function C<pred> results in the I<predecessor> value of its
C<0> argument, or in C<Neg_Inf> if there is none.  Other programming
languages may name their corresponding operators I<prior> or I<previous>.

=head2 nth_pred

    ::MD::nth_pred ::= function
        --> {Bicessable, Neg_Inf} <-- (Bicessable, Integer_NN)
    : (
        if !?\.1 then
            \.0
        else
            if (s ::= pred \.0) --> \@Excuse then
                s
            else
                s nth_pred --\.1
    );

The function C<nth_pred> results in the Nth I<predecessor> value of its C<0>
argument, where N is its C<1> argument, or in C<Neg_Inf> if there is none.

=head1 BOOLABLE DATA TYPES

=head2 Boolable

    ::MD::Boolable ::= interface requires_implements so;

The interface contract C<Boolable> is infinite.  A C<Boolable> value has a
canonical way of being cast to a C<Boolean> value in a context-free manner,
as the answer to the non-specific question "Is that so?" on the value taken
in isolation, whatever that would conceivably mean for the value's type.
The idiomatic predicate being asked has to do with whether or not something
exists; for composing numeric types it is asking whether the number is
nonzero; for composing collection types it is asking whether the collection
has any members.  The primary reason for C<Boolable> is to provide an easy
consistent and terse way to ask a common predicate question such as this.
The default value of C<Boolable> is C<False>.  Other programming languages
often have the concept of particular values from a wide variety of types as
being conceptually either I<false> or I<true>, and C<Boolable> is the
formalization of that concept for Muldis D, allowing program code to be
written in a similar style but with more type safety as any treatment of a
value as a C<Boolean> must be made explicit.

C<Boolable> is composed, directly or indirectly, by: C<Boolean>,
C<Numerical>, C<Integral>, C<Integer>, C<Homogeneous>, C<Positional>,
C<Array>, C<String>, C<Blob>, C<Text>, C<Setty>, C<Set>, C<Bag>,
C<Relation>, C<Tuple_Bag>.

While conceivably C<Boolable> could also be composed by C<Attributive>, and
hence C<Tuple>, it isn't because that would set up a semantic conflict for
C<Relation> and C<Tuple_Bag> which are collections across 2 dimensions, and
it was decided for those latter types that C<Boolable> would apply to them
explicitly in their C<Homogeneous> dimension and not in their
C<Attributive> dimension.  As such, the C<Attributive> functions
C<has_any_attrs> and C<is_nullary> are provided as that dimension's direct
analogies to the C<Homogeneous> dimension's C<Boolable>-implementing
C<has_any_members> (C<so>) and C<is_empty> (C<not_so>) functions.

=head2 so ? to_Boolean

    ::MD::so::"" ::= function virtual --> Boolean <-- (Boolable);

    ::MD::"?"        ::= alias of so;
    ::MD::to_Boolean ::= alias of so;

The virtual function C<so> aka C<?> aka C<to_Boolean> results in C<True>
typically when its C<0> argument is a nonzero number or a nonempty
collection; otherwise it results in C<False>.

=head2 not_so !?

    ::MD::not_so ::= function negates so;

    ::MD::"!?" ::= alias of not_so;

The function C<not_so> aka C<!?> results in C<True> typically when
its C<0> argument is a number zero or an empty collection; otherwise
it results in C<False>.

=head1 BOOLEAN DATA TYPES

=head2 Boolean Bool

    ::MD::Boolean::"" ::= selection where (topic -->^ FDN__is_a_Boolean)
        default (False)
        composes {Bicessable, Boolable and_provides_its_default};

    ::MD::Bool ::= alias of Boolean;

The selection contract C<Boolean> aka C<Bool> represents the finite Muldis
D Foundation type I<FDN__Boolean>.  A C<Boolean> value is a general purpose
2-valued logic boolean or I<truth value>, or specifically it is one of the
2 values C<False> and C<True>.  Its default value is C<False>.  C<Boolean>
is both C<Orderable> and C<Bicessable>; its minimum value is C<False> and
its maximum value is C<True>.  Other programming languages frequently don't
have a dedicated boolean type but rather consider values of other types,
typically integer types, to be I<false> or I<true>.

=head2 False ⊥

    ::MD::False ::= constant (False);

    ::MDA::"⊥" ::= alias of False;

The constant C<False> aka C<⊥> represents the boolean logical truth value
I<false> aka I<contradiction>.  Other programming languages frequently use
the integer 0 to represent I<false>.

=head2 True ⊤

    ::MD::True ::= constant (True);

    ::MDA::"⊤" ::= alias of True;

The constant C<True> aka C<⊤> represents the boolean logical truth value
I<true> aka I<tautology>.  Other programming languages frequently use the
integer 1 to represent I<true>.

=head2 in_order (Boolean)

    ::MD::in_order::Boolean ::= function --> Boolean <-- (Boolean, Boolean)
        implements 2::""
        : (!\.0 or \.1);

The function C<in_order::Boolean> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Boolean>.

=head2 asset (Boolean)

    ::MD::asset::Boolean ::= function --> Boolean <-- (Boolean)
        implements 2::""
        : (\.0);

The function C<asset::Boolean> simply results in its C<0> argument.
This function implements the C<Successable> virtual function C<asset> for
the composing type C<Boolean>.

=head2 pred (Boolean)

    ::MD::pred::Boolean ::= function --> {False, Neg_Inf} <-- (Boolean)
        implements 2::""
        : (\.0 ?? False !! Neg_Inf());

The function C<pred::Boolean> implements the C<Bicessable> virtual
function C<pred> for the composing type C<Boolean>.

=head2 succ (Boolean)

    ::MD::succ::Boolean ::= function --> {True, Pos_Inf} <-- (Boolean)
        implements 2::""
        : (!\.0 ?? True !! Pos_Inf());

The function C<succ::Boolean> implements the C<Successable> virtual
function C<succ> for the composing type C<Boolean>.

=head2 so (Boolean)

    ::MD::so::Boolean ::= function --> Boolean <-- (Boolean)
        implements 2::""
        : (\.0);

The function C<so::Boolean> performs a logical I<proposition>; it simply
results in its C<0> argument.  This function implements the C<Boolable>
virtual function C<so> aka C<?> aka C<to_Boolean> for the composing type
C<Boolean>.

=head2 not ! ¬

    ::MD::not ::= function negates so::Boolean;

    ::MD::"!"  ::= alias of not;
    ::MDA::"¬" ::= alias of not;

The function C<not> aka C<!> aka C<¬> performs a logical I<negation> or
I<logical complement>; it results in C<True> iff its C<0> argument is
C<False> and vice-versa.  Other programming languages may name their
corresponding operators I<~> or I<^> or I<N>.

=head2 and ∧

    ::MD::and ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity (True)
        : (\.0 ?? \.1 !! False);

    ::MDA::"∧"  ::= alias of and;

The function C<and> aka C<∧> performs a logical I<conjunction>; it results
in C<True> iff its 2 arguments C<0> and C<1> are both C<True>, and C<False>
otherwise.  Other programming languages may name their corresponding
operators I<&> or I<&&> or I<K>.

=head2 nand not_and ⊼ ↑

    ::MD::nand ::= function negates and
        is commutative;

    ::MD::not_and ::= alias of nand;
    ::MDA::"⊼"    ::= alias of nand;
    ::MDA::"↑"    ::= alias of nand;

The function C<nand> aka C<not_and> aka C<⊼> aka C<↑> performs a logical
I<alternative denial>; it results in C<False> iff its 2 arguments C<0> and
C<1> are both C<True>, and C<True> otherwise.

=head2 or ∨

    ::MD::or ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity (False)
        : (\.0 ?? True !! \.1);

    ::MDA::"∨" ::= alias of or;

The function C<or> aka C<∨> performs a logical I<disjunction>; it results
in C<True> iff at least one of its 2 arguments C<0> and C<1> is C<True>,
and C<False> otherwise.  Other programming languages may name their
corresponding operators I<|> or I<||> or I<A>.

=head2 nor not_or ⊽ ↓

    ::MD::nor ::= function negates or
        is commutative;

    ::MD::not_or ::= alias of nor;
    ::MDA::"⊽"   ::= alias of nor;
    ::MDA::"↓"   ::= alias of nor;

The function C<nor> aka C<not_or> aka C<⊽> aka C<↓> performs a logical
I<joint denial>; it results in C<False> iff at least one of its 2 arguments
C<0> and C<1> is C<True>, and C<True> otherwise.

=head2 xnor iff ↔

    ::MD::xnor ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative} identity (True)
        : (topic --> \@same);

    ::MD::iff  ::= alias of xnor;
    ::MDA::"↔" ::= alias of xnor;

The function C<xnor> aka C<iff> aka C<↔> performs a logical
I<biconditional> or I<material equivalence> or I<even parity>; it results
in C<True> iff its 2 arguments C<0> and C<1> are exactly the same value,
and C<False> otherwise.  This function is effectively a C<Boolean>-specific
alias of the function C<same> aka C<=>.  Other programming languages may
name their corresponding operators I<E>.

=head2 xor ⊻ ↮

    ::MD::xor ::= function negates xnor
        is {associative,commutative} identity (False);

    ::MDA::"⊻" ::= alias of xor;
    ::MDA::"↮" ::= alias of xor;

The function C<xor> aka C<⊻> aka C<↮> performs a logical I<exclusive
disjunction> or I<odd parity>; it results in C<False> iff its 2 arguments
C<0> and C<1> are exactly the same value, and C<True> otherwise.  This
function is effectively a C<Boolean>-specific alias of the function
C<not_same> aka C<!=> aka C<≠>.  Other programming languages may name their
corresponding operators I<^>.

=head2 imp implies →

    ::MD::imp ::= function --> Boolean <-- (Boolean, Boolean)
        : (\.0 ?? \.1 !! True);

    ::MD::implies ::= alias of imp;
    ::MDA::"→"    ::= alias of imp;

The function C<imp> aka C<implies> aka C<→> performs a logical I<material
implication>; it results in C<False> when its C<0> argument is C<True> and
its C<1> argument is C<False>, and C<True> otherwise.

=head2 nimp not_implies ↛

    ::MD::nimp ::= function negates imp;

    ::MD::not_implies ::= alias of nimp;
    ::MDA::"↛"        ::= alias of nimp;

The function C<nimp> aka C<not_implies> aka C<↛> performs a logical
I<material nonimplication>; it results in C<True> when its C<0> argument is
C<True> and its C<1> argument is C<False>, and C<False> otherwise.

=head2 if ←

    ::MD::if ::= function commutes imp;

    ::MDA::"←" ::= alias of if;

The function C<if> aka C<←> performs a logical I<converse implication> or
I<reverse material implication>; it results in C<False> when its C<0>
argument is C<False> and its C<1> argument is C<True>, and C<True>
otherwise.

=head2 nif not_if ↚

    ::MD::nif ::= function commutes nimp;

    ::MD::not_if ::= alias of nif;
    ::MDA::"↚"   ::= alias of nif;

The function C<nif> aka C<not_if> aka C<↚> performs a logical I<converse
nonimplication>; it results in C<True> when its C<0> argument is C<False>
and its C<1> argument is C<True>, and C<False> otherwise.

=head1 ROUNDING INSTRUCTION DATA TYPES

=head2 Round_Meth

    ::MD::Round_Meth::"" ::= selection
        union {2::Down,2::Up,2::To_Zero,2::To_Inf
            ,2::Half_Down,2::Half_Up,2::Half_To_Zero,2::Half_To_Inf
            ,2::Half_Even}
        default (2::To_Zero());

    ::MD::Round_Meth::Down         ::= constant (\@0);
    ::MD::Round_Meth::Up           ::= constant (\@0);
    ::MD::Round_Meth::To_Zero      ::= constant (\@0);
    ::MD::Round_Meth::To_Inf       ::= constant (\@0);
    ::MD::Round_Meth::Half_Down    ::= constant (\@0);
    ::MD::Round_Meth::Half_Up      ::= constant (\@0);
    ::MD::Round_Meth::Half_To_Zero ::= constant (\@0);
    ::MD::Round_Meth::Half_To_Inf  ::= constant (\@0);
    ::MD::Round_Meth::Half_Even    ::= constant (\@0);

The selection contract C<Round_Meth> is finite.  When a value of some
C<Orderable> type needs to be mapped into a proper subtype that doesn't
contain that value, such as when mapping an arbitrary number to one with
less precision, some rounding method is applied to determine which value of
the subtype is to be mapped to while most accurately reflecting the
original value.  The C<Round_Meth> type enumerates the rounding methods
that Muldis D operators can typically apply.

With C<Down> (aka I<floor>), C<Up> (aka I<ceiling>), C<To_Zero> (aka
I<truncate>), and C<To_Inf>, the original value will always be mapped to
the single adjacent value that is lower than it, or higher than it, or
towards "zero" from it, or towards the nearer infinity from it,
respectively.  With C<Half_Down>, C<Half_Up>, C<Half_To_Zero>,
C<Half_To_Inf>, and C<Half_Even> (aka I<unbiased rounding>, I<convergent
rounding>, I<statistician's rounding>, or I<bankers' rounding>), the
original value will be mapped to the single target value that it is closest
to, if there is one; otherwise, if it is exactly half-way between 2
adjacent target values, then C<Half_Down> will round towards negative
infinity, C<Half_Up> will round towards positive infinity, C<Half_To_Zero>
will round towards "zero", C<Half_To_Inf> will round towards the nearer
infinity, and C<Half_Even> will round towards the nearest "even" target.
The default value of C<Round_Meth> is C<To_Zero>, which is the simplest.

=head1 NUMERICAL DATA TYPES

=head2 Numerical

    ::MD::Numerical ::= interface
        composes Boolable
        requires_implements {so
            ,zero,opposite,reciprocal,modulus
            ,plus,minus,times,multiple_of
            ,fractional_divided_by,integral_divided_by
            ,integral_power,integral_nn_power};

The interface contract C<Numerical> is infinite.  A C<Numerical> value
either is a simple number of some kind or is something that can act as a
simple number.  A I<simple number> means, typically speaking, any rational
real number, those numbers that can be derived simply by multiplying or
dividing integers.  All operators defined by the C<Core> package
for C<Numerical> are expect to be closed over the real rational numbers,
and consist mainly of addition, subtraction, multiplication, and division
of any rationals, plus exponentiation of any rationals to integer powers
only.  Idiomatically a C<Numerical> is a pure number which does not
represent any kind of thing in particular, neither cardinal nor ordinal nor
nominal; however some types which do represent such a particular kind of
thing may choose to compose C<Numerical> because it makes sense to provide
its operators.  The default value of C<Numerical> is the C<Integer> value
C<0>.  A C<Numerical> in the general case is not C<Orderable>, but often a
type that is numeric is also orderable.  Other programming languages may
name their corresponding types I<Numeric>.

C<Numerical> is composed, directly or indirectly, by: C<Integral>,
C<Integer>, C<Fractional>, C<Fraction>, C<Quantity>.  It is also composed
by a lot of additional contracts defined by other Muldis D packages such as
L<Muldis::D::Package::Core::Math>; these include types for irrational
or algebraic or complex numbers or quaternions or rational types with a
fixed precision or scale or floating-point types and so on.

=head2 Excuse::Div_By_Zero

    ::MD::Excuse::Div_By_Zero ::= constant (\@0) composes Excuse;

The constant C<Excuse::Div_By_Zero> represents the I<undefined> result of
attempting to divide a simple number by a simple, unsigned, number zero.
Note that IEEE floating-point standards define a negative or positive
infinity result value when dividing by an explicitly signed (negative or
positive) zero, but the Muldis D core package lacks those concepts.

=head2 Excuse::Zero_To_The_Zero

    ::MD::Excuse::Zero_To_The_Zero ::= constant (\@0) composes Excuse;

The constant C<Excuse::Zero_To_The_Zero> represents the I<undefined> result
of attempting to exponentiate a number zero to the power of a number zero.

=head2 so (Numerical)

    ::MD::so::Numerical ::= function virtual --> Boolean <-- (Numerical)
        implements 2::"";

The virtual function C<so::Numerical> results in C<True> when its C<0>
argument is a nonzero number; otherwise it results in C<False>.  This
function implements the C<Boolable> virtual function C<so> aka C<?> aka
C<to_Boolean> for the composing type C<Numerical>.

=head2 is_zero

    ::MD::is_zero ::= function negates so::Numerical;

The function C<is_zero> results in C<True> when its C<0> argument is a
number zero; otherwise it results in C<False>.

=head2 zero

    ::MD::zero::"" ::= function virtual --> Numerical <-- (Numerical);

The virtual function C<zero> results in the number zero of its C<0>
argument's numerical type, assuming that every type composing C<Numerical>
has one.

=head2 opposite

    ::MD::opposite::"" ::= function virtual --> Numerical <-- (Numerical);

    ::MD::additive_inverse ::= alias of opposite;

The virtual function C<opposite> aka C<additive_inverse> aka unary C<-> aka
unary C<−> results in the numeric I<opposite> or I<negation> or I<additive
inverse> or I<unary minus> of its C<0> argument, and is a shorthand for
either multiplying that argument by negative one or subtracting it from
zero.  By definition, the sum of a number and its opposite is zero.

=head2 reciprocal

    ::MD::reciprocal::"" ::= function virtual
        --> {Numerical, Excuse::Div_By_Zero} <-- (Numerical);

    ::MD::multiplicative_inverse ::= alias of reciprocal;

The virtual function C<reciprocal> aka C<multiplicative_inverse> results in
the numeric I<reciprocal> or I<multiplicative inverse> of its nonzero C<0>
argument, and is a shorthand for dividing one by that argument.  By
definition, the product of a number and its reciprocal is one.  The result
is always C<Fractional> for both C<Integral> and C<Fractional> arguments.
The result is only I<defined> when the argument is a nonzero number; it is
an C<Excuse> otherwise.

=head2 modulus abs

    ::MD::modulus::"" ::= function virtual --> Numerical <-- (Numerical);

    ::MD::abs ::= alias of modulus;

The virtual function C<modulus> aka C<abs> results in the numeric
I<modulus> or I<absolute value> of its C<0> argument, which is the
(non-negative) distance between that argument and zero.  Note that typical
mathematical notion writes this operator in circumfix like I<|n|>.

=head2 plus +

    ::MD::plus::"" ::= function virtual
        --> Numerical <-- (Numerical, Numerical)
        is {associative,commutative}
        repeater times;

    ::MD::"+" ::= alias of plus;

The virtual function C<plus> aka C<+> results in the numeric I<sum> from
performing I<addition> of its 2 I<summand> arguments C<0> (I<augend>) and
C<1> (I<addend>).

=head2 minus

    ::MD::minus::"" ::= function virtual
        --> Numerical <-- (Numerical, Numerical);

The virtual function C<minus> aka binary C<-> aka binary C<−> results in
the numeric I<difference> from performing I<subtraction> of its 2 arguments
C<0> (I<minuend>) and C<1> (I<subtrahend>).

=head2 - −

    ::MD::"-" ::= function
        --> Numerical <-- {(Numerical), (Numerical, Numerical)}
        : (topic --> (degree(topic) = 1 ?? \@opposite !! \@minus));

    ::MDA::"−" ::= alias of "-";

The function C<-> aka C<−> is a proxy for either of the virtual functions
unary C<opposite> and binary C<minus>, depending on how many arguments it
was invoked with.

=head2 modulus_minus abs_minus |-| |−|

    ::MD::modulus_minus ::= function
        --> Numerical <-- (Numerical, Numerical)
        is commutative
        : (modulus topic --> \@minus);

    ::MD::abs_minus ::= alias of modulus_minus;
    ::MD::"|-|"     ::= alias of modulus_minus;
    ::MDA::"|−|"    ::= alias of modulus_minus;

The function C<modulus_minus> aka C<abs_minus> aka C<|-|> aka C<|−|>
results in the numeric I<absolute difference> of its 2 arguments C<0> and
C<1>, which is the (non-negative) distance between those arguments.

=head2 times * ×

    ::MD::times::"" ::= function virtual
        --> Numerical <-- (Numerical, Numerical)
        is {associative,commutative}
        repeater integral_nn_power;

    ::MD::"*"  ::= alias of times;
    ::MDA::"×" ::= alias of times;

The virtual function C<times> aka C<*> aka C<×> results in the numeric
I<product> from performing I<multiplication> of its 2 I<factor> arguments
C<0> (I<multiplier>) and C<1> (I<multiplicand>).

=head2 multiple_of

    ::MD::multiple_of::"" ::= function virtual
        --> {Boolean, Excuse::Div_By_Zero} <-- (Numerical, Numerical);

The virtual function C<multiple_of> results in C<True> iff its C<0>
argument is an even multiple of its C<1> argument (that is, the former is
evenly divisible by the latter), and C<False> otherwise.  The result is
only I<defined> when the C<1> argument is a nonzero number; it is an
C<Excuse> otherwise.  Other programming languages may name their
corresponding operators I<%%>.

=head2 fractional_divided_by / ÷ ∕

    ::MD::fractional_divided_by::"" ::= function virtual
        --> {Numerical, Excuse::Div_By_Zero} <-- (Numerical, Numerical);

    ::MD::"/"  ::= alias of fractional_divided_by;
    ::MDA::"÷" ::= alias of fractional_divided_by;
    ::MDA::"∕" ::= alias of fractional_divided_by;

The virtual function C<fractional_divided_by> aka C</> aka C<÷> aka C<∕>
results in the typically-fractional numeric I<quotient> from performing
I<division> of its 2 arguments C<0> (I<dividend> or I<numerator>) and C<1>
(I<divisor> or I<denominator>) using the semantics of real number division.
The result is always C<Fractional> for both C<Integral> and C<Fractional>
arguments; as such, C<fractional_divided_by> is the idiomatic way to select
any C<Fraction> values in terms of C<Integer> values.  The result is only
I<defined> when the C<1> argument is a nonzero number; it is an C<Excuse>
otherwise.

=head2 integral_divided_by div

    ::MD::integral_divided_by::"" ::= function virtual
        --> {Numerical, Excuse::Div_By_Zero}
        <-- (Numerical, Numerical, Round_Meth);

    ::MD::div ::= alias of integral_divided_by;

The virtual function C<integral_divided_by> aka C<div> results in the
integral numeric I<quotient> from performing I<division> of its 2 arguments
C<0> (I<dividend> or I<numerator>) and C<1> (I<divisor> or I<denominator>)
using the semantics of real number division, whereupon the real number
result is rounded to the same or nearest integral number, where the nearest
is determined by the rounding method specified by the C<2> argument.  The
result is always C<Integral> for both C<Integral> and C<Fractional>
arguments.  The result is only I<defined> when the C<1> argument is a
nonzero number; it is an C<Excuse> otherwise.

=head2 modulo mod

    ::MD::modulo ::= function
        --> {Numerical, Excuse::Div_By_Zero}
        <-- (Numerical, Numerical, Round_Meth)
        : (if \.1->is_zero then Excuse::Div_By_Zero()
            else \.0 - (\.1 * topic --> \@div));

    ::MD::mod ::= alias of modulo;

The function C<modulo> aka C<mod> results in the possibly-fractional
numeric I<remainder> from performing same I<division> operation as
C<integral_divided_by> does with all of the same arguments; to be specific,
C<modulo> preserves the identity C<x mod y = x - y * (x div y)>.  The
result is C<Integral> for C<Integral> arguments and is C<Fractional> for
C<Fractional> arguments.  The result is only I<defined> when the C<1>
argument is a nonzero number; it is an C<Excuse> otherwise.  Other
programming languages may name their corresponding operators I<%> or I<//>
or I<\\> or I<div> or I<rem> or I<remainder> or various other things.

=head2 divided_by_and_modulo

    ::MD::divided_by_and_modulo::"" ::= function
        --> ({Numerical, Excuse::Div_By_Zero}, {Numerical, Excuse::Div_By_Zero})
        <-- (Numerical, Numerical, Round_Meth)
        : (\%(topic --> \@div, topic --> \@mod));

The function C<divided_by_and_modulo> results in a binary tuple whose C<0>
and C<1> attributes have the exact same values that C<integral_divided_by>
and C<modulo> would result in, respectively, when each is given all of the
same arguments.  This function is a shorthand for invoking the other two.

=head2 integral_power **

    ::MD::integral_power::"" ::= function virtual
        --> {Numerical, Excuse::Zero_To_The_Zero} <-- (Numerical, Integral);

    ::MD::"**" ::= alias of integral_power;

The virtual function C<integral_power> aka C<**> results in a
typically-fractional number from performing I<exponentiation> of its 2
arguments C<0> (I<base>) and C<1> (I<exponent> or I<power>).  The result is
always C<Fractional> for both an C<Integral> and a C<Fractional> C<0>
argument.  The result is only I<defined> when the C<0> and C<1> arguments
are both nonzero numbers; it is an C<Excuse> otherwise.  Other programming
languages may name their corresponding operators I<exp> or I<^>.

=head2 integral_nn_power power

    ::MD::integral_nn_power::"" ::= function virtual
        --> {Numerical, Excuse::Zero_To_The_Zero} <-- (Numerical, Integral_NN);

    ::MD::power ::= alias of integral_nn_power;

The virtual function C<integral_nn_power> aka C<power> results in a
possibly-fractional number from performing I<exponentiation> of its 2
arguments C<0> (I<base>) and C<1> (I<exponent> or I<power>).  The result is
C<Integral> for an C<Integral> C<0> argument and is C<Fractional> for a
C<Fractional> C<0> argument.  The result is only I<defined> when the C<0>
and C<1> arguments are both nonzero numbers; it is an C<Excuse> otherwise.

=head1 INTEGRAL DATA TYPES

=head2 Integral

    ::MD::Integral ::= interface
        composes {Bicessable and_provides_its_default,
            Numerical and_provides_its_default}
        requires_implements {in_order,asset,pred,succ
            ,so,to_Integer
            ,zero,opposite,reciprocal,modulus
            ,plus,minus,times,multiple_of
            ,fractional_divided_by,integral_divided_by
            ,integral_power,integral_nn_power
            ,factorial};

The interface contract C<Integral> is infinite.  An C<Integral> value
either is an exact integral number of some kind or is something that can
act as such.  Idiomatically an C<Integral> is a pure integer which does not
represent any kind of thing in particular, neither cardinal nor ordinal nor
nominal; however some types which do represent such a particular kind of
thing may choose to compose C<Integral> because it makes sense to provide
its operators.  The default value of C<Integral> is the C<Integer> value
C<0>.  C<Integral> is both C<Orderable> and C<Bicessable>.  For each type
composing C<Integral>, a value closer to negative infinity is ordered
before a value closer to positive infinity, and the definition of
I<predecessor> and I<successor> is exactly equal to subtracting or adding
an integer positive-one respectively, while other C<Bicessable> don't
generally mean that.  In the general case, C<Integral> has no minimum or
maximum value, but often a type that is C<Integral> will have them.
C<Integral> is composed by C<Integer>.

=head2 Integral_NN

    ::MD::Integral_NN ::= selection of Integral
        where (topic >= zero(topic));

The selection contract C<Integral_NN> represents the infinite type
consisting just of the C<Integral> values that are non-negative.  Its
default and minmum value is C<0>; it has no maximum value.

=head2 Integral_P

    ::MD::Integral_P ::= selection of Integral_NN
        where (topic > zero(topic)) default (succ(Integral()));

The selection contract C<Integral_P> represents the infinite type
consisting just of the C<Integral_NN> values that are positive.  Its
default and minmum value is C<1>; it has no maximum value.

=head2 pred (Integral)

    ::MD::pred::Integral ::= function virtual --> Integral <-- (Integral)
        implements 2::"";

    ::MD::"--" ::= alias of pred::Integral;

The virtual function C<pred::Integral> aka C<--> implements the
C<Bicessable> virtual function C<pred> for the composing type C<Integral>.
Other programming languages may name their corresponding operators
I<decrement>.

=head2 succ (Integral)

    ::MD::succ::Integral ::= function virtual --> Integral <-- (Integral)
        implements 2::"";

    ::MD::"++" ::= alias of succ::Integral;

The virtual function C<succ::Integral> aka C<++> implements the
C<Successable> virtual function C<succ> for the composing type C<Integral>.
Other programming languages may name their corresponding operators
I<increment>.

=head2 to_Integer

    ::MD::to_Integer::"" ::= function virtual --> Integer <-- (Integral);

The virtual function C<to_Integer> results in the C<Integer> value that
represents the same integer value as its C<0> argument.  The purpose of
C<to_Integer> is to canonicalize C<Integral> values so they can be compared
abstractly as integers, or so that it is easier to do exact math with
integers without running afoul of possible range limits of fixed-size
C<Integral> types, just dealing with the latter for storage.

=head2 factorial

    ::MD::factorial::"" ::= function virtual --> Integral_P <-- (Integral_NN);

The virtual function C<factorial> results in the integral numeric
I<factorial> of its C<0> argument, and is a shorthand for the product of
every integer between 1 and that argument; the factorial of zero is defined
to result in positive one.  Note that typical mathematical notion writes
this operator in postfix like I<n!>.

=head2 gcd greatest_common_divisor

    ::MD::gcd ::= function --> Integral_P <-- (Integral_NN, Integral_NN)
        is {commutative,associative,idempotent}
        : ((if \.1->is_zero then \.0 else 0::(\.1, mod(\.0, \.1, To_Zero())))
            ::?= \~?'Calculate using the Euclidean algorithm.');

    ::MD::greatest_common_divisor ::= alias of gcd;

The function C<gcd> aka C<greatest_common_divisor> results in the integral
numeric I<greatest common divisor> of its 2 arguments C<0> and C<1>, which
is the largest integer that will divide both arguments evenly.
I<TODO: Look into generalizing it to take negative integer arguments too.>

=head2 lcm least_common_multiple

    ::MD::lcm ::= function --> Integral_NN <-- (Integral_NN, Integral_NN)
        is {commutative,associative,idempotent}
        : (if \.0->is_zero or \.1->is_zero then \.0->zero
            else div(\.0 * \.1, \.0 gcd \.1, To_Zero()));

    ::MD::least_common_multiple ::= alias of lcm;

The function C<lcm> aka C<least_common_multiple> results in the integral
numeric I<least common multiple> of its 2 arguments C<0> and C<1>, which
is the smallest integer that is an even multiple of both arguments.
I<TODO: Look into generalizing it to take negative integer arguments too.>

=head2 coprime

    ::MD::coprime ::= function --> Boolean <-- (Integral, Integral)
        : ((abs(\.0) gcd abs(\.1)) = (\.0->zero->succ));

The function C<coprime> results in C<True> iff its 2 arguments C<0> and
C<1> are coprime (their I<greatest common divisor> is 1), and C<False>
otherwise.

=head1 INTEGER DATA TYPES

=head2 Integer

    ::MD::Integer ::= selection where (topic -->^ FDN__is_a_Integer)
        default (0)
        composes Integral and_provides_its_default;

The selection contract C<Integer> represents
the infinite Muldis D Foundation type I<FDN__Integer>.  An C<Integer>
value is a general purpose exact integral number of any magnitude, which
explicitly does not represent any kind of thing in particular, neither
cardinal nor ordinal nor nominal.  Its default value is C<0>.  C<Integer>
is both C<Orderable> and C<Bicessable>; it has no minimum or maximum value.
Other programming languages may name their corresponding types I<BigInt>.

=head2 Integer_NN

    ::MD::Integer_NN ::= selection of Integer where (topic >= 0);

The selection contract C<Integer_NN> represents the infinite type
consisting just of the C<Integer> values that are non-negative.  Its
default and minmum value is C<0>; it has no maximum value.

=head2 Integer_P

    ::MD::Integer_P ::= selection of Integer_NN where (topic > 0) default (1);

The selection contract C<Integer_P> represents the infinite type consisting
just of the C<Integer_NN> values that are positive.  Its default and minmum
value is C<1>; it has no maximum value.

=head2 in_order (Integer)

    ::MD::in_order::Integer ::= function --> Boolean <-- (Integer, Integer)
        implements 2::""
        : (topic -->^ FDN__Integer_in_order);

The function C<in_order::Integer> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Integer>.

=head2 asset (Integer)

    ::MD::asset::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (\.0);

The function C<asset::Integer> simply results in its C<0> argument.
This function implements the C<Successable> virtual function C<asset> for
the composing type C<Integer>.

=head2 pred (Integer)

    ::MD::pred::Integer ::= function --> Integer <-- (Integer)
        implements 2::Integral
        : (\.0 - 1);

The function C<pred::Integer> implements the C<Bicessable>/C<Integral>
virtual function C<pred> aka C<--> for the composing type C<Integer>.

=head2 succ (Integer)

    ::MD::succ::Integer ::= function --> Integer <-- (Integer)
        implements 2::Integral
        repeater plus::Integer
        : (\.0 + 1);

The function C<succ::Integer> implements the C<Successable>/C<Integral>
virtual function C<succ> aka C<++> for the composing type C<Integer>.

=head2 so (Integer)

    ::MD::so::Integer ::= function --> Boolean <-- (Integer)
        implements 2::""
        : (\.0 != 0);

The function C<so::Integer> results in C<True> iff its C<0> argument is not
C<0>, and in C<False> if it is C<0>.  This function implements the
C<Boolable> virtual function C<so> aka C<?> aka C<to_Boolean> for the
composing type C<Integer>.

=head2 to_Integer (Integer)

    ::MD::to_Integer::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (\.0);

The function C<to_Integer::Integer> simply results in its C<0> argument.
This function implements the C<Integral> virtual function C<to_Integer> for
the composing type C<Integer>.

=head2 zero (Integer)

    ::MD::zero::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (0);

The function C<zero::Integer> simply results in C<0>.  This function
implements the C<Numerical> virtual function C<zero> for the composing type
C<Integer>.

=head2 opposite (Integer)

    ::MD::opposite::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (topic -->^ FDN__Integer_opposite);

The function C<opposite::Integer> implements the C<Numerical> virtual
function C<opposite> aka C<additive_inverse> aka unary C<-> aka unary C<−>
for the composing type C<Integer>.

=head2 reciprocal (Integer)

    ::MD::reciprocal::Integer ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Integer)
        implements 2::""
        : (1 / \.0);

The function C<reciprocal::Integer> implements the C<Numerical> virtual
function C<reciprocal> aka C<multiplicative_inverse> for the composing type
C<Integer>.

=head2 modulus (Integer)

    ::MD::modulus::Integer ::= function --> Integer_NN <-- (Integer)
        implements 2::""
        : (topic -->^ FDN__Integer_modulus);

The function C<modulus::Integer> implements the C<Numerical>
virtual function C<modulus> aka C<abs> for the composing type C<Integer>.

=head2 plus (Integer)

    ::MD::plus::Integer ::= function --> Integer <-- (Integer, Integer)
        implements 2::""
        is {associative,commutative} identity (0)
        repeater times::Integer
        : (topic -->^ FDN__Integer_plus);

The function C<plus::Integer> implements the C<Numerical>
virtual function C<plus> aka C<+> for the composing type C<Integer>.

=head2 minus (Integer)

    ::MD::minus::Integer ::= function --> Integer <-- (Integer, Integer)
        implements 2::""
        : (topic -->^ FDN__Integer_minus);

The function C<minus::Integer> implements the C<Numerical> virtual function
C<minus> aka binary C<-> aka binary C<−> for the composing type C<Integer>.

=head2 times (Integer)

    ::MD::times::Integer ::= function --> Integer <-- (Integer, Integer)
        implements 2::""
        is {associative,commutative} identity (1)
        repeater integral_nn_power::Integer
        : (topic -->^ FDN__Integer_times);

The function C<times::Integer> implements the C<Numerical> virtual function
C<times> aka C<*> aka C<×> for the composing type C<Integer>.

=head2 multiple_of (Integer)

    ::MD::multiple_of::Integer ::= function
        --> {Boolean, Excuse::Div_By_Zero} <-- (Integer, Integer)
        implements 2::""
        : (if \.1 = 0 then Excuse::Div_By_Zero()
            else topic -->^ FDN__Integer_multiple_of);

The function C<multiple_of::Integer> implements the C<Numerical>
virtual function C<multiple_of> for the composing type C<Integer>.

=head2 fractional_divided_by (Integer)

    ::MD::fractional_divided_by::Integer ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Integer, Integer)
        implements 2::""
    : (
        n ::= \.0;
        d ::= \.1;

        <-- if d = 0 then Excuse::Div_By_Zero() else q;

        q ::= (\Fraction wrap \%(
            numerator   : div((d > 0 ?? n !! -n), gcd, To_Zero()),
            denominator : div((d > 0 ?? d !! -d), gcd, To_Zero()),
        ));

        gcd ::= gcd(abs(n), abs(d));
    );

The function C<fractional_divided_by::Integer> implements the C<Numerical>
virtual function C<fractional_divided_by> aka C</> aka C<÷> aka C<∕> for
the composing type C<Integer>.

=head2 integral_divided_by (Integer)

    ::MD::integral_divided_by::Integer ::= function
        --> {Integer, Excuse::Div_By_Zero}
        <-- (Integer, Integer, Round_Meth)
        implements 2::""
    : (
        dividend   ::= \.0;
        divisor    ::= \.1;
        round_meth ::= \.2;

        <-- if divisor = 0 then Excuse::Div_By_Zero() else e1;

        e1 ::?= \~?'This is the case where we are dividing by a non-zero.';

        e1 ::= (
               dividend = 0       ?? 0
            !! divisor  = 1       ?? dividend
            !! dividend = divisor ?? 1
            !! divisor  = -1      ?? -dividend
            !!                       e2
        );

        e2 ::?= \~?'This is the case where the divisor and dividend do not'
            ' equal each other and neither of them is a zero or a one.';

        e2 ::= (
            real_q_is_neg ::= (dividend < 0 xor divisor < 0);
            rtz_quotient  ::= (FDN__Integer_divided_by_rtz
                ^<-- \%(dividend, divisor));
            rtz_remainder ::= (dividend - (divisor * rtz_quotient));

            <-- rtz_remainder = 0 ?? rtz_quotient !! e3;
        );

        e3 ::?= \~?'This is the case where the divisor does not divide the'
            ' dividend evenly and the real number division result would'
            ' have a fractional part, so we decide how to round that.';

        e3 ::= (
            rti_quotient ::= (rtz_quotient + (real_q_is_neg ?? -1 !! 1));
            rdn_quotient ::= (rtz_quotient + (real_q_is_neg ?? -1 !! 0));
            rup_quotient ::= (rtz_quotient + (real_q_is_neg ??  0 !! 1));

            <-- round_meth ??? {
                Down()    : rdn_quotient,
                Up()      : rup_quotient,
                To_Zero() : rtz_quotient,
                To_Inf()  : rti_quotient,
            } !!!
                   (2 * abs(rtz_remainder)) < abs(divisor) ?? rtz_quotient
                !! (2 * abs(rtz_remainder)) > abs(divisor) ?? rti_quotient
                !! e4
            ;
        );

        e4 ::?= \~?'This is the case where real division remainder is'
            ' exactly one-half so we decide how to round that.';

        e4 ::= (
            round_meth ??? {
                Half_Down()    : rdn_quotient,
                Half_Up()      : rup_quotient,
                Half_To_Zero() : rtz_quotient,
                Half_To_Inf()  : rti_quotient,
                Half_Even()    :
                  (
                    q ::= (FDN__Integer_divided_by_rtz
                        ^<-- \%(abs(rtz_quotient),2))
                    r ::= (abs(rtz_quotient) - (2 * q));
                    rtz_quotient_is_even ::= (r = 0);
                    <-- rtz_quotient_is_even ?? rtz_quotient !! rti_quotient;
                  ),
            } !!! fail  `oops, an unhandled case`
        );
    );

The function C<integral_divided_by::Integer> implements the C<Numerical>
virtual function C<integral_divided_by> aka C<div> for the composing type
C<Integer>.

=head2 integral_power (Integer)

    ::MD::integral_power::Integer ::= function
        --> {Fraction, Excuse::Zero_To_The_Zero} <-- (Integer, Integer)
        implements 2::""
        : (if \.0 = 0 and \.1 = 0 then Excuse::Zero_To_The_Zero()
            else \.0 / 1 ** \.1);

The function C<integral_power::Integer> implements the C<Numerical> virtual
function C<integral_power> aka C<**> for the composing type C<Integer>.

=head2 integral_nn_power (Integer)

    ::MD::integral_nn_power::Integer ::= function
        --> {Integer, Excuse::Zero_To_The_Zero} <-- (Integer, Integer_NN)
        implements 2::""
        : (if \.0 = 0 and \.1 = 0 then Excuse::Zero_To_The_Zero()
            else topic -->^ FDN__Integer_nn_power);

The function C<integral_nn_power::Integer> implements the C<Numerical>
virtual function C<integral_nn_power> aka C<power> for the composing type
C<Integer>.

=head2 factorial (Integer)

    ::MD::factorial::Integer ::= function --> Integer_P <-- (Integer_NN)
        implements 2::""
        : (topic -->^ FDN__Integer_factorial);

The function C<factorial::Integer> implements the C<Integral> virtual
function C<factorial> for the composing type C<Integer>.

=head1 FRACTIONAL DATA TYPES

=head2 Fractional

    ::MD::Fractional ::= interface
        composes {Orderable and_provides_its_default,
            Numerical and_provides_its_default}
        requires_implements {in_order
            ,so,to_Fraction
            ,zero,opposite,reciprocal,modulus
            ,plus,minus,times,multiple_of
            ,fractional_divided_by,integral_divided_by
            ,integral_power,integral_nn_power
            ,numerator,denominator};

The interface contract C<Fractional> is infinite.  A C<Fractional> value
either is a rational exact numeric of some kind, expressible as a coprime
I<numerator> / I<denominator> pair of C<Integral> whose I<denominator> is
positive, or is something that can act as such.  Idiomatically a
C<Fractional> is a pure rational number which does not represent any kind
of thing in particular, neither cardinal nor ordinal nor nominal; however
some types which do represent such a particular kind of thing may choose to
compose C<Fractional> because it makes sense to provide its operators.  The
default value of C<Fractional> is the C<Fraction> value C<0.0>.
C<Fractional> is C<Orderable>; for each type composing C<Fractional>, a
value closer to negative infinity is ordered before a value closer to
positive infinity.  In the general case it is not C<Bicessable> nor does it
have a minimum or maximum value, but sometimes a type that is C<Fractional>
will have either of those. C<Fractional> is composed by C<Fraction>.

=head2 Fractional_NN

    ::MD::Fractional_NN ::= selection of Fractional
        where (topic >= zero(topic));

The selection contract C<Fractional_NN> represents the infinite type
consisting just of the C<Fractional> values that are non-negative.  Its
default and minmum value is C<0.0>; it has no maximum value.

=head2 to_Fraction

    ::MD::to_Fraction::"" ::= function virtual --> Fraction <-- (Fractional);

The virtual function C<to_Fraction> results in the C<Fraction> value that
represents the same rational value as its C<0> argument.  The purpose of
C<to_Fraction> is to canonicalize C<Fractional> values so they can be
compared abstractly as rationals, or so that it is easier to do exact math
with rationals without running afoul of possible range limits of fixed-size
C<Fractional> types, just dealing with the latter for storage.

=head2 numerator

    ::MD::numerator::"" ::= function virtual --> Integral <-- (Fractional);

The virtual function C<numerator> results in the I<numerator> of its
C<0> argument, when the latter is expressed as a coprime I<numerator> /
I<denominator> pair of C<Integral> whose I<denominator> is positive.

=head2 denominator

    ::MD::denominator::"" ::= function virtual --> Integral_P <-- (Fractional);

The virtual function C<denominator> results in the I<denominator> of its
C<0> argument, when the latter is expressed as a coprime I<numerator> /
I<denominator> pair of C<Integral> whose I<denominator> is positive.

=head1 FRACTION DATA TYPES

=head2 Fraction

    ::MD::Fraction ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped( topic, \Fraction, \@1::_Asset ))
            default (0.0)
            composes Fractional and_provides_its_default;

        _Asset ::= selection of Tuple where
        (
            if
                topic ^?= \%(
                    numerator : \@Integer,
                    denominator : \@Integer_P,
                )
            then
                \.numerator coprime \.denominator
            else
                False
        );
    };

The selection contract C<Fraction> is infinite.  A
C<Fraction> value is a general purpose exact rational number of any
magnitude and precision, expressible as a coprime
I<numerator> / I<denominator> pair of C<Integer> whose I<denominator> is
positive, which explicitly does not represent any kind of thing in
particular, neither cardinal nor ordinal nor nominal.  Its default value is
C<0.0>.  C<Fraction> is C<Orderable>; it has no minimum or maximum value.
Other programming languages may name their corresponding types I<BigRat>.

=head2 Fraction_NN

    ::MD::Fraction_NN ::= selection of Fraction where (topic >= 0.0);

The selection contract C<Fraction_NN> represents the infinite type
consisting just of the C<Fraction> values that are non-negative.  Its
default and minmum value is C<0.0>; it has no maximum value.

=head2 in_order (Fraction)

    ::MD::in_order::Fraction ::= function --> Boolean <-- (Fraction, Fraction)
        implements 2::""
    : (
        <-- (\.0->denominator) = (\.1->denominator)
            ?? in_order(\.0->numerator, \.1->numerator)
         !!
          (
            common_d ::= lcm(\.0->denominator, \.1->denominator);
            <-- in_order(
                (\.0->numerator) * div(common_d, \.0->denominator, To_Zero()),
                (\.1->numerator) * div(common_d, \.1->denominator, To_Zero()),
            );
          )
    );

The function C<in_order::Fraction> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Fraction>.

=head2 so (Fraction)

    ::MD::so::Fraction ::= function --> Boolean <-- (Fraction)
        implements 2::""
        : (\.0 != 0.0);

The function C<so::Fraction> results in C<True> iff its C<0> argument is
not C<0.0>, and in C<False> if it is C<0.0>.  This function implements the
C<Boolable> virtual function C<so> aka C<?> aka C<to_Boolean> for the
composing type C<Fraction>.

=head2 to_Fraction (Fraction)

    ::MD::to_Fraction::Fraction ::= function --> Fraction <-- (Fraction)
        implements 2::""
        : (\.0);

The function C<to_Fraction::Fraction> simply results in its C<0> argument.
This function implements the C<Fractional> virtual function C<to_Fraction>
for the composing type C<Fraction>.

=head2 zero (Fraction)

    ::MD::zero::Fraction ::= function --> Fraction <-- (Fraction)
        implements 2::""
        : (0.0);

The function C<zero::Fraction> simply results in C<0.0>.  This function
implements the C<Numerical> virtual function C<zero> for the composing type
C<Fraction>.

=head2 opposite (Fraction)

    ::MD::opposite::Fraction ::= function --> Fraction <-- (Fraction)
        implements 2::""
        : (-(\.0->numerator) / (\.0->denominator));

The function C<opposite::Fraction> implements the C<Numerical> virtual
function C<opposite> aka C<additive_inverse> aka unary C<-> aka unary C<−>
for the composing type C<Fraction>.

=head2 reciprocal (Fraction)

    ::MD::reciprocal::Fraction ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Fraction)
        implements 2::""
        : (if \.0 = 0.0 then Excuse::Div_By_Zero()
            else (\.0->denominator) / (\.0->numerator));

The function C<reciprocal::Fraction> implements the C<Numerical> virtual
function C<reciprocal> aka C<multiplicative_inverse> for the composing type
C<Fraction>.

=head2 modulus (Fraction)

    ::MD::modulus::Fraction ::= function --> Fraction_NN <-- (Fraction)
        implements 2::""
        : (abs(\.0->numerator) / (\.0->denominator));

The function C<modulus::Fraction> implements the C<Numerical>
virtual function C<modulus> aka C<abs> for the composing type C<Fraction>.

=head2 plus (Fraction)

    ::MD::plus::Fraction ::= function --> Fraction <-- (Fraction, Fraction)
        implements 2::""
        is {associative,commutative} identity (0.0)
        repeater times::Fraction
    : (
        <-- (\.0->denominator) = (\.1->denominator)
            ?? (\.0->numerator) + (\.1->numerator) / (\.0->denominator)
         !!
          (
            common_d ::= lcm(\.0->denominator, \.1->denominator);
            <-- ((\.0->numerator) * div(common_d, \.0->denominator, To_Zero()))
                + ((\.1->numerator) * div(common_d, \.1->denominator, To_Zero()))
                / common_d;
            );
          )
    );

The function C<plus::Fraction> implements the C<Numerical>
virtual function C<plus> aka C<+> for the composing type C<Fraction>.

=head2 minus (Fraction)

    ::MD::minus::Fraction ::= function --> Fraction <-- (Fraction, Fraction)
        implements 2::""
        : (\.0 + (-\.1));

The function C<minus::Fraction> implements the C<Numerical> virtual function
C<minus> aka binary C<-> aka binary C<−> for the composing type C<Fraction>.

=head2 times (Fraction)

    ::MD::times::Fraction ::= function --> Fraction <-- (Fraction, Fraction)
        implements 2::""
        is {associative,commutative} identity (1.0)
        repeater integral_nn_power::Fraction
        : (((\.0->numerator) * (\.1->numerator))
            / ((\.0->denominator) * (\.1->denominator)));

The function C<times::Fraction> implements the C<Numerical> virtual function
C<times> aka C<*> aka C<×> for the composing type C<Fraction>.

=head2 multiple_of (Fraction)

    ::MD::multiple_of::Fraction ::= function
        --> {Boolean, Excuse::Div_By_Zero} <-- (Fraction, Fraction)
        implements 2::""
        : (if \.1 = 0.0 then Excuse::Div_By_Zero()
            else \@mod <-- topic = 0.0);

The function C<multiple_of::Fraction> implements the C<Numerical>
virtual function C<multiple_of> for the composing type C<Fraction>.

=head2 fractional_divided_by (Fraction)

    ::MD::fractional_divided_by::Fraction ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Fraction, Fraction)
        implements 2::""
        : (if \.1 = 0.0 then Excuse::Div_By_Zero()
            else \.0 * reciprocal(\.1));

The function C<fractional_divided_by::Fraction> implements the C<Numerical>
virtual function C<fractional_divided_by> aka C</> aka C<÷> aka C<∕> for
the composing type C<Fraction>.

=head2 integral_divided_by (Fraction)

    ::MD::integral_divided_by::Fraction ::= function
        --> {Integer, Excuse::Div_By_Zero}
        <-- (Fraction, Fraction, Round_Meth)
        implements 2::""
    : (
        d ::= lcm(\.0->denominator, \.1->denominator);
        n0 ::= ((\.0->numerator) * div(d, \.0->denominator, To_Zero()));
        n1 ::= ((\.1->numerator) * div(d, \.1->denominator, To_Zero()));
        <-- if \.1 = 0.0 then Excuse::Div_By_Zero()
            else div(n0 * d, n1 * d, \.2);
    );

The function C<integral_divided_by::Fraction> implements the C<Numerical>
virtual function C<integral_divided_by> aka C<div> for the composing type
C<Fraction>.

=head2 integral_power (Fraction)

    ::MD::integral_power::Fraction ::= function
        --> {Fraction, Excuse::Zero_To_The_Zero} <-- (Fraction, Integer)
        implements 2::""
        : (\@integral_nn_power
            <-- \.1 >= 0 ?? topic !! \%(reciprocal(\.0), -\.1));

The function C<integral_power::Fraction> implements the C<Numerical> virtual
function C<integral_power> aka C<**> for the composing type C<Fraction>.

=head2 integral_nn_power (Fraction)

    ::MD::integral_nn_power::Fraction ::= function
        --> {Fraction, Excuse::Zero_To_The_Zero} <-- (Fraction, Integer_NN)
        implements 2::""
        : (if \.0 = 0.0 and \.1 = 0 then Excuse::Zero_To_The_Zero()
            else ((\.0->numerator) ** \.1) / ((\.0->denominator) ** \.1));

The function C<integral_nn_power::Fraction> implements the C<Numerical>
virtual function C<integral_nn_power> aka C<power> for the composing type
C<Fraction>.

=head2 numerator (Fraction)

    ::MD::numerator::Fraction ::= function --> Integer <-- (Fraction)
        : (unwrap(\.0).\numerator);

The function C<numerator::Fraction> implements the C<Fractional> virtual
function C<numerator> for the composing type C<Fraction>.

=head2 denominator (Fraction)

    ::MD::denominator::Fraction ::= function --> Integer_P <-- (Fraction)
        : (unwrap(\.0).\denominator);

The function C<denominator::Fraction> implements the C<Fractional> virtual
function C<denominator> for the composing type C<Fraction>.

=head1 ACCESSIBLE DATA TYPES

=head2 Accessible

    ::MD::Accessible ::= interface
        requires_implements {".",".?",".!"};

I<TODO.  For types that support simple accessor-based lookup of single values;
for one-dimensional collections of pairs that support lookup by one
pair element of the other pair element, and every pair in the
collection has a distinct first element.
Does not have anything to say related to either enumerating elements or
to slicing a subset elements into a new collection.
Accessible just provides certain convenient shared names for operators that
otherwise have distinct names on the composing types.
Composed by: Positional (Array, String,...), Tuple, Dictionary, etc.
(Conceptually also composed by Capsule, but isn't to avoid conflicts.)>

=head2 .

    ::MD::"."::"" ::= function virtual --> Any <-- (Accessible, Any)
        requires (topic --> \@".?");

I<TODO.>

=head2 .?

    ::MD::".?"::"" ::= function virtual --> Boolean <-- (Accessible, Any);

I<TODO.>

=head2 .!

    ::MD::".!"::"" ::= function virtual --> Any <-- (Accessible, Any);

I<TODO.>

=head1 HOMOGENEOUS DATA TYPES

=head2 Homogeneous

    ::MD::Homogeneous::"" ::= interface
        composes Boolable
        requires_implements {so,empty,count,has,nest,unnest,any,where,map,reduce,...};

I<TODO.  For types whose values are conceptually homogeneous collections
of distinct integral-weighted objects, where the weights may or may not be
constrained to 1 (each element can only appear once),
either with a canonical order of elements or with no canonical order.
Composed by: Positional (Array, String, etc), Setty (Set, Relation),
Bag, Tuple_Bag, Dictionary, etc.
Subtypes also composing Positional are ordered, and others are not.
Subtypes also composing Setty ensure elements appear just once, others don't.
(Conceptually more or less all collection types can be thought of as being
collections over 2 dimensions, heterogeneous/Attributive and Homogeneous;
Relation and Tuple_Bag formally are multiples in both dimensions, while the
other types are formally multiples in just one of those dimensions.)>

I<TODO.  Note that for all the regular function-taking element-wise
Homogeneous operators that are logically supposed to work with each
collection member in isolation and/or shouldn't put significance on either
duplicate members or member position in the collection, including the likes
of {any, where, map} etc, but not including the likes of {reduce}, the
operators will only be passing the asset portion (where applicable) of the
member to the higher-order function, and not say the index-asset pair for a
Positional or the asset-count pair for a Baggy.  Note that for a Relation
or Tuple_Bag each entire Tuple is the member asset, and for a Dictionary
the pair is the asset.  (With the corresponding attribute-wise Tuple
operators, they are given the whole attribute name-value pair.)  The main
reason for this is to help ensure consistency of results while supporting a
variety of collection implementations including ones that are lazy, such as
by not eagerly counting duplicates, or that use distributed computation.
For that matter, the likes of {reduce} should probably be treated the same
way; see also the 'repeater' function trait that helps optimize it.
Surely, any time when one may think these operations need to know the
baggy count or positional index, its for a problem best solved differently.>

=head2 so (Homogeneous) has_any_members

    ::MD::so::Homogeneous ::= function virtual --> Boolean <-- (Homogeneous)
        implements 2::"";

    ::MD::has_any_members ::= alias of so::Homogeneous;

The function C<so::Homogeneous> aka C<has_any_members> ...  This function implements the C<Boolable>
virtual function C<so> aka C<?> aka C<to_Boolean> for the composing type C<Homogeneous>.

I<TODO.>

=head2 is_empty ∅?

    ::MD::is_empty ::= function negates so::Homogeneous;

    ::MDA::"∅?" ::= alias of is_empty;

I<TODO.>

=head2 empty ∅

    ::MD::empty::"" ::= function virtual --> Homogeneous <-- (Homogeneous);

    ::MDA::"∅" ::= alias of empty;

I<TODO.  Returns the 'empty' value of the argument's collection type.
For plain {Array,Set,Bag} this is a constant value, but for a Relation or
a Tuple_Bag this is distinct per each heading.>

=head2 count cardinality #

    ::MD::count::"" ::= function virtual --> Integral <-- (Homogeneous);

    ::MD::cardinality ::= alias of count;
    ::MD::"#"         ::= alias of count;

I<TODO.>

=head2 has ∋

    ::MD::has::"" ::= function virtual --> Boolean <-- (Homogeneous, Any);

    ::MDA::"∋" ::= alias of has;

I<TODO.>

=head2 not_has ∌

    ::MD::not_has ::= function negates has;

    ::MDA::"∌" ::= alias of not_has;

I<TODO.>

=head2 in ∈

    ::MD::in ::= function commutes has;

    ::MDA::"∈" ::= alias of in;

I<TODO.>

=head2 not_in ∉

    ::MD::not_in ::= function commutes not_has;

    ::MDA::"∉" ::= alias of not_in;

I<TODO.>

=head2 nest group

    ::MD::nest::"" ::= function virtual --> Homogeneous <-- (Homogeneous)
        requires (...);

    ::MD::group ::= alias of nest;

I<TODO.>

=head2 unnest ungroup

    ::MD::unnest::"" ::= function virtual --> Homogeneous <-- (Homogeneous)
        requires (...);

    ::MD::ungroup ::= alias of unnest;

I<TODO.>

=head2 any there_exists ∃

    ::MD::any::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Primed_Func_Ref);

    ::MD::there_exists ::= alias of any;
    ::MDA::"∃"         ::= alias of any;

I<TODO.  Result is true when at least one member evaluates to true.
This is logically equivalent to testing if a same-topic 'where' result is nonempty,
but 'any' is instead virtual with applicable Foundation-level functions to
aid efficiency with less-savvy optimizers that don't know to short-circuit.>

=head2 none there_does_not_exist ∄

    ::MD::none ::= function negates any;

    ::MD::there_does_not_exist ::= alias of none;
    ::MDA::"∄"                 ::= alias of none;

I<TODO.  Result is true when no member evaluates to true.>

=head2 all for_all ∀

    ::MD::all ::= function --> Boolean <-- (Homogeneous, Primed_Func_Ref)
        : (\.0 none negated_func(of : \.1, passing_args : \@(0)));

    ::MD::for_all ::= alias of all;
    ::MDA::"∀"    ::= alias of all;

I<TODO.  Result is true when no member evaluates to false.>

=head2 all_is_a

    ::MD::all_is_a ::= function --> Boolean <-- (Homogeneous, Reference)
        : (\.0 all (\@is_a assuming topic ^ \@(1)));

I<TODO.>

=head2 where

    ::MD::where::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Primed_Func_Ref);

I<TODO.  The primed-func-ref is expected to be a Capsule with 2 asset attrs
named 'func' and 'args', which are a Reference and a Tuple respectively.
The 'args' can be any Tuple that doesn't have a '0' attr.
The function referenced by 'func' is expected to take a Tuple argument
whose '0' attr is a member of the collection and whose other attrs match
those given in 'args'.>

=head2 filtering

    ::MD::filtering ::= function commutes where;

I<TODO.>

=head2 map

    ::MD::map::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Primed_Func_Ref);

I<TODO.  The primed-func-ref is as per that of 'where'.>

=head2 reduce

    ::MD::reduce::"" ::= function virtual
        --> Any <-- (Homogeneous, Primed_Func_Ref);

I<TODO.  The primed-func-ref is expected to be a Capsule with 2 asset attrs
named 'func' and 'args', which are a Reference and a Tuple respectively.
The 'args' can be any Tuple that doesn't have either '0' or '1' attrs.
The function referenced by 'func' is expected to take a Tuple argument
whose '0' and '1' attrs are members of the collection and whose other attrs match
those given in 'args'.
Depending on the collection subtype, order of 0,1 may or may not be significant.>

=head1 POSITIONAL DATA TYPES

=head2 Positional

    ::MD::Positional ::= interface
        composes {Orderable, Accessible, Homogeneous and_provides_its_default, ...}
        requires_implements {so,empty,count,elem,has_index,has,nest,unnest,any,where,map,reduce,
            first_index,last_index,slice,catenate,index_succ_all_matches,...};

I<TODO.  For types that support integer-index-based lookup of values;
for collections of index-value pairs where all indexes are distinct;
for collections you can enumerate in canonical order;
the collection indexes might not be zero-based in the general case but must be dense.
Composed by: Array, String, Blob, Text, etc.>

=head2 Excuse::No_Such_Index

    ::MD::Excuse::No_Such_Index ::= constant (\@0) composes Excuse;

I<TODO.>

=head2 in_order (Positional)

    ::MD::in_order::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
    : (
        i ::= (topic --> \@index_succ_all_matches);
      <--
        if not \.0 .? i then
            e1 ::= True
        else if not \.1 .? i then
            False
        else
            e2 ::= (\.0.i in_order \.1.i);

        e1 ::?= \~?'This is the case where LHS is a leading subsequence of or is equal to RHS.';
        e2 ::?= \~?'This will succeed iff in_order() is defined for the element type.';
    );

The function C<in_order::Positional> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Positional>.

=head2 elem . (Positional)

    ::MD::elem::"" ::= function virtual --> Any <-- (Positional, Integral)
        requires (topic --> \@has_index);

    ::MD::"."::Positional ::= function --> Any <-- (Positional, Integral)
        implements 2::""
        requires (topic --> \@has_index)
        : (topic --> \@elem);

I<TODO.>

=head2 has_index .? (Positional)

    ::MD::has_index::"" ::= function virtual --> Boolean <-- (Positional, Integral);

    ::MD::".?"::Positional ::= function --> Boolean <-- (Positional, Integral)
        implements 2::""
        : (topic --> \@has_index);

I<TODO.>

=head2 elem_or_excuse .! (Positional)

    ::MD::elem_or_excuse ::= function --> Any <-- (Positional, Integral)
        : (topic --> \@has_index ?? topic --> \@elem !! Excuse::No_Such_Index());

    ::MD::".!"::Positional ::= function --> Any <-- (Positional, Integral)
        implements 2::""
        : (topic --> \@elem_or_excuse);

I<TODO.>

=head2 first_index

    ::MD::first_index::"" ::= function virtual --> Integral <-- (Positional)
        requires (?\.0);

I<TODO.>

=head2 last_index

    ::MD::last_index::"" ::= function virtual --> Integral <-- (Positional)
        requires (?\.0);

I<TODO.>

=head2 slice

    ::MD::slice::"" ::= function virtual
        --> Positional <-- (Positional, Interval);

I<TODO.  Need to clarify constraints, eg is this a strict subsequence
operation or is it more like an intersection.>

=head2 first

    ::MD::first ::= function --> Any <-- (Positional)
        requires (?\.0)
        : (\.0 . first_index(\.0));

I<TODO.>

=head2 nonfirst

    ::MD::nonfirst ::= function --> Positional <-- (Positional)
        requires (?\.0)
        : (\.0 slice first_index(\.0)^..last_index(\.0));

I<TODO.>

=head2 last

    ::MD::last ::= function --> Any <-- (Positional)
        requires (?\.0)
        : (\.0 . last_index(\.0));

I<TODO.>

=head2 nonlast

    ::MD::nonlast ::= function --> Positional <-- (Positional)
        requires (?\.0)
        : (\.0 slice first_index(\.0)..^last_index(\.0));

I<TODO.>

=head2 catenate ~

    ::MD::catenate::"" ::= function virtual
        --> Positional <-- (Positional, Positional)
        is associative;

    ::MD::"~" ::= alias of catenate;

I<TODO.>

=head2 index_succ_all_matches

    ::MD::index_succ_all_matches::"" ::= function virtual
        --> Integral <-- (Positional, Positional)
        is commutative;

I<TODO.>

=head1 ARRAY DATA TYPES

=head2 Array

    ::MD::Array ::= selection where (topic -->^ FDN__is_a_Array)
        default ([])
        composes Positional and_provides_its_default;

The selection contract C<Array> represents the infinite
Muldis D Foundation type I<FDN__Array>.  An C<Array> value is ...

I<TODO.>

=head2 ~∅

    ::MDA::"~∅" ::= constant ([]);

The constant C<~∅> represents the only zero-member C<Array> value.

=head2 so (Array)

    ::MD::so::Array ::= function --> Boolean <-- (Array)
        implements 2::""
        : (\.0 != []);

The function C<so::Array> ...  This function implements the C<Boolable>
virtual function C<so> aka C<?> aka C<to_Boolean> for the composing type C<Array>.

I<TODO.>

=head2 empty (Array)

    ::MD::empty::Array ::= function --> Array <-- (Array)
        implements 2::""
        : ([]);

I<TODO.>

=head2 count (Array)

    ::MD::count::Array ::= function --> Integer_NN <-- (Array)
        implements 2::""
        : (topic -->^ FDN__Array_count);

I<TODO.>

=head2 elem (Array)

    ::MD::elem::Array ::= function --> Any <-- (Array, Integer_NN)
        implements 2::""
        requires (topic --> \@has_index)
        : (topic -->^ FDN__Array_elem);

I<TODO.>

=head2 has_index (Array)

    ::MD::has_index::Array ::= function --> Boolean <-- (Array, Integer_NN)
        implements 2::""
        : (topic -->^ FDN__Array_has_index);

I<TODO.  True if given array index exists.>

=head2 has (Array)

    ::MD::has::Array ::= function --> Boolean <-- (Array, Any)
        implements 2::""
        : (topic -->^ FDN__Array_has);

I<TODO.  True if given element value exists at any index.>

=head2 nest (Array)

    ::MD::nest::Array ::= function --> Array <-- (Array)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Array_nest);

I<TODO.>

=head2 unnest (Array)

    ::MD::unnest::Array ::= function --> Array <-- (Array)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Array_unnest);

I<TODO.>

=head2 any (Array)

    ::MD::any::Array ::= function --> Boolean <-- (Array, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Array_any);

I<TODO.>

=head2 where (Array)

    ::MD::where::Array ::= function --> Array <-- (Array, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Array_where);

I<TODO.>

=head2 map (Array)

    ::MD::map::Array ::= function --> Array <-- (Array, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Array_map);

I<TODO.>

=head2 reduce (Array)

    ::MD::reduce::Array ::= function --> Any <-- (Array, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Array_reduce);

I<TODO.>

=head2 first_index

    ::MD::first_index::Array ::= function --> Integer_NN <-- (Array)
        implements 2::""
        requires (?\.0)
        : (0);

I<TODO.>

=head2 last_index

    ::MD::last_index::Array ::= function --> Integer_NN <-- (Array)
        implements 2::""
        requires (?\.0)
        : (-- #\.0);

I<TODO.>

=head2 slice

    ::MD::slice::Array ::= function --> Array <-- (Array, Interval)
        implements 2::""
        : (topic -->^ FDN__Array_slice);

I<TODO.>

=head2 catenate (Array)

    ::MD::catenate::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        is associative identity ([])
        : (topic -->^ FDN__Array_catenate);

I<TODO.>

=head2 index_succ_all_matches (Array)

    ::MD::index_succ_all_matches::Array ::= function
        --> Integer_NN <-- (Array, Array)
        implements 2::""
        is commutative
        : (topic -->^ FDN__Array_index_succ_all_matches);

I<TODO.  While conceivably implementable at a higher level, make low level
for perceived efficiency.>

=head1 SETTY DATA TYPES

=head2 Setty

    ::MD::Setty ::= interface
        composes Homogeneous
        requires_implements {so,empty,count,has,nest,unnest,any,where,map,reduce,...};

I<TODO.  For collections that make sure each element can only appear once.
Composed by: Set, Relation.>

=head1 SET DATA TYPES

=head2 Set

    ::MD::Set ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped( topic, \Set, \@1::_Asset ))
            default ({})
            composes Setty and_provides_its_default;

        _Asset ::= selection of Bag
            where (...);
    };

I<TODO. Update 'where' to say quantity for each distinct member is 1,
using a Foundation function specific to that purpose.>

=head2 ?∅

    ::MDA::"?∅" ::= constant ({});

The constant C<?∅> represents the only zero-member C<Set> value.

=head2 so (Set)

    ::MD::so::Set ::= function --> Boolean <-- (Set)
        implements 2::""
        : (\.0 != {});

The function C<so::Set> ...  This function implements the C<Boolable>
virtual function C<so> aka C<?> aka C<to_Boolean> for the composing type C<Set>.

I<TODO.>

=head2 empty (Set)

    ::MD::empty::Set ::= function --> Set <-- (Set)
        implements 2::""
        : ({});

I<TODO.>

=head2 count (Set)

    ::MD::count::Set ::= function --> Integer_NN <-- (Set)
        implements 2::""
        : (\.0->unwrap->count);

I<TODO.>

=head2 has (Set)

    ::MD::has::Set ::= function --> Boolean <-- (Set, Any)
        implements 2::""
        : (\.0->unwrap has \.1);

I<TODO.>

=head2 nest (Set)

    ::MD::nest::Set ::= function --> Set <-- (Set)
        implements 2::""
        requires (...)
        : (\Set wrap (\.0->unwrap->nest));

I<TODO.>

=head2 unnest (Set)

    ::MD::unnest::Set ::= function --> Set <-- (Set)
        implements 2::""
        requires (...)
        : (\Set wrap (\.0->unwrap->unnest));

I<TODO.>

=head2 any (Set)

    ::MD::any::Set ::= function --> Boolean <-- (Set, Primed_Func_Ref)
        implements 2::""
        : (\.0->unwrap any \.1);

I<TODO.>

=head2 where (Set)

    ::MD::where::Set ::= function --> Set <-- (Set, Primed_Func_Ref)
        implements 2::""
        : (\Set wrap (\.0->unwrap where \.1));

I<TODO.>

=head2 map (Set)

    ::MD::map::Set ::= function --> Set <-- (Set, Primed_Func_Ref)
        implements 2::""
        : (\Set wrap (\.0->unwrap map \.1));

I<TODO.>

=head2 reduce (Set)

    ::MD::reduce::Set ::= function --> Any <-- (Set, Primed_Func_Ref)
        implements 2::""
        : (\Set wrap (\.0->unwrap reduce \.1));

I<TODO.>

=head1 BAG DATA TYPES

=head2 Bag

    ::MD::Bag ::= selection where (topic -->^ FDN__is_a_Bag)
        default (\+{})
        composes Homogeneous;

The selection contract C<Bag> represents the infinite Muldis
D Foundation type I<FDN__Bag>.  A C<Bag> value is ...

I<TODO.>

=head2 +∅

    ::MDA::"+∅" ::= constant (\+{});

The constant C<+∅> represents the only zero-member C<Bag> value.

=head2 so (Bag)

    ::MD::so::Bag ::= function --> Boolean <-- (Bag)
        implements 2::""
        : (\.0 != \+{});

The function C<so::Bag> ...  This function implements the C<Boolable>
virtual function C<so> aka C<?> aka C<to_Boolean> for the composing type C<Bag>.

I<TODO.>

=head2 empty (Bag)

    ::MD::empty::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        : (\+{});

I<TODO.>

=head2 count (Bag)

    ::MD::count::Bag ::= function --> Integer_NN <-- (Bag)
        implements 2::""
        : (topic -->^ FDN__Bag_count);

I<TODO.>

=head2 has (Bag)

    ::MD::has::Bag ::= function --> Boolean <-- (Bag, Any)
        implements 2::""
        : (topic -->^ FDN__Bag_has);

I<TODO.>

=head2 nest (Bag)

    ::MD::nest::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Bag_nest);

I<TODO.>

=head2 unnest (Bag)

    ::MD::unnest::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Bag_unnest);

I<TODO.>

=head2 any (Bag)

    ::MD::any::Bag ::= function --> Boolean <-- (Bag, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Bag_any);

I<TODO.>

=head2 where (Bag)

    ::MD::where::Bag ::= function --> Bag <-- (Bag, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Bag_where);

I<TODO.>

=head2 map (Bag)

    ::MD::map::Bag ::= function --> Bag <-- (Bag, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Bag_map);

I<TODO.>

=head2 reduce (Bag)

    ::MD::reduce::Bag ::= function --> Any <-- (Bag, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Bag_reduce);

I<TODO.>

=head1 ATTRIBUTIVE DATA TYPES

=head2 Attributive

    ::MD::Attributive ::= interface
        requires_implements {has_any_attrs,degree,on,but,extend,rename,has_attrs,has_just_attrs};

I<TODO.  For types that support attribute-name-based lookup of values;
for collections of name-value pairs where all names are distinct;
for typically heterogeneous collections.
Composed by: Tuple, Relation, Tuple_Bag.>

=head2 Excuse::No_Such_Attr

    ::MD::Excuse::No_Such_Attr ::= constant (\@0) composes Excuse;

I<TODO.>

=head2 has_any_attrs ?^

    ::MD::has_any_attrs::"" ::= function virtual --> Boolean <-- (Attributive);

    ::MD::"?^" ::= alias of has_any_attrs;

I<TODO.>

=head2 is_nullary !?^

    ::MD::is_nullary ::= function negates has_any_attrs;

    ::MD::"!?^" ::= alias of is_nullary;

I<TODO.>

=head2 degree #^

    ::MD::degree::"" ::= function virtual --> Integral <-- (Attributive);

    ::MD::"#^" ::= alias of degree;

I<TODO.>

=head2 on ^ project

    ::MD::on::"" ::= function virtual
        --> Attributive <-- (Attributive, Attr_Names)
        requires (...);

    ::MD::"^"     ::= alias of on;
    ::MD::project ::= alias of on;

I<TODO.  Also, this is analogous to set intersect.>

=head2 from

    ::MD::from ::= function commutes on;

I<TODO.>

=head2 but -^ project_all_but

    ::MD::but::"" ::= function virtual
        --> Attributive <-- (Attributive, Attr_Names)
        requires (...);

    ::MD::"-^"            ::= alias of but;
    ::MD::project_all_but ::= alias of but;

I<TODO.  Also, this is analogous to set difference.>

=head2 extend +^

    ::MD::extend::"" ::= function virtual
        --> Attributive <-- (Attributive, Attributive)
        requires (topic --> \@atnms_disjoint)
        is {associative,commutative};

    ::MD::"+^" ::= alias of extend;

I<TODO.  Also, this is analogous to set union (disjoint).>

I<Note: There is no version of 'extend' that takes a routine; one can just
use the above version plus an eg-tuple selector. In the case of relation
extend, one can do the aforementioned within a 'map' routine, for the
routine version; they can use join/cross-product for the static version.>

=head2 rename

    ::MD::rename::"" ::= function virtual
        --> Attributive <-- (Attributive, Attr_Renaming)
        requires (...);

I<TODO.>

=head2 renaming

    ::MD::renaming ::= function commutes rename;

I<TODO.>

=head2 atnms_disjoint

    ::MD::atnms_disjoint ::= function
        --> Boolean <-- (Attributive, Attributive)
        is commutative
        : (...);

I<TODO.>

=head2 has_attrs ^?

    ::MD::has_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, Signature);

    ::MD::"^?" ::= alias of has_attrs;

I<TODO.>

=head2 has_just_attrs ^?=

    ::MD::has_just_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, Signature);

    ::MD::"^?=" ::= alias of has_just_attrs;

I<TODO.>

=head1 TUPLE DATA TYPES

=head2 Tuple

    ::MD::Tuple ::= selection where (topic -->^ FDN__is_a_Tuple)
        default (\%())
        composes {Accessible and_provides_its_default,
            Attributive and_provides_its_default};

The selection contract C<Tuple> represents the infinite
Muldis D Foundation type I<FDN__Tuple>.  A C<Tuple> value is ...

I<TODO.>

=head2 Tuple_D0 D0

    ::MD::Tuple_D0 ::= constant (\%());

    ::MD::D0 ::= alias of Tuple_D0;

The constant C<Tuple_D0> aka C<D0> represents the only zero-attribute
C<Tuple> value.

=head2 has_any_attrs (Tuple)

    ::MD::has_any_attrs::Tuple ::= function --> Boolean <-- (Tuple)
        implements 2::""
        : (\.0 != \%());

I<TODO.>

=head2 degree (Tuple)

    ::MD::degree::Tuple ::= function --> Integer_NN <-- (Tuple)
        implements 2::""
        : (topic -->^ FDN__Tuple_degree);

I<TODO.>

=head2 attr . (Tuple)

    ::MD::attr ::= function --> Any <-- (Tuple, Attr_Name)
        requires (topic --> \@has_attr)
        : (topic -->^ FDN__Tuple_attr);

    ::MD::"."::Tuple ::= function --> Any <-- (Tuple, Attr_Name)
        implements 2::""
        requires (topic --> \@has_attr)
        : (topic --> \@attr);

I<TODO.>

=head2 has_attr .? (Tuple)

    ::MD::has_attr ::= function --> Boolean <-- (Tuple, Attr_Name)
        : (topic -->^ FDN__Tuple_has_attr);

    ::MD::".?"::Tuple ::= function --> Boolean <-- (Tuple, Attr_Name)
        implements 2::""
        : (topic --> \@has_attr);

I<TODO.>

=head2 attr_or_excuse .! (Tuple)

    ::MD::attr_or_excuse ::= function --> Any <-- (Tuple, Attr_Name)
        : (topic --> \@has_attr ?? topic --> \@attr !! Excuse::No_Such_Attr());

    ::MD::".!"::Tuple ::= function --> Any <-- (Tuple, Attr_Name)
        implements 2::""
        : (topic --> \@attr_or_excuse);

I<TODO.>

=head2 on (Tuple)

    ::MD::on::Tuple ::= function --> Tuple <-- (Tuple, Attr_Names)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Tuple_on);

I<TODO.>

=head2 but (Tuple)

    ::MD::but::Tuple ::= function --> Tuple <-- (Tuple, Attr_Names)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Tuple_but);

I<TODO.>

=head2 extend (Tuple)

    ::MD::extend::Tuple ::= function --> Tuple <-- (Tuple, Tuple)
        implements 2::""
        requires (topic --> \@atnms_disjoint)
        is {associative,commutative} identity (\%())
        : (topic -->^ FDN__Tuple_extend);

I<TODO.>

=head2 rename (Tuple)

    ::MD::rename::Tuple ::= function --> Tuple <-- (Tuple, Attr_Renaming)
        implements 2::""
        requires (...)
        : (...);

I<TODO.>

=head2 has_attrs (Tuple)

    ::MD::has_attrs::Tuple ::= function --> Boolean <-- (Tuple, Signature)
        implements 2::""
        : (...);

I<TODO.>

=head2 has_just_attrs (Tuple)

    ::MD::has_just_attrs::Tuple ::= function --> Boolean <-- (Tuple, Signature)
        implements 2::""
        : (...);

I<TODO.>

=head2 any_attrs

    ::MD::any_attrs ::= function --> Boolean <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_any_attrs);

I<TODO.>

=head2 none_of_attrs

    ::MD::none_of_attrs ::= function negates any_attrs;

I<TODO.>

=head2 all_attrs

    ::MD::all_attrs ::= function --> Boolean <-- (Tuple, Primed_Func_Ref)
        : (\.0 none_of_attrs negated_func(of : \.1, passing_args : \@(0)));

I<TODO.>

=head2 attrs_where

    ::MD::attrs_where ::= function --> Tuple <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_attrs_where);

I<TODO.>

=head2 attrs_map

    ::MD::attrs_map ::= function --> Tuple <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_attrs_map);

I<TODO.>

=head2 attrs_reduce

    ::MD::attrs_reduce ::= function --> Any <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_attrs_reduce);

I<TODO.>

=head1 RELATION DATA TYPES

=head2 Relation

    ::MD::Relation ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped( topic, \Relation, \@1::_Asset ))
            default (\?%())
            composes {Setty, Attributive};

        _Asset ::= selection of Tuple_Bag
            where (...);
    };

I<TODO.  See also definition of Set in terms of Bag, which Relation mirrors.>

=head2 Relation_D0C0 D0C0

    ::MD::Relation_D0C0 ::= constant (\?%());

    ::MD::D0C0 ::= alias of Relation_D0C0;

The constant C<Relation_D0C0> aka C<D0C0> represents the only
zero-attribute, zero-tuple C<Relation> value.  Note that I<The Third
Manifesto> also refers to this value by the special name I<TABLE_DUM>.

=head2 Relation_D0C1 D0C1

    ::MD::Relation_D0C1 ::= constant (\?%{()});

    ::MD::D0C1 ::= alias of Relation_D0C1;

The constant C<Relation_D0C1> aka C<D0C1> represents the only
zero-attribute, single-tuple C<Relation> value.  Note that I<The Third
Manifesto> also refers to this value by the special name I<TABLE_DEE>.

=head1 TUPLE-BAG DATA TYPES

=head2 Tuple_Bag

    ::MD::Tuple_Bag ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped( topic, \Tuple_Bag, \@1::_Asset ))
            default (\+%())
            composes {Homogeneous, Attributive};

        _Asset ::= selection of Tuple where
        (
            if topic ^?= \%( heading : \@Attr_Names, body : \@Bag ) then
                if \.body all_is_a \@Tuple then
                    \.body all (\@"^?=" assuming \.heading)
                else
                    False
            else
                False
        );
    };

I<TODO.>

=head2 Tuple_Bag_D0C0

    ::MD::Tuple_Bag_D0C0 ::= constant (\+%());

The constant C<Tuple_Bag_D0C0> represents the only zero-attribute,
zero-tuple C<Tuple_Bag> value.

=head2 Tuple_Bag_D0C1

    ::MD::Tuple_Bag_D0C1 ::= constant (\+%{()});

The constant C<Tuple_Bag_D0C1> represents the only zero-attribute,
single-tuple C<Tuple_Bag> value.

=head1 CAPSULE DATA TYPES

=head2 Capsule

    ::MD::Capsule::"" ::= selection where (topic -->^ FDN__is_a_Capsule)
        default (False wrap False);

The selection contract C<Capsule> represents the infinite Muldis D
Foundation type I<FDN__Capsule>.  An C<Capsule> value is ...

I<TODO.  Candidate literal syntax is `\:(wrapper,asset)`.>

Given that almost every selection contract is a subset of
C<Capsule>, the latter intentionally does not compose any interface
contracts, and only has the minimal set of its own operators, so to
minimize interference with other types' interfaces.

=head2 Capsule::wrap

    ::MD::Capsule::wrap ::= function --> Capsule <-- (Any, Any)
        : (topic -->^ FDN__Capsule_wrap);

I<TODO.>

=head2 Capsule::wrapper

    ::MD::Capsule::wrapper ::= function --> Any <-- (Capsule)
        : (topic -->^ FDN__Capsule_wrapper);

I<TODO.>

=head2 Capsule::unwrap

    ::MD::Capsule::unwrap ::= function --> Any <-- (Capsule)
        : (topic -->^ FDN__Capsule_unwrap);

I<TODO.>

=head2 Capsule::has_wrapped

    ::MD::Capsule::has_wrapped ::= function
        --> Boolean <-- (Capsule, Any, Reference)
        : (wrapper(\.0) = \.1 and unwrap(\.0) --> \.2);

I<TODO.>

=head1 EXTERNAL DATA TYPES

=head2 External

    ::MD::External::"" ::= selection where (topic -->^ FDN__is_a_External)
        default (-->^ FDN__default_External);

The selection contract C<External> represents the infinite Muldis D
Foundation type I<FDN__External>.  An C<External> value is an opaque and
transient reference to an entity that is defined and managed externally to
the Muldis D language environment, either internally to the Muldis D host
implementation or in some peer language that it mediates.  Its default
value is implementation-defined.

As C<External> values are black boxes to Muldis D, it is the responsibility
of their external manager to at the very least implement the C<same>
function for them in a fully deterministic manner, as well as externally
define any other operators for them that users may wish to invoke for those
values from Muldis D code, including any to map with or marshal with Muldis
D values.

=head2 External::call_function

    ::MD::External::call_function ::= function --> Any <-- Any
        : (FDN__External_call_function ^<-- topic);

The function C<External::call_function> is a proxy for invoking a function
that is defined and managed externally to the Muldis D language
environment.  Muldis D will assume said function is completely
deterministic, and there would likely be problems if it isn't.  Using
C<External::call_function> as a foundation, it is possible to define an
arbitrarily complex type graph involving C<External> values.

=head1 SOURCE CODE BEHAVIOURAL DATA TYPES

I<TODO.>

=head2 Source_Code::Package_List

    ::MD::Source_Code::Package_List ::= selection of Array
        where (topic all_is_a (selection of {Package, Decoration} default Package()));

I<TODO.>

=head2 Source_Code::Package

    ::MD::Source_Code::Package ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped( topic, \Package, \@1::_Asset ))
            default (\Package wrap 1::_Asset());

        _Asset ::= selection of Tuple where
        (
            if
                topic ^?= \%(
                    identity : (selection of Pkg_Decl_Map where (degree(topic) = 1)),
                    foundation : ...,
                    uses : \@Pkg_Decl_Map,
                    floating : ...,
                    materials : ...,
                    annotation : ...,
                    decoration : ...,
                )
            then
                topic.\uses atnms_disjoint topic.\identity
            else
                False
        );
    };

I<TODO.>

=head2 Source_Code::Pkg_Decl_Map

    ::MD::Source_Code::Pkg_Decl_Map ::= selection of Tuple
        where (topic all_attrs (function : (\.asset --> \@Pkg_Canon_Name)));

I<TODO.>

=head2 Source_Code::negated_func

    ::MD::Source_Code::negated_func ::= function --> Primed_Func_Ref
        <-- (of : Primed_Func_Ref, passing_args : Attr_Names)
    : (
        (function : (
            not(
                (\.of.\args +^ (topic ^ \.passing_args)) --> (\.of.\func)
            )
        )) assuming topic
    );

I<TODO.  This expects the original function is from Tuple to Boolean.>

=head1 SOURCE CODE ANNOTATION DATA TYPES

I<TODO.>

=head2 Source_Code::Annotation

    ::MD::Source_Code::Annotation::"" ::= interface;

I<TODO.>

=head2 Source_Code::Annotation::Comment

    ::MD::Source_Code::Annotation::Comment ::= selection of Capsule
        where (has_wrapped( topic, \Comment, \@Text ))
        default (\~?'')
        composes Annotation;

I<TODO.>

=head1 SOURCE CODE DECORATION DATA TYPES

I<TODO.  Generally speaking, all Decoraction types are declared by a
package that is not Core, such as in the Core::Plain_Text package.>

I<TODO:  The decoration data types may loosely resemble template defs so
that decorations don't necessarily have to be attached to all
behavioral/annotation nodes they are conceptually adjacent / apply to but
rather can be in some nearby parent context and refer to behavioral/etc
nodes by name.>

=head2 Source_Code::Decoration

    ::MD::Source_Code::Decoration::"" ::= interface;

I<TODO.>

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::See_Also> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright © 2002-2015, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
