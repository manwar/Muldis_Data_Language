=pod

=encoding utf8

=head1 NAME

Muldis::D::Package::Muldis_D -
Muldis D core data types and operators

=head1 VERSION

This document is Muldis::D::Package::Muldis_D version 0.200.1.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document
before you read this one, which provides subservient details.

=head1 SYNOPSIS

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script ASCII;
    package
    {
        identity My_App ::= My_App:"http://mycorp.com":"0";
        uses
        {
            MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        };
        materials
        {
            floating {::My_App, ::MD};

            `TODO: Put example routines etc here.`

        };
    };

=head1 DESCRIPTION

This document defines the Muldis D Plain Text package
C<Muldis_D:"http://muldis.com":"0.200.1"> which provides the common core
system-defined data types and operators that regular users of the language
would employ directly in their applications and schemas.

This document I<also> defines the Muldis D Plain Text package
C<Muldis_D::Aliases:"http://muldis.com":"0.200.1"> which adds trans-ASCII
Unicode aliases to C<Muldis_D> package entities.

Note that for brevity this document will use the unqualified term
I<argument> to refer to a function's conceptual argument that is actually
an attribute of a I<FDN__Tuple_Inf> typed actual argument; the latter will
be qualified as I<topic> in the rarer circumstance where that is meant.

=head1 PACKAGES

From one source:

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script ASCII;
    package
    {
        identity MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        materials
        {
            floating {::MD, ::MD::Source_Code};
            ...
        };
    };

From a separate source:

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script Unicode:8.0:UTF-8:canon;
    package
    {
        identity MDA ::= Muldis_D::Aliases:"http://muldis.com":"0.200.1";
        uses
        {
            MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        };
        materials
        {
            floating {::MD, ::MDA};
            ...
        };
    };

=head1 MAXIMAL AND MINIMAL DATA TYPES

=head2 Anything Any

    ::MD::Anything ::= selection default (False);

    ::MD::Any ::= alias of Anything;

The selection contract C<Anything> aka C<Any> represents the infinite
I<universal type>, which is the maximal data type of the entire Muldis D
type system and consists of all values which can possibly exist.  It also
represents the infinite Muldis D Foundation type I<FDN__Anything>.  Its
default value is C<False>.  Other programming languages may name their
corresponding types I<Any> or I<Object> or I<Anything>.

=head2 Nothing

    ::MD::Nothing ::= selection of {};

The selection contract C<Nothing> represents the finite I<empty type>,
which is the minimal data type of the entire Muldis D type system and
consists of exactly zero values.  It can not have any default value.

=head2 same =

    ::MD::same ::= function --> Boolean <-- (Any, Any)
        is commutative
        : (topic -->^ FDN__same);

    ::MD::"=" ::= alias of same;

The function C<same> aka C<=> results in C<True> iff its 2 arguments C<0>
and C<1> are exactly the same value, and C<False> otherwise.  Other
programming languages may name their corresponding operators I<==> or
I<===> or I<eq>.

=head2 not_same != ≠

    ::MD::not_same ::= function negates same
        is commutative;

    ::MD::"!=" ::= alias of not_same;
    ::MDA::"≠" ::= alias of not_same;

The function C<not_same> aka C<!=> aka C<≠> results in C<False> iff its 2
arguments C<0> and C<1> are exactly the same value, and C<True> otherwise.
Other programming languages may name their corresponding operators
I<< <> >> or I<!===> or I<ne>.

=head2 isa

    ::MD::isa ::= function --> Boolean <-- (Any, Reference)
        : (\.0 --> \.1);

The function C<isa> results in C<True> iff its C<0> argument is a
member of the type specified by its C<1> argument, and C<False> otherwise.

=head2 not_isa

    ::MD::not_isa ::= function negates isa;

The function C<not_isa> results in C<False> iff its C<0> argument is a
member of the type specified by its C<1> argument, and C<True> otherwise.

=head2 default

    ::MD::default ::= function --> Any <-- (Reference)
        : (--> \.0);

The function C<default> results in the default value of the not-empty type
specified by its C<0> argument.

=head1 EXCUSE DATA TYPES

=head2 Excuse

    ::MD::Excuse::"" ::= interface;

The semantic contract C<Excuse> is infinite.  An C<Excuse> value is an
explicitly stated reason for why, given some particular problem domain, a
value is not being used that is ordinary for that domain.  For example, the
typical integer division operation is not defined to give an integer result
when the divisor is zero, and so a Muldis D function for integer division
could be defined to result in an C<Excuse> value rather than throw an
exception in that case.  For another example, an C<Excuse> value could be
used to declare that the information we are storing about a person is
missing certain details and why those are missing, such as because the
person left the birthdate field blank on their application form.  Its
default value is C<Excuse::No_Reason>.  An C<Excuse> is isomorphic to an
C<Exception> but that use of the former is not meant to terminate execution
of code early unlike the latter which is.  Other programming languages that
have typed exceptions are analogous.

=head2 Excuse::No_Reason

    ::MD::Excuse::No_Reason ::= constant (\@0)
        composes Excuse and_provides_its_default;

The constant C<Excuse::No_Reason> represents the C<Excuse> value which
simply says that an ordinary value for any given domain is missing and that
there is simply no excuse that has been given for this; in other words,
something has gone wrong without the slightest hint of an explanation.
This is conceptually the most generic C<Excuse> value there is and it can
be used by lazy programmers as a fallback for when they don't have even a
semblance of a better explanation for why an ordinary value is missing.
Other programming languages may name their corresponding values or
quasi-values I<null> or I<nil> or I<none> or I<nothing> or I<undef> or
I<unknown>; but unlike some of those languages, C<No_Reason> equals itself.

=head2 coalesce or_else ?!

    ::MD::coalesce ::= function --> Any <-- (Any, Any)
        : (\.0 --> \@Excuse ?? \.1 !! \.0);

    ::MD::or_else ::= alias of coalesce;
    ::MD::"?!"    ::= alias of coalesce;

The function C<coalesce> aka C<or_else> aka C<?!> results in its C<0>
argument iff the latter is not an C<Excuse>, and results in its C<1>
argument otherwise.  This function is designed to be chained for any number
of sequenced values in order to pick the first non-C<Excuse> in a list.

=head1 ORDERABLE DATA TYPES

=head2 Orderable

    ::MD::Orderable ::= interface
        requires_implements in_order;

The interface contract C<Orderable> is infinite.  An C<Orderable> value has
all of the traditional comparison operators defined for it such that values
of its type I<T> can be deterministically sorted by Muldis D into a
canonical total order.  But I<T> otherwise does not necessarily have
conceptually a total order in the normal sense or that order is different
than what the provided comparison operators give you.  An C<Orderable> type
is a type for which one can take all of its values and place them on a line
such that each value is definitively considered I<before> all of the values
one one side and I<after> all of the values on the other side.  Other
programming languages may name their corresponding types I<IComparable> or
I<Ord> or I<ordered> or I<ordinal>.

The default value of C<Orderable> is C<False>.  The minimum and maximum
values of C<Orderable> are C<Neg_Inf> and C<Pos_Inf>, respectively; these 2
C<Excuse> values are canonically considered to be before and after,
respectively, I<every> other value of the Muldis D type system, regardless
of whether those values are members a type for which an
C<Orderable>-composing contract exists.  The primary reason for having
these values C<Neg_Inf> and C<Pos_Inf> is so Muldis D has an easy
consistent way to define an C<Interval> that is partially or completely
unbounded, and to use as identity values for chained order-comparisons.

C<Orderable> is composed, directly or indirectly, by: C<Neg_Inf>,
C<Pos_Inf>, C<Enumerable>, C<Boolean>, C<Integral>, C<Integer>,
C<Positional>, C<Array>, C<String>, C<Blob>, C<Text>.

=head2 Neg_Inf -∞

    ::MD::Neg_Inf ::= constant (\@0) composes {Orderable, Excuse};

    ::MDA::"-∞" ::= alias of Neg_Inf;

The constant C<Neg_Inf> aka C<-∞> represents the type-agnostic concept of
negative infinity, an C<Orderable> value that sorts I<before> all other
values in the Muldis D type system.  This value is also an C<Excuse> that
says the result of some operation is infinite in the negative direction.
Note that IEEE floating-point standards define a negative infinity value.

=head2 Pos_Inf +∞

    ::MD::Pos_Inf ::= constant (\@0) composes {Orderable, Excuse};

    ::MDA::"+∞" ::= alias of Pos_Inf;

The constant C<Pos_Inf> aka C<-∞> represents the type-agnostic concept of
positive infinity, an C<Orderable> value that sorts I<after> all other
values in the Muldis D type system.  This value is also an C<Excuse> that
says the result of some operation is infinite in the positive direction.
Note that IEEE floating-point standards define a positive infinity value.

=head2 in_order

    ::MD::in_order::"" ::= function virtual
        --> Boolean <-- (Orderable, Orderable);

The virtual function C<in_order> results in C<True> iff its 2 arguments are
considered to already be I<in order> as given to the function, meaning that
either both arguments are exactly the same value or otherwise that the C<0>
argument value is definitively considered I<before> the C<1> argument
value; if C<0> is considered I<after> C<1> then C<in_order> results in
C<False>.  The primary reason for C<in_order> is to underlie all
order-determination or value sorting operations in an easy consistent way;
an C<Orderable>-composing contract only has to implement C<in_order> and
then values of its type can be compared, sorted on, and have intervals
defined in terms of them.

Other programming languages may instead typically use a three-way
comparison operator for this role, where its possible result values are
I<before>, I<same>, and I<after>, and those 3 are typically represented by
either the integers {-1,0,1} or a special 3-valued enumeration type.  Said
operators may be named I<< <=> >> or I<cmp> or I<compare> or I<CompareTo>
or I<memcmp> or I<strcmp>.  But Muldis D uses a C<Boolean> result instead
partly to keep its core type system simpler (it would have gone the
enumeration route) and partly because the logic for doing sorting or
comparisons or validation is typically much simpler with this foundation.

=head2 in_order (Neg_Inf, Pos_Inf)

    ::MD::in_order::Neg_Inf_L ::= function --> Boolean <-- (Neg_Inf, Orderable)
        implements 2::""
        : (True);

    ::MD::in_order::Neg_Inf_R ::= function --> Boolean <-- (Orderable, Neg_Inf)
        implements 2::""
        : (topic --> \@same);

    ::MD::in_order::Pos_Inf_L ::= function --> Boolean <-- (Pos_Inf, Orderable)
        implements 2::""
        : (topic --> \@same);

    ::MD::in_order::Pos_Inf_R ::= function --> Boolean <-- (Orderable, Pos_Inf)
        implements 2::""
        : (True);

The 4 functions {C<in_order::Neg_Inf_L>, C<in_order::Neg_Inf_R>,
C<in_order::Pos_Inf_L>, C<in_order::Pos_Inf_R>} implement the C<Orderable>
virtual function C<in_order> for the composing types C<Neg_Inf> and
C<Pos_Inf>, specifically for comparing either value with any C<Orderable>.

=head2 before <

    ::MD::before ::= function commutes after;

    ::MD::"<" ::= alias of before;

The function C<before> aka C<< < >> results in C<True> iff its C<0>
argument is I<before> its C<1> argument; otherwise it results in C<False>.
Other programming languages may name this operator I<lt>.

=head2 after >

    ::MD::after ::= function negates before_or_same;

    ::MD::">" ::= alias of after;

The function C<after> aka C<< > >> results in C<True> iff its C<0>
argument is I<after> its C<1> argument; otherwise it results in C<False>.
Other programming languages may name this operator I<gt>.

=head2 before_or_same <= ≤

    ::MD::before_or_same ::= alias of in_order;

    ::MD::"<=" ::= alias of before_or_same;
    ::MDA::"≤" ::= alias of before_or_same;

The function C<before_or_same> aka C<< <= >> aka C<≤> results in C<True>
iff its C<0> argument is I<before> its C<1> argument or they are the same
value; otherwise it results in C<False>.  Other programming languages may
name this operator I<le>.

=head2 after_or_same >= ≥

    ::MD::after_or_same ::= function commutes before_or_same;

    ::MD::">=" ::= alias of after_or_same;
    ::MDA::"≥" ::= alias of after_or_same;

The function C<after_or_same> aka C<< >= >> aka C<≥> results in C<True>
iff its C<0> argument is I<after> its C<1> argument or they are the same
value; otherwise it results in C<False>.  Other programming languages may
name this operator I<ge>.

=head2 min

    ::MD::min ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity (Pos_Inf())
        : (topic --> \@in_order ?? \.0 !! \.1);

The function C<min> results in whichever of its 2 arguments is first when
the 2 are sorted I<in order>.  This function is designed to be chained for
any number of values in order to pick the one that sorts
I<before> all of the others.

=head2 max

    ::MD::max ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity (Neg_Inf())
        : (topic --> \@in_order ?? \.1 !! \.0);

The function C<max> results in whichever of its 2 arguments is last when
the 2 are sorted I<in order>.  This function is designed to be chained for
any number of values in order to pick the one that sorts
I<after> all of the others.

=head2 minmax

    ::MD::minmax ::= function
        --> (Orderable, Orderable) <-- (Orderable, Orderable)
        is commutative
        : (topic --> \@in_order ?? topic !! \%(\.1, \.0));

The function C<minmax> results in a binary C<Tuple> containing its 2
arguments sorted I<in order>; the function's result is the same as its
topic when the arguments are already in order, and the reverse of that
otherwise, meaning the values of C<0> and C<1> are swapped.

=head1 ENUMERABLE DATA TYPES

=head2 Enumerable

    ::MD::Enumerable ::= interface
        composes Orderable and_provides_its_default
        requires_implements {in_order,pred,succ};

The interface contract C<Enumerable> is infinite.  An C<Enumerable> value
is an C<Orderable> value for which, using the same canonical total order
for its type, there exists a definitive I<predecessor> or I<successor>
value, at least where the given value isn't the first or last value on the
line respectively.  Similarly, one can take any two values of an
C<Enumerable> type and produce an ordered list of all of that type's values
which are on the line between those two values.  A primary quality of a
type that is C<Orderable> but not C<Enumerable> is that you can take any
two values of that type and then find a third value of that type which lies
between the first two on the line; by definition for an C<Enumerable> type,
there is no third value between one of its values and that value's
predecessor or successor value.  Other programming languages may name their
corresponding types I<ordinal> or categorically as I<enum>.  Note that
while a generic rational numeric type may qualify as an ordinal type by
some definitions of I<ordinal>, since it is possible to count all the
rationals if arranged a particular way, these types would not qualify as
C<Enumerable> here when that ordering is not the same as the one used for
the same type's C<Orderable> comparisons.  The default and minimum and
maximum values of C<Enumerable> are the same as those of C<Orderable>.
C<Enumerable> is composed, directly or indirectly, by: C<Boolean>,
C<Integral>, C<Integer>.

For some C<Enumerable> types, there is the concept of a I<quantum> or
I<step size>, where every consecutive pair of values on that type's value
line are conceptually spaced apart at equal distances; this distance would
be the quantum, and all steps along the value line are at exact multiples
of that quantum.  However, C<Enumerable> types in general don't need to be
like this, and there can be different amounts of conceivable distance
between consecutive values; an C<Enumerable> type is just required to know
where all the values are.  For example, C<Integer> has a quantum while a
subtype consisting just of prime numbers does not.

=head2 pred

    ::MD::pred::"" ::= function virtual --> Enumerable <-- (Enumerable);

The virtual function C<pred> results in the I<predecessor> value of its
C<0> argument, or in C<Neg_Inf> if there is none.  Other programming
languages may name their corresponding operators I<--> or I<decrement>.

=head2 succ

    ::MD::succ::"" ::= function virtual --> Enumerable <-- (Enumerable);

The virtual function C<succ> results in the I<successor> value of its
C<0> argument, or in C<Pos_Inf> if there is none.  Other programming
languages may name their corresponding operators I<++> or I<increment>.

=head1 BOOLABLE DATA TYPES

=head2 Boolable

    ::MD::Boolable ::= interface requires_implements so;

The interface contract C<Boolable> is infinite.  A C<Boolable> value has a
canonical way of being cast to a C<Boolean> value in a context-free manner,
as the answer to the non-specific question "Is that so?" on the value taken
in isolation, whatever that would conceivably mean for the value's type.
The idiomatic predicate being asked has to do with whether or not something
exists; for composing numeric types it is asking whether the number is
nonzero; for composing collection types it is asking whether the collection
has any members.  The primary reason for C<Boolable> is to provide an easy
consistent and terse way to ask a common predicate question such as this.
The default value of C<Boolable> is C<False>.  Other programming languages
often have the concept of particular values from a wide variety of types as
being conceptually either I<false> or I<true>, and C<Boolable> is the
formalization of that concept for Muldis D, allowing program code to be
written in a similar style but with more type safety as any treatment of a
value as a C<Boolean> must be made explicit.

C<Boolable> is composed, directly or indirectly, by: C<Boolean>,
C<Numeric>, C<Integral>, C<Integer>, C<Homogeneous>, C<Positional>,
C<Array>, C<String>, C<Blob>, C<Text>, C<Setty>, C<Set>, C<Bag>,
C<Relation>, C<Tuple_Bag>.

While conceivably C<Boolable> could also be composed by C<Attributive>, and
hence C<Tuple>, it isn't because that would set up a semantic conflict for
C<Relation> and C<Tuple_Bag> which are collections across 2 dimensions, and
it was decided for those latter types that C<Boolable> would apply to them
explicitly in their C<Homogeneous> dimension and not in their
C<Attributive> dimension.  As such, the C<Attributive> functions
C<has_any_attrs> and C<is_nullary> are provided as that dimension's direct
analogies to the C<Homogeneous> dimension's C<Boolable>-implementing
C<has_any_members> (C<so>) and C<is_empty> (C<not_so>) functions.

=head2 so ?

    ::MD::so::"" ::= function virtual --> Boolean <-- (Boolable);

    ::MD::"?" ::= alias of so;

The virtual function C<so> aka C<?> results in C<True> typically when
its C<0> argument is a nonzero number or a nonempty collection; otherwise
it results in C<False>.  Other programming languages may name their
corresponding operators I<ToBoolean> or use similar cast-like syntax.

=head2 not_so !?

    ::MD::not_so ::= function negates so;

    ::MD::"!?" ::= alias of not_so;

The function C<not_so> aka C<!?> results in C<True> typically when
its C<0> argument is a number zero or an empty collection; otherwise
it results in C<False>.

=head1 BOOLEAN DATA TYPES

=head2 Boolean Bool

    ::MD::Boolean::"" ::= selection where (topic -->^ FDN__isa_Boolean)
        default (False)
        composes {Enumerable and_provides_its_default,
            Boolable and_provides_its_default};

    ::MD::Bool ::= alias of Boolean;

The selection contract C<Boolean> aka C<Bool> represents the finite Muldis
D Foundation type I<FDN__Boolean>.  A C<Boolean> value is a general purpose
2-valued logic boolean or I<truth value>, or specifically it is one of the
2 values C<False> and C<True>.  Its default value is C<False>.  C<Boolean>
is both C<Orderable> and C<Enumerable>; its minimum value is C<False> and
its maximum value is C<True>.  Other programming languages frequently don't
have a dedicated boolean type but rather consider values of other types,
typically integer types, to be I<false> or I<true>.

=head2 False ⊥

    ::MD::False ::= constant (False);

    ::MDA::"⊥" ::= alias of False;

The constant C<False> aka C<⊥> represents the boolean logical truth value
I<false> aka I<contradiction>.  Other programming languages frequently use
the integer 0 to represent I<false>.

=head2 True ⊤

    ::MD::True ::= constant (True);

    ::MDA::"⊤" ::= alias of True;

The constant C<True> aka C<⊤> represents the boolean logical truth value
I<true> aka I<tautology>.  Other programming languages frequently use the
integer 1 to represent I<true>.

=head2 in_order (Boolean)

    ::MD::in_order::Boolean ::= function --> Boolean <-- (Boolean, Boolean)
        implements 2::""
        : (!\.0 or \.1);

The function C<in_order::Boolean> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Boolean>.

=head2 pred (Boolean)

    ::MD::pred::Boolean ::= function --> {False, Neg_Inf} <-- (Boolean)
        implements 2::""
        : (\.0 ?? False !! Neg_Inf());

The function C<pred::Boolean> implements the C<Enumerable> virtual
function C<pred> for the composing type C<Boolean>.

=head2 succ (Boolean)

    ::MD::succ::Boolean ::= function --> {True, Pos_Inf} <-- (Boolean)
        implements 2::""
        : (!\.0 ?? True !! Pos_Inf());

The function C<succ::Boolean> implements the C<Enumerable> virtual
function C<succ> for the composing type C<Boolean>.

=head2 so (Boolean)

    ::MD::so::Boolean ::= function --> Boolean <-- (Boolean)
        implements 2::""
        : (\.0);

The function C<so::Boolean> performs a logical I<proposition>; it simply
results in its C<0> argument.  This function implements the C<Boolable>
virtual function C<so> aka C<?> for the composing type C<Boolean>.

=head2 not ! ¬

    ::MD::not ::= function negates so::Boolean;

    ::MD::"!"  ::= alias of not;
    ::MDA::"¬" ::= alias of not;

The function C<not> aka C<!> aka C<¬> performs a logical I<negation> or
I<logical complement>; it results in C<True> iff its C<0> argument is
C<False> and vice-versa.  Other programming languages may name their
corresponding operators I<~> or I<N>.

=head2 and ∧

    ::MD::and ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity (True)
        : (\.0 ?? \.1 !! False);

    ::MDA::"∧"  ::= alias of and;

The function C<and> aka C<∧> performs a logical I<conjunction>; it results
in C<True> iff its 2 arguments C<0> and C<1> are both C<True>, and C<False>
otherwise.  Other programming languages may name their corresponding
operators I<&> or I<&&> or I<K>.

=head2 nand not_and ⊼ ↑

    ::MD::nand ::= function negates and
        is commutative;

    ::MD::not_and ::= alias of nand;
    ::MDA::"⊼"    ::= alias of nand;
    ::MDA::"↑"    ::= alias of nand;

The function C<nand> aka C<not_and> aka C<⊼> aka C<↑> performs a logical
I<alternative denial>; it results in C<False> iff its 2 arguments C<0> and
C<1> are both C<True>, and C<True> otherwise.

=head2 or ∨

    ::MD::or ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity (False)
        : (\.0 ?? True !! \.1);

    ::MDA::"∨" ::= alias of or;

The function C<or> aka C<∨> performs a logical I<disjunction>; it results
in C<True> iff at least one of its 2 arguments C<0> and C<1> is C<True>,
and C<False> otherwise.  Other programming languages may name their
corresponding operators I<|> or I<||> or I<A>.

=head2 nor not_or ⊽ ↓

    ::MD::nor ::= function negates or
        is commutative;

    ::MD::not_or ::= alias of nor;
    ::MDA::"⊽"   ::= alias of nor;
    ::MDA::"↓"   ::= alias of nor;

The function C<nor> aka C<not_or> aka C<⊽> aka C<↓> performs a logical
I<joint denial>; it results in C<False> iff at least one of its 2 arguments
C<0> and C<1> is C<True>, and C<True> otherwise.

=head2 xnor iff ↔

    ::MD::xnor ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative} identity (True)
        : (topic --> \@same);

    ::MD::iff  ::= alias of xnor;
    ::MDA::"↔" ::= alias of xnor;

The function C<xnor> aka C<iff> aka C<↔> performs a logical
I<biconditional> or I<material equivalence> or I<even parity>; it results
in C<True> iff its 2 arguments C<0> and C<1> are exactly the same value,
and C<False> otherwise.  This function is effectively a C<Boolean>-specific
alias of the function C<same> aka C<=>.  Other programming languages may
name their corresponding operators I<E>.

=head2 xor ⊻ ↮

    ::MD::xor ::= function negates xnor
        is {associative,commutative} identity (False);

    ::MDA::"⊻" ::= alias of xor;
    ::MDA::"↮" ::= alias of xor;

The function C<xor> aka C<⊻> aka C<↮> performs a logical I<exclusive
disjunction> or I<odd parity>; it results in C<False> iff its 2 arguments
C<0> and C<1> are exactly the same value, and C<True> otherwise.  This
function is effectively a C<Boolean>-specific alias of the function
C<not_same> aka C<!=> aka C<≠>.  Other programming languages may name their
corresponding operators I<^>.

=head2 imp implies →

    ::MD::imp ::= function --> Boolean <-- (Boolean, Boolean)
        : (\.0 ?? \.1 !! True);

    ::MD::implies ::= alias of imp;
    ::MDA::"→"    ::= alias of imp;

The function C<imp> aka C<implies> aka C<→> performs a logical I<material
implication>; it results in C<False> when its C<0> argument is C<True> and
its C<1> argument is C<False>, and C<True> otherwise.

=head2 nimp not_implies ↛

    ::MD::nimp ::= function negates imp;

    ::MD::not_implies ::= alias of nimp;
    ::MDA::"↛"        ::= alias of nimp;

The function C<nimp> aka C<not_implies> aka C<↛> performs a logical
I<material nonimplication>; it results in C<True> when its C<0> argument is
C<True> and its C<1> argument is C<False>, and C<False> otherwise.

=head2 if ←

    ::MD::if ::= function commutes imp;

    ::MDA::"←" ::= alias of if;

The function C<if> aka C<←> performs a logical I<converse implication> or
I<reverse material implication>; it results in C<False> when its C<0>
argument is C<False> and its C<1> argument is C<True>, and C<True>
otherwise.

=head2 nif not_if ↚

    ::MD::nif ::= function commutes nimp;

    ::MD::not_if ::= alias of nif;
    ::MDA::"↚"   ::= alias of nif;

The function C<nif> aka C<not_if> aka C<↚> performs a logical I<converse
nonimplication>; it results in C<True> when its C<0> argument is C<False>
and its C<1> argument is C<True>, and C<False> otherwise.

=head1 NUMERIC DATA TYPES

=head2 Numeric

    ::MD::Numeric ::= interface
        composes Boolable
        requires_implements {so,opposite,reciprocal,modulus,
            plus,minus,frac_divide,whole_divide,...};

I<TODO.>

=head2 Round_Meth

    ::MD::Round_Meth::"" ::= selection
        union {2::Down,2::Up,2::To_Zero,2::To_Inf
            ,2::Half_Down,2::Half_Up,2::Half_To_Zero,2::Half_To_Inf
            ,2::Half_Even}
        default (2::To_Zero());

    ::MD::Round_Meth::Down         ::= constant (\@0);
    ::MD::Round_Meth::Up           ::= constant (\@0);
    ::MD::Round_Meth::To_Zero      ::= constant (\@0);
    ::MD::Round_Meth::To_Inf       ::= constant (\@0);
    ::MD::Round_Meth::Half_Down    ::= constant (\@0);
    ::MD::Round_Meth::Half_Up      ::= constant (\@0);
    ::MD::Round_Meth::Half_To_Zero ::= constant (\@0);
    ::MD::Round_Meth::Half_To_Inf  ::= constant (\@0);
    ::MD::Round_Meth::Half_Even    ::= constant (\@0);

I<TODO.  Also, review most appropriate values for the constants.>

=head2 so (Numeric)

    ::MD::so::Numeric ::= function virtual --> Boolean <-- (Numeric)
        implements 2::"";

The function C<so::Numeric> ...  This function implements the C<Boolable>
virtual function C<so> aka C<?> for the composing type C<Numeric>.

I<TODO.>

=head2 is_zero

    ::MD::is_zero ::= function negates so::Numeric;

I<TODO.>

=head2 opposite

    ::MD::opposite::"" ::= function virtual --> Numeric <-- (Numeric);

    ::MD::additive_inverse ::= alias of opposite;

I<TODO.>

=head2 reciprocal

    ::MD::reciprocal::"" ::= function virtual --> Numeric <-- (Numeric)
        requires (?\.0);

    ::MD::multiplicative_inverse ::= alias of reciprocal;

I<TODO.>

=head2 modulus abs

    ::MD::modulus::"" ::= function virtual --> Numeric <-- (Numeric);

    ::MD::abs ::= alias of modulus;

I<TODO.>

=head2 plus +

    ::MD::plus::"" ::= function virtual --> Numeric <-- (Numeric, Numeric);

    ::MD::"+" ::= alias of plus;

I<TODO.>

=head2 minus

    ::MD::minus::"" ::= function virtual --> Numeric <-- (Numeric, Numeric);

I<TODO.>

=head2 -

    ::MD::"-" ::= function --> Numeric <-- {(Numeric), (Numeric, Numeric)}
        : (topic --> (degree(topic) = 1 ?? \@opposite !! \@minus));

I<TODO.>

=head2 modulus_minus abs_minus |-|

    ::MD::modulus_minus ::= function --> Numeric <-- (Numeric, Numeric)
        : (modulus topic --> \@minus);

    ::MD::abs_minus ::= alias of modulus_minus;
    ::MD::"|-|"     ::= alias of modulus_minus;

I<TODO.>

=head2 times *

    ::MD::times::"" ::= function virtual --> Numeric <-- (Numeric, Numeric);

    ::MD::"*" ::= alias of times;

I<TODO.>

=head2 frac_divide /

    ::MD::frac_divide::"" ::= function virtual
        --> Numeric <-- (Numeric, Numeric)
        requires (?\.1);

    ::MD::"/" ::= alias of frac_divide;

I<TODO.>

=head2 whole_divide div

    ::MD::whole_divide::"" ::= function virtual
        --> Numeric <-- (Numeric, Numeric, Round_Meth)
        requires (?\.1);

    ::MD::div ::= alias of whole_divide;

I<TODO.>

=head2 modulo mod

    ::MD::modulo::"" ::= function
        --> Numeric <-- (Numeric, Numeric, Round_Meth)
        requires (?\.1)
        : (\.0 - (\.1 * topic --> \@div));

    ::MD::mod ::= alias of modulo;

I<TODO.>

=head2 divide_and_modulo

    ::MD::divide_and_modulo::"" ::= function
        --> (Numeric, Numeric) <-- (Numeric, Numeric, Round_Meth)
        requires (?\.1)
        : (\%(topic --> \@div, topic --> \@mod));

I<TODO.>

=head1 INTEGRAL DATA TYPES

=head2 Integral

    ::MD::Integral ::= interface
        composes {Enumerable, Numeric and_provides_its_default}
        requires_implements {in_order,pred,succ,so,...};

I<TODO.  Also, do something about the unimplemented Numeric operators.>

=head1 INTEGER DATA TYPES

=head2 Integer_Inf Integer Int

    ::MD::Integer_Inf ::= selection where (topic -->^ FDN__isa_Integer_Inf)
        default (0)
        composes Integral and_provides_its_default;

    ::MD::Integer ::= alias of Integer_Inf;
    ::MD::Int     ::= alias of Integer_Inf;

The selection contract C<Integer_Inf> aka C<Integer> aka C<Int> represents
the infinite Muldis D Foundation type I<FDN__Integer_Inf>.  An C<Integer>
value is a general purpose integer exact numeric, which explicitly does not
represent any kind of thing in particular, neither cardinal nor ordinal nor
nominal.  Its default value is C<0>.  C<Integer> is both C<Orderable> and
C<Enumerable>; it has no minimum or maximum value.  Other programming
languages may name their corresponding types I<BigInt>.

I<TODO.  Also, do something about the unimplemented Numeric operators.>

=head2 Integer_NN

    ::MD::Integer_NN ::= selection of Integer where (topic >= 0);

The selection contract C<Integer_NN> represents the infinite type
consisting just of the C<Integer> values that are non-negative.  Its
default and minmum value is C<0>; it has no maximum value.

=head2 Integer_P

    ::MD::Integer_P ::= selection of Integer_NN where (topic > 0) default (1);

The selection contract C<Integer_P> represents the infinite type consisting
just of the C<Integer_NN> values that are positive.  Its default and minmum
value is C<1>; it has no maximum value.

=head2 in_order (Integer)

    ::MD::in_order::Integer ::= function --> Boolean <-- (Integer, Integer)
        implements 2::""
        : (topic -->^ FDN__Integers_in_order);

The function C<in_order::Integer> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Integer>.

=head2 pred (Integer)

    ::MD::pred::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (\.0 - 1);

The function C<pred::Integer> implements the C<Enumerable> virtual
function C<pred> for the composing type C<Integer>.

=head2 succ (Integer)

    ::MD::succ::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (\.0 + 1);

The function C<succ::Integer> implements the C<Enumerable> virtual
function C<succ> for the composing type C<Integer>.

=head2 so (Integer)

    ::MD::so::Integer ::= function --> Boolean <-- (Integer)
        implements 2::""
        : (\.0 != 0);

The function C<so::Integer> ...  This function implements the C<Boolable>
virtual function C<so> aka C<?> for the composing type C<Integer>.

I<TODO.>

=head1 ACCESSIBLE DATA TYPES

=head2 Accessible

    ::MD::Accessible ::= interface
        requires_implements {".",".?",".!"};

I<TODO.  For types that support simple accessor-based lookup of single values;
for one-dimensional collections of pairs that support lookup by one
pair element of the other pair element, and every pair in the
collection has a distinct first element.
Does not have anything to say related to either enumerating elements or
to slicing a subset elements into a new collection.
Accessible just provides certain convenient shared names for operators that
otherwise have distinct names on the composing types.
Composed by: Positional (Array, String,...), Tuple, Dictionary, etc.
(Conceptually also composed by Capsule, but isn't to avoid conflicts.)>

=head2 .

    ::MD::"."::"" ::= function virtual --> Any <-- (Accessible, Any)
        requires (topic --> \@".?");

I<TODO.>

=head2 .?

    ::MD::".?"::"" ::= function virtual --> Boolean <-- (Accessible, Any);

I<TODO.>

=head2 .!

    ::MD::".!"::"" ::= function virtual --> Any <-- (Accessible, Any);

I<TODO.>

=head1 HOMOGENEOUS DATA TYPES

=head2 Homogeneous

    ::MD::Homogeneous::"" ::= interface
        composes Boolable
        requires_implements {so,empty,count,has,nest,unnest,any,where,map,reduce,...};

I<TODO.  For types whose values are conceptually homogeneous collections
of distinct integral-weighted objects, where the weights may or may not be
constrained to 1 (each element can only appear once),
either with a canonical order of elements or with no canonical order.
Composed by: Positional (Array, String, etc), Setty (Set, Relation),
Bag, Tuple_Bag, Dictionary, etc.
Subtypes also composing Positional are ordered, and others are not.
Subtypes also composing Setty ensure elements appear just once, others don't.
(Conceptually more or less all collection types can be thought of as being
collections over 2 dimensions, heterogeneous/Attributive and Homogeneous;
Relation and Tuple_Bag formally are multiples in both dimensions, while the
other types are formally multiples in just one of those dimensions.)>

I<TODO.  Note that for all the regular function-taking element-wise
Homogeneous operators that are logically supposed to work with each
collection member in isolation and/or shouldn't put significance on either
duplicate members or member position in the collection, including the likes
of {any, where, map} etc, but not including the likes of {reduce}, the
operators will only be passing the asset portion (where applicable) of the
member to the higher-order function, and not say the index-asset pair for a
Positional or the asset-count pair for a Baggy.  Note that for a Relation
or Tuple_Bag each entire Tuple is the member asset, and for a Dictionary
the pair is the asset.  (With the corresponding attribute-wise Tuple
operators, they are given the whole attribute name-value pair.)  The main
reason for this is to help ensure consistency of results while supporting a
variety of collection implementations including ones that are lazy, such as
by not eagerly counting duplicates, or that use distributed computation.
For that matter, the likes of {reduce} should probably be treated the same
way; see also the 'repeater' function trait that helps optimize it.
Surely, any time when one may think these operations need to know the
baggy count or positional index, its for a problem best solved differently.>

=head2 so (Homogeneous) has_any_members

    ::MD::so::Homogeneous ::= function virtual --> Boolean <-- (Homogeneous)
        implements 2::"";

    ::MD::has_any_members ::= alias of so::Homogeneous;

The function C<so::Homogeneous> ...  This function implements the C<Boolable>
virtual function C<so> aka C<?> for the composing type C<Homogeneous>.

I<TODO.>

=head2 is_empty ∅?

    ::MD::is_empty ::= function negates so::Homogeneous;

    ::MDA::"∅?" ::= alias of is_empty;

I<TODO.>

=head2 empty ∅

    ::MD::empty::"" ::= function virtual --> Homogeneous <-- (Homogeneous);

    ::MDA::"∅" ::= alias of empty;

I<TODO.  Returns the 'empty' value of the argument's collection type.
For plain {Array,Set,Bag} this is a constant value, but for a Relation or
a Tuple_Bag this is distinct per each heading.>

=head2 count cardinality #

    ::MD::count::"" ::= function virtual --> Integral <-- (Homogeneous);

    ::MD::cardinality ::= alias of count;
    ::MD::"#"         ::= alias of count;

I<TODO.>

=head2 has ∋

    ::MD::has::"" ::= function virtual --> Boolean <-- (Homogeneous, Any);

    ::MDA::"∋" ::= alias of has;

I<TODO.>

=head2 not_has ∌

    ::MD::not_has ::= function negates has;

    ::MDA::"∌" ::= alias of not_has;

I<TODO.>

=head2 in ∈

    ::MD::in ::= function commutes has;

    ::MDA::"∈" ::= alias of in;

I<TODO.>

=head2 not_in ∉

    ::MD::not_in ::= function commutes not_has;

    ::MDA::"∉" ::= alias of not_in;

I<TODO.>

=head2 nest group

    ::MD::nest::"" ::= function virtual --> Homogeneous <-- (Homogeneous)
        requires (...);

    ::MD::group ::= alias of nest;

I<TODO.>

=head2 unnest ungroup

    ::MD::unnest::"" ::= function virtual --> Homogeneous <-- (Homogeneous)
        requires (...);

    ::MD::ungroup ::= alias of unnest;

I<TODO.>

=head2 any there_exists ∃

    ::MD::any::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Primed_Func_Ref);

    ::MD::there_exists ::= alias of any;
    ::MDA::"∃"         ::= alias of any;

I<TODO.  Result is true when at least one member evaluates to true.
This is logically equivalent to testing if a same-topic 'where' result is nonempty,
but 'any' is instead virtual with applicable Foundation-level functions to
aid efficiency with less-savvy optimizers that don't know to short-circuit.>

=head2 none there_does_not_exist ∄

    ::MD::none ::= function negates any;

    ::MD::there_does_not_exist ::= alias of none;
    ::MDA::"∄"                 ::= alias of none;

I<TODO.  Result is true when no member evaluates to true.>

=head2 all for_all ∀

    ::MD::all ::= function --> Boolean <-- (Homogeneous, Primed_Func_Ref)
        : (\.0 none negated_func(of : \.1, passing_args : \@(0)));

    ::MD::for_all ::= alias of all;
    ::MDA::"∀"    ::= alias of all;

I<TODO.  Result is true when no member evaluates to false.>

=head2 all_isa

    ::MD::all_isa ::= function --> Boolean <-- (Homogeneous, Reference)
        : (\.0 all (\@isa assuming topic ^ \@(1)));

I<TODO.>

=head2 where

    ::MD::where::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Primed_Func_Ref);

I<TODO.  The primed-func-ref is expected to be a Capsule with 2 asset attrs
named 'func' and 'args', which are a Reference and a Tuple respectively.
The 'args' can be any Tuple that doesn't have a '0' attr.
The function referenced by 'func' is expected to take a Tuple argument
whose '0' attr is a member of the collection and whose other attrs match
those given in 'args'.>

=head2 filtering

    ::MD::filtering ::= function commutes where;

I<TODO.>

=head2 map

    ::MD::map::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Primed_Func_Ref);

I<TODO.  The primed-func-ref is as per that of 'where'.>

=head2 reduce

    ::MD::reduce::"" ::= function virtual
        --> Any <-- (Homogeneous, Primed_Func_Ref);

I<TODO.  The primed-func-ref is expected to be a Capsule with 2 asset attrs
named 'func' and 'args', which are a Reference and a Tuple respectively.
The 'args' can be any Tuple that doesn't have either '0' or '1' attrs.
The function referenced by 'func' is expected to take a Tuple argument
whose '0' and '1' attrs are members of the collection and whose other attrs match
those given in 'args'.
Depending on the collection subtype, order of 0,1 may or may not be significant.>

=head1 POSITIONAL DATA TYPES

=head2 Positional

    ::MD::Positional ::= interface
        composes {Orderable, Accessible, Homogeneous and_provides_its_default, ...}
        requires_implements {so,empty,count,elem,has_index,has,nest,unnest,any,where,map,reduce,
            first_index,last_index,slice,catenate,index_succ_all_matches,...};

I<TODO.  For types that support integer-index-based lookup of values;
for collections of index-value pairs where all indexes are distinct;
for collections you can enumerate in canonical order;
the collection indexes might not be zero-based in the general case but must be dense.
Composed by: Array, String, Blob, Text, etc.>

=head2 Excuse::No_Such_Index

    ::MD::Excuse::No_Such_Index ::= constant (\@0) composes Excuse;

I<TODO.>

=head2 in_order (Positional)

    ::MD::in_order::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
    : (
        i ::= (topic --> \@index_succ_all_matches);
      <--
        if not \.0 .? i then
            e1 ::= True
        else if not \.1 .? i then
            False
        else
            e2 ::= (\.0.i in_order \.1.i);

        e1 ::?= \~?'This is the case where LHS is a leading subsequence of or is equal to RHS.';
        e2 ::?= \~?'This will succeed iff in_order() is defined for the element type.';
    );

The function C<in_order::Positional> implements the C<Orderable> virtual
function C<in_order> for the composing type C<Positional>.

=head2 elem . (Positional)

    ::MD::elem::"" ::= function virtual --> Any <-- (Positional, Integral)
        requires (topic --> \@has_index);

    ::MD::"."::Positional ::= function --> Any <-- (Positional, Integral)
        implements 2::""
        requires (topic --> \@has_index)
        : (topic --> \@elem);

I<TODO.>

=head2 has_index .? (Positional)

    ::MD::has_index::"" ::= function virtual --> Boolean <-- (Positional, Integral);

    ::MD::".?"::Positional ::= function --> Boolean <-- (Positional, Integral)
        implements 2::""
        : (topic --> \@has_index);

I<TODO.>

=head2 elem_or_excuse .! (Positional)

    ::MD::elem_or_excuse ::= function --> Any <-- (Positional, Integral)
        : (topic --> \@has_index ?? topic --> \@elem !! Excuse::No_Such_Index());

    ::MD::".!"::Positional ::= function --> Any <-- (Positional, Integral)
        implements 2::""
        : (topic --> \@elem_or_excuse);

I<TODO.>

=head2 first_index

    ::MD::first_index::"" ::= function virtual --> Integral <-- (Positional)
        requires (?\.0);

I<TODO.>

=head2 last_index

    ::MD::last_index::"" ::= function virtual --> Integral <-- (Positional)
        requires (?\.0);

I<TODO.>

=head2 slice

    ::MD::slice::"" ::= function virtual
        --> Positional <-- (Positional, Interval);

I<TODO.  Need to clarify constraints, eg is this a strict subsequence
operation or is it more like an intersection.>

=head2 first

    ::MD::first ::= function --> Any <-- (Positional)
        requires (?\.0)
        : (\.0 . first_index(\.0));

I<TODO.>

=head2 nonfirst

    ::MD::nonfirst ::= function --> Positional <-- (Positional)
        requires (?\.0)
        : (\.0 slice first_index(\.0)^..last_index(\.0));

I<TODO.>

=head2 last

    ::MD::last ::= function --> Any <-- (Positional)
        requires (?\.0)
        : (\.0 . last_index(\.0));

I<TODO.>

=head2 nonlast

    ::MD::nonlast ::= function --> Positional <-- (Positional)
        requires (?\.0)
        : (\.0 slice first_index(\.0)..^last_index(\.0));

I<TODO.>

=head2 catenate ~

    ::MD::catenate::"" ::= function virtual
        --> Positional <-- (Positional, Positional)
        is associative;

    ::MD::"~" ::= alias of catenate;

I<TODO.>

=head2 index_succ_all_matches

    ::MD::index_succ_all_matches::"" ::= function virtual
        --> Integral <-- (Positional, Positional)
        is commutative;

I<TODO.>

=head1 ARRAY DATA TYPES

=head2 Array_Inf Array

    ::MD::Array_Inf ::= selection where (topic -->^ FDN__isa_Array_Inf)
        default ([])
        composes Positional and_provides_its_default;

    ::MD::Array ::= alias of Array_Inf;

The selection contract C<Array_Inf> aka C<Array> represents the infinite
Muldis D Foundation type I<FDN__Array_Inf>.  An C<Array> value is ...

I<TODO.>

=head2 ~∅

    ::MDA::"~∅" ::= constant ([]);

The constant C<~∅> represents the only zero-member C<Array> value.

=head2 so (Array)

    ::MD::so::Array ::= function --> Boolean <-- (Array)
        implements 2::""
        : (\.0 != []);

The function C<so::Array> ...  This function implements the C<Boolable>
virtual function C<so> aka C<?> for the composing type C<Array>.

I<TODO.>

=head2 empty (Array)

    ::MD::empty::Array ::= function --> Array <-- (Array)
        implements 2::""
        : ([]);

I<TODO.>

=head2 count (Array)

    ::MD::count::Array ::= function --> Integer_NN <-- (Array)
        implements 2::""
        : (topic -->^ FDN__Array_count);

I<TODO.>

=head2 elem (Array)

    ::MD::elem::Array ::= function --> Any <-- (Array, Integer_NN)
        implements 2::""
        requires (topic --> \@has_index)
        : (topic -->^ FDN__Array_elem);

I<TODO.>

=head2 has_index (Array)

    ::MD::has_index::Array ::= function --> Boolean <-- (Array, Integer_NN)
        implements 2::""
        : (topic -->^ FDN__Array_has_index);

I<TODO.  True if given array index exists.>

=head2 has (Array)

    ::MD::has::Array ::= function --> Boolean <-- (Array, Any)
        implements 2::""
        : (topic -->^ FDN__Array_has);

I<TODO.  True if given element value exists at any index.>

=head2 nest (Array)

    ::MD::nest::Array ::= function --> Array <-- (Array)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Array_nest);

I<TODO.>

=head2 unnest (Array)

    ::MD::unnest::Array ::= function --> Array <-- (Array)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Array_unnest);

I<TODO.>

=head2 any (Array)

    ::MD::any::Array ::= function --> Boolean <-- (Array, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Array_any);

I<TODO.>

=head2 where (Array)

    ::MD::where::Array ::= function --> Array <-- (Array, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Array_where);

I<TODO.>

=head2 map (Array)

    ::MD::map::Array ::= function --> Array <-- (Array, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Array_map);

I<TODO.>

=head2 reduce (Array)

    ::MD::reduce::Array ::= function --> Any <-- (Array, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Array_reduce);

I<TODO.>

=head2 first_index

    ::MD::first_index::Array ::= function --> Integer_NN <-- (Array)
        implements 2::""
        requires (?\.0)
        : (0);

I<TODO.>

=head2 last_index

    ::MD::last_index::Array ::= function --> Integer_NN <-- (Array)
        implements 2::""
        requires (?\.0)
        : (-- #\.0);

I<TODO.>

=head2 slice

    ::MD::slice::Array ::= function --> Array <-- (Array, Interval)
        implements 2::""
        : (topic -->^ FDN__Array_slice);

I<TODO.>

=head2 catenate (Array)

    ::MD::catenate::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        is associative identity ([])
        : (topic -->^ FDN__Array_catenate);

I<TODO.>

=head2 index_succ_all_matches (Array)

    ::MD::index_succ_all_matches::Array ::= function
        --> Integer_NN <-- (Array, Array)
        implements 2::""
        is commutative
        : (topic -->^ FDN__Array_index_succ_all_matches);

I<TODO.  While conceivably implementable at a higher level, make low level
for perceived efficiency.>

=head1 SETTY DATA TYPES

=head2 Setty

    ::MD::Setty ::= interface
        composes Homogeneous
        requires_implements {so,empty,count,has,nest,unnest,any,where,map,reduce,...};

I<TODO.  For collections that make sure each element can only appear once.
Composed by: Set, Relation.>

=head1 SET DATA TYPES

=head2 Set_Inf Set

    ::MD::Set_Inf ::= binder
    {
        "" ::= selection of Capsule
            where (Capsule_has_tag_asset( topic, \Set, \@1::_Asset ))
            default ({})
            composes Setty and_provides_its_default;

        _Asset ::= selection of Bag
            where (...);
    };

    ::MD::Set ::= alias of Set_Inf;

I<TODO. Update 'where' to say quantity for each distinct member is 1,
using a Foundation function specific to that purpose.>

=head2 ?∅

    ::MDA::"?∅" ::= constant ({});

The constant C<?∅> represents the only zero-member C<Set> value.

=head2 so (Set)

    ::MD::so::Set ::= function --> Boolean <-- (Set)
        implements 2::""
        : (\.0 != {});

The function C<so::Set> ...  This function implements the C<Boolable>
virtual function C<so> aka C<?> for the composing type C<Set>.

I<TODO.>

=head2 empty (Set)

    ::MD::empty::Set ::= function --> Set <-- (Set)
        implements 2::""
        : ({});

I<TODO.>

=head2 count (Set)

    ::MD::count::Set ::= function --> Integer_NN <-- (Set)
        implements 2::""
        : (Capsule_asset(\.0) ->count);

I<TODO.>

=head2 has (Set)

    ::MD::has::Set ::= function --> Boolean <-- (Set, Any)
        implements 2::""
        : (Capsule_asset(\.0) has \.1);

I<TODO.>

=head2 nest (Set)

    ::MD::nest::Set ::= function --> Set <-- (Set)
        implements 2::""
        requires (...)
        : (select_Capsule(\Set, Capsule_asset(\.0) ->nest));

I<TODO.>

=head2 unnest (Set)

    ::MD::unnest::Set ::= function --> Set <-- (Set)
        implements 2::""
        requires (...)
        : (select_Capsule(\Set, Capsule_asset(\.0) ->unnest));

I<TODO.>

=head2 any (Set)

    ::MD::any::Set ::= function --> Boolean <-- (Set, Primed_Func_Ref)
        implements 2::""
        : (Capsule_asset(\.0) any \.1);

I<TODO.>

=head2 where (Set)

    ::MD::where::Set ::= function --> Set <-- (Set, Primed_Func_Ref)
        implements 2::""
        : (select_Capsule(\Set, Capsule_asset(\.0) where \.1));

I<TODO.>

=head2 map (Set)

    ::MD::map::Set ::= function --> Set <-- (Set, Primed_Func_Ref)
        implements 2::""
        : (select_Capsule(\Set, Capsule_asset(\.0) map \.1));

I<TODO.>

=head2 reduce (Set)

    ::MD::reduce::Set ::= function --> Any <-- (Set, Primed_Func_Ref)
        implements 2::""
        : (select_Capsule(\Set, Capsule_asset(\.0) reduce \.1));

I<TODO.>

=head1 BAG DATA TYPES

=head2 Bag_Inf Bag

    ::MD::Bag_Inf ::= selection where (topic -->^ FDN__isa_Bag_Inf)
        default (\+{})
        composes Homogeneous;

    ::MD::Bag ::= alias of Bag_Inf;

The selection contract C<Bag_Inf> aka C<Bag> represents the infinite Muldis
D Foundation type I<FDN__Bag_Inf>.  A C<Bag> value is ...

I<TODO.>

=head2 +∅

    ::MDA::"+∅" ::= constant (\+{});

The constant C<+∅> represents the only zero-member C<Bag> value.

=head2 so (Bag)

    ::MD::so::Bag ::= function --> Boolean <-- (Bag)
        implements 2::""
        : (\.0 != \+{});

The function C<so::Bag> ...  This function implements the C<Boolable>
virtual function C<so> aka C<?> for the composing type C<Bag>.

I<TODO.>

=head2 empty (Bag)

    ::MD::empty::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        : (\+{});

I<TODO.>

=head2 count (Bag)

    ::MD::count::Bag ::= function --> Integer_NN <-- (Bag)
        implements 2::""
        : (topic -->^ FDN__Bag_count);

I<TODO.>

=head2 has (Bag)

    ::MD::has::Bag ::= function --> Boolean <-- (Bag, Any)
        implements 2::""
        : (topic -->^ FDN__Bag_has);

I<TODO.>

=head2 nest (Bag)

    ::MD::nest::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Bag_nest);

I<TODO.>

=head2 unnest (Bag)

    ::MD::unnest::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Bag_unnest);

I<TODO.>

=head2 any (Bag)

    ::MD::any::Bag ::= function --> Boolean <-- (Bag, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Bag_any);

I<TODO.>

=head2 where (Bag)

    ::MD::where::Bag ::= function --> Bag <-- (Bag, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Bag_where);

I<TODO.>

=head2 map (Bag)

    ::MD::map::Bag ::= function --> Bag <-- (Bag, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Bag_map);

I<TODO.>

=head2 reduce (Bag)

    ::MD::reduce::Bag ::= function --> Any <-- (Bag, Primed_Func_Ref)
        implements 2::""
        : (topic -->^ FDN__Bag_reduce);

I<TODO.>

=head1 ATTRIBUTIVE DATA TYPES

=head2 Attributive

    ::MD::Attributive ::= interface
        requires_implements {has_any_attrs,degree,on,but,extend,rename,has_attrs,has_just_attrs};

I<TODO.  For types that support attribute-name-based lookup of values;
for collections of name-value pairs where all names are distinct;
for typically heterogeneous collections.
Composed by: Tuple, Relation, Tuple_Bag.>

=head2 Excuse::No_Such_Attr

    ::MD::Excuse::No_Such_Attr ::= constant (\@0) composes Excuse;

I<TODO.>

=head2 has_any_attrs ?^

    ::MD::has_any_attrs::"" ::= function virtual --> Boolean <-- (Attributive);

    ::MD::"?^" ::= alias of has_any_attrs;

I<TODO.>

=head2 is_nullary !?^

    ::MD::is_nullary ::= function negates has_any_attrs;

    ::MD::"!?^" ::= alias of is_nullary;

I<TODO.>

=head2 degree #^

    ::MD::degree::"" ::= function virtual --> Integral <-- (Attributive);

    ::MD::"#^" ::= alias of degree;

I<TODO.>

=head2 on ^ project

    ::MD::on::"" ::= function virtual
        --> Attributive <-- (Attributive, Attr_Names)
        requires (...);

    ::MD::"^"     ::= alias of on;
    ::MD::project ::= alias of on;

I<TODO.  Also, this is analogous to set intersect.>

=head2 from

    ::MD::from ::= function commutes on;

I<TODO.>

=head2 but -^ project_all_but

    ::MD::but::"" ::= function virtual
        --> Attributive <-- (Attributive, Attr_Names)
        requires (...);

    ::MD::"-^"            ::= alias of but;
    ::MD::project_all_but ::= alias of but;

I<TODO.  Also, this is analogous to set difference.>

=head2 extend +^

    ::MD::extend::"" ::= function virtual
        --> Attributive <-- (Attributive, Attributive)
        requires (topic --> \@atnms_disjoint)
        is {associative,commutative};

    ::MD::"+^" ::= alias of extend;

I<TODO.  Also, this is analogous to set union (disjoint).>

I<Note: There is no version of 'extend' that takes a routine; one can just
use the above version plus an eg-tuple selector. In the case of relation
extend, one can do the aforementioned within a 'map' routine, for the
routine version; they can use join/cross-product for the static version.>

=head2 rename

    ::MD::rename::"" ::= function virtual
        --> Attributive <-- (Attributive, Attr_Renaming)
        requires (...);

I<TODO.>

=head2 renaming

    ::MD::renaming ::= function commutes rename;

I<TODO.>

=head2 atnms_disjoint

    ::MD::atnms_disjoint ::= function
        --> Boolean <-- (Attributive, Attributive)
        is commutative
        : (...);

I<TODO.>

=head2 has_attrs ^?

    ::MD::has_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, Signature);

    ::MD::"^?" ::= alias of has_attrs;

I<TODO.>

=head2 has_just_attrs ^?=

    ::MD::has_just_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, Signature);

    ::MD::"^?=" ::= alias of has_just_attrs;

I<TODO.>

=head1 TUPLE DATA TYPES

=head2 Tuple_Inf Tuple

    ::MD::Tuple_Inf ::= selection where (topic -->^ FDN__isa_Tuple_Inf)
        default (\%())
        composes {Accessible and_provides_its_default,
            Attributive and_provides_its_default};

    ::MD::Tuple ::= alias of Tuple_Inf;

The selection contract C<Tuple_Inf> aka C<Tuple> represents the infinite
Muldis D Foundation type I<FDN__Tuple_Inf>.  A C<Tuple> value is ...

I<TODO.>

=head2 Tuple_D0 D0

    ::MD::Tuple_D0 ::= constant (\%());

    ::MD::D0 ::= alias of Tuple_D0;

The constant C<Tuple_D0> aka C<D0> represents the only zero-attribute
C<Tuple> value.

=head2 has_any_attrs (Tuple)

    ::MD::has_any_attrs::Tuple ::= function --> Boolean <-- (Tuple)
        implements 2::""
        : (\.0 != \%());

I<TODO.>

=head2 degree (Tuple)

    ::MD::degree::Tuple ::= function --> Integer_NN <-- (Tuple)
        implements 2::""
        : (topic -->^ FDN__Tuple_degree);

I<TODO.>

=head2 attr . (Tuple)

    ::MD::attr ::= function --> Any <-- (Tuple, Attr_Name)
        requires (topic --> \@has_attr)
        : (topic -->^ FDN__Tuple_attr);

    ::MD::"."::Tuple ::= function --> Any <-- (Tuple, Attr_Name)
        implements 2::""
        requires (topic --> \@has_attr)
        : (topic --> \@attr);

I<TODO.>

=head2 has_attr .? (Tuple)

    ::MD::has_attr ::= function --> Boolean <-- (Tuple, Attr_Name)
        : (topic -->^ FDN__Tuple_has_attr);

    ::MD::".?"::Tuple ::= function --> Boolean <-- (Tuple, Attr_Name)
        implements 2::""
        : (topic --> \@has_attr);

I<TODO.>

=head2 attr_or_excuse .! (Tuple)

    ::MD::attr_or_excuse ::= function --> Any <-- (Tuple, Attr_Name)
        : (topic --> \@has_attr ?? topic --> \@attr !! Excuse::No_Such_Attr());

    ::MD::".!"::Tuple ::= function --> Any <-- (Tuple, Attr_Name)
        implements 2::""
        : (topic --> \@attr_or_excuse);

I<TODO.>

=head2 on (Tuple)

    ::MD::on::Tuple ::= function --> Tuple <-- (Tuple, Attr_Names)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Tuple_on);

I<TODO.>

=head2 but (Tuple)

    ::MD::but::Tuple ::= function --> Tuple <-- (Tuple, Attr_Names)
        implements 2::""
        requires (...)
        : (topic -->^ FDN__Tuple_but);

I<TODO.>

=head2 extend (Tuple)

    ::MD::extend::Tuple ::= function --> Tuple <-- (Tuple, Tuple)
        implements 2::""
        requires (topic --> \@atnms_disjoint)
        is {associative,commutative} identity (\%())
        : (topic -->^ FDN__Tuple_extend);

I<TODO.>

=head2 rename (Tuple)

    ::MD::rename::Tuple ::= function --> Tuple <-- (Tuple, Attr_Renaming)
        implements 2::""
        requires (...)
        : (...);

I<TODO.>

=head2 has_attrs (Tuple)

    ::MD::has_attrs::Tuple ::= function --> Boolean <-- (Tuple, Signature)
        implements 2::""
        : (...);

I<TODO.>

=head2 has_just_attrs (Tuple)

    ::MD::has_just_attrs::Tuple ::= function --> Boolean <-- (Tuple, Signature)
        implements 2::""
        : (...);

I<TODO.>

=head2 any_attrs

    ::MD::any_attrs ::= function --> Boolean <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_any_attrs);

I<TODO.>

=head2 none_of_attrs

    ::MD::none_of_attrs ::= function negates any_attrs;

I<TODO.>

=head2 all_attrs

    ::MD::all_attrs ::= function --> Boolean <-- (Tuple, Primed_Func_Ref)
        : (\.0 none_of_attrs negated_func(of : \.1, passing_args : \@(0)));

I<TODO.>

=head2 attrs_where

    ::MD::attrs_where ::= function --> Tuple <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_attrs_where);

I<TODO.>

=head2 attrs_map

    ::MD::attrs_map ::= function --> Tuple <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_attrs_map);

I<TODO.>

=head2 attrs_reduce

    ::MD::attrs_reduce ::= function --> Any <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_attrs_reduce);

I<TODO.>

=head1 RELATION DATA TYPES

=head2 Relation_Inf Relation

    ::MD::Relation_Inf ::= binder
    {
        "" ::= selection of Capsule
            where (Capsule_has_tag_asset( topic, \Relation, \@1::_Asset ))
            default (\?%())
            composes {Setty, Attributive};

        _Asset ::= selection of Tuple_Bag
            where (...);
    };

    ::MD::Relation ::= alias of Relation_Inf;

I<TODO.  See also definition of Set in terms of Bag, which Relation mirrors.>

=head2 Relation_D0C0 D0C0

    ::MD::Relation_D0C0 ::= constant (\+%());

    ::MD::D0C0 ::= alias of Relation_D0C0;

The constant C<Relation_D0C0> aka C<D0C0> represents the only
zero-attribute, zero-tuple C<Relation> value.  Note that I<The Third
Manifesto> also refers to this value by the special name I<TABLE_DUM>.

=head2 Relation_D0C1 D0C1

    ::MD::Relation_D0C1 ::= constant (\+%{()});

    ::MD::D0C1 ::= alias of Relation_D0C1;

The constant C<Relation_D0C1> aka C<D0C1> represents the only
zero-attribute, single-tuple C<Relation> value.  Note that I<The Third
Manifesto> also refers to this value by the special name I<TABLE_DEE>.

=head1 TUPLE-BAG DATA TYPES

=head2 Tuple_Bag_Inf Tuple_Bag

    ::MD::Tuple_Bag_Inf ::= binder
    {
        "" ::= selection of Capsule
            where (Capsule_has_tag_asset( topic, \Tuple_Bag, \@1::_Asset ))
            default (\+%())
            composes {Homogeneous, Attributive};

        _Asset ::= selection of Tuple where
        (
            if topic ^?= \%( heading : \@Attr_Names, body : \@Bag ) then
                if \.body all_isa \@Tuple then
                    \.body all (\@"^?=" assuming \.heading)
                else
                    False
            else
                False
        );
    };

    ::MD::Tuple_Bag ::= alias of Tuple_Bag_Inf;

I<TODO.>

=head2 Tuple_Bag_D0C0

    ::MD::Tuple_Bag_D0C0 ::= constant (\+%());

The constant C<Tuple_Bag_D0C0> represents the only zero-attribute,
zero-tuple C<Tuple_Bag> value.

=head2 Tuple_Bag_D0C1

    ::MD::Tuple_Bag_D0C1 ::= constant (\+%{()});

The constant C<Tuple_Bag_D0C1> represents the only zero-attribute,
single-tuple C<Tuple_Bag> value.

=head1 CAPSULE DATA TYPES

=head2 Capsule

    ::MD::Capsule::"" ::= selection where (topic -->^ FDN__isa_Capsule)
        default (select_Capsule(False, False));

The selection contract C<Capsule> represents the infinite Muldis D
Foundation type I<FDN__Capsule>.  An C<Capsule> value is ...

I<TODO.  We will want a literal syntax for Capsule values, and probably
more tersely named tag/asset operator names.>

Given that almost every selection contract is a subset of
C<Capsule>, the latter intentionally does not compose any interface
contracts, and only has the minimal set of its own operators, so to
minimize interference with other types' interfaces.

=head2 select_Capsule

    ::MD::select_Capsule ::= function --> Capsule <-- (Any, Any)
        : (topic -->^ FDN__Capsule_select);

I<TODO.>

=head2 Capsule_tag

    ::MD::Capsule_tag ::= function --> Any <-- (Capsule)
        : (topic -->^ FDN__Capsule_tag);

I<TODO.>

=head2 Capsule_asset

    ::MD::Capsule_asset ::= function --> Any <-- (Capsule)
        : (topic -->^ FDN__Capsule_asset);

I<TODO.>

=head2 Capsule_has_tag_asset

    ::MD::Capsule_has_tag_asset ::= function
        --> Boolean <-- (Capsule, Any, Reference)
        : (Capsule_tag(\.0) = \.1 and Capsule_asset(\.0) --> \.2);

I<TODO.>

=head1 EXTERNAL DATA TYPES

=head2 External

    ::MD::External ::= selection where (topic -->^ FDN__isa_External)
        default (-->^ FDN__default_External);

The selection contract C<External> represents the infinite Muldis D
Foundation type I<FDN__External>.  An C<External> value is ...

I<TODO.>

=head1 SOURCE CODE BEHAVIOURAL DATA TYPES

I<TODO.>

=head2 Source_Code::Package_List

    ::MD::Source_Code::Package_List ::= selection of Array
        where (topic all_isa (selection of {Package, Decoration} default Package()));

I<TODO.>

=head2 Source_Code::Package

    ::MD::Source_Code::Package ::= binder
    {
        "" ::= selection of Capsule
            where (Capsule_has_tag_asset( topic, \Package, \@1::_Asset ))
            default (select_Capsule( \Package, 1::_Asset() ));

        _Asset ::= selection of Tuple where
        (
            if
                topic ^?= \%(
                    identity : (selection of Pkg_Decl_Map where (degree(topic) = 1)),
                    uses : \@Pkg_Decl_Map,
                    materials : \@Materials,
                )
            then
                topic.\uses atnms_disjoint topic.\identity
            else
                False
        );
    };

I<TODO.>

=head2 Source_Code::Pkg_Decl_Map

    ::MD::Source_Code::Pkg_Decl_Map ::= selection of Tuple
        where (topic all_attrs (function : (\.asset --> \@Pkg_Canon_Name)));

I<TODO.>

=head2 Source_Code::negated_func

    ::MD::Source_Code::negated_func ::= function --> Primed_Func_Ref
        <-- (of : Primed_Func_Ref, passing_args : Attr_Names)
    : (
        (function : (
            not(
                (\.of.\args +^ (topic ^ \.passing_args)) --> (\.of.\func)
            )
        )) assuming topic
    );

I<TODO.  This expects the original function is from Tuple to Boolean.>

=head1 SOURCE CODE ANNOTATION DATA TYPES

I<TODO.>

=head2 Source_Code::Annotation

    ::MD::Source_Code::Annotation::"" ::= interface;

I<TODO.>

=head2 Source_Code::Annotation::Comment

    ::MD::Source_Code::Annotation::Comment ::= selection of Capsule
        where (Capsule_has_tag_asset( topic, \Comment, \@Text ))
        default (\~?'')
        composes Annotation;

I<TODO.>

=head1 SOURCE CODE DECORATION DATA TYPES

I<TODO.  Generally speaking, all Decoraction types are declared by a
package that is not Muldis_D, such as in the Muldis_D::Plain_Text package.>

I<TODO:  The decoration data types may loosely resemble template defs so
that decorations don't necessarily have to be attached to all
behavioral/annotation nodes they are conceptually adjacent / apply to but
rather can be in some nearby parent context and refer to behavioral/etc
nodes by name.>

=head2 Source_Code::Decoration

    ::MD::Source_Code::Decoration::"" ::= interface;

I<TODO.>

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::See_Also> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright © 2002-2015, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
