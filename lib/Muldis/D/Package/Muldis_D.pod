=pod

=encoding utf8

=head1 NAME

Muldis::D::Package::Muldis_D -
Muldis D core data types and operators

=head1 VERSION

This document is Muldis::D::Package::Muldis_D version 0.200.1.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document
before you read this one, which provides subservient details.

=head1 SYNOPSIS

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script ASCII;
    package
    {
        identity My_App ::= My_App:"http://mycorp.com":"0";
        uses
        {
            MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        };
        materials
        {
            floating {::My_App, ::MD};

            `TODO: Put example routines etc here.`

        };
    };

=head1 DESCRIPTION

This document defines the Muldis D Plain Text package
C<Muldis_D:"http://muldis.com":"0.200.1"> which provides the common core
system-defined data types and operators that regular users of the language
would employ directly in their applications and schemas.

This document I<also> defines the Muldis D Plain Text package
C<Muldis_D::Synonyms:"http://muldis.com":"0.200.1"> which adds trans-ASCII
Unicode synonyms to C<Muldis_D> package entities.

=head1 PACKAGES

From one source:

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script ASCII;
    package
    {
        identity MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        materials
        {
            floating {::MD, ::MD::Source_Code};
            ...
        };
    };

From a separate source:

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script Unicode:8.0:UTF-8:canon;
    package
    {
        identity MDS ::= Muldis_D::Synonyms:"http://muldis.com":"0.200.1";
        uses
        {
            MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        };
        materials
        {
            floating {::MD, ::MDS};
            ...
        };
    };

=head1 MAXIMAL AND MINIMAL DATA TYPES

=head2 Anything Any

    ::MD::Anything ::= type default False;

    ::MD::Any ::= synonym of Anything;

The selection contract C<Anything> represents the infinite I<universal
type>, which is the maximal data type of the entire Muldis D type system
and consists of all values which can possibly exist.  It also represents
the infinite Muldis D Foundation type I<FDN__Anything>.  Its default value
is C<False>.  Other programming languages may name their corresponding
types I<Any> or I<Object> or I<Anything>.

=head2 Nothing

    ::MD::Nothing ::= type of {};

The selection contract C<Nothing> represents the finite I<empty type>,
which is the minimal data type of the entire Muldis D type system and
consists of exactly zero values.  It can not have any default value.

=head2 same =

    ::MD::same ::= function --> Boolean <-- (Any, Any)
        is commutative
        : (topic -->^ FDN__same);

    ::MD::"=" ::= synonym of same;

The function C<same> results in C<True> iff its 2 conceptual arguments are
exactly the same value, and C<False> otherwise.  Other programming
languages may name their corresponding operators I<==> or I<===>.

=head2 not_same != ≠

    ::MD::not_same ::= function --> Boolean <-- (Any, Any)
        is commutative
        : (topic --> \@same ?? False !! True);

    ::MD::"!=" ::= synonym of not_same;
    ::MDS::"≠" ::= synonym of not_same;

The function C<not_same> results in C<False> iff its 2 conceptual arguments
are exactly the same value, and C<True> otherwise.

=head1 ORDERABLE DATA TYPES

=head2 Orderable

    ::MD::Orderable ::= type abstract
        requires_implements in_order;

I<TODO.>

=head2 in_order

    ::MD::in_order::"" ::= function virtual
        --> Boolean <-- (Orderable, Orderable);

I<TODO.>

=head2 before <

    ::MD::before ::= function --> Boolean <-- (Orderable, Orderable)
        : (topic --> \@in_order and topic --> \@"!=");

    ::MD::"<" ::= synonym of before;

I<TODO.>

=head2 after >

    ::MD::after ::= function --> Boolean <-- (Orderable, Orderable)
        : (not topic --> \@in_order);

    ::MD::">" ::= synonym of after;

I<TODO.>

=head2 before_or_same <= ≤

    ::MD::before_or_same ::= function --> Boolean <-- (Orderable, Orderable)
        : (topic --> \@in_order);

    ::MD::"<=" ::= synonym of before_or_same;
    ::MDS::"≤" ::= synonym of before_or_same;

I<TODO.>

=head2 after_or_same >= ≥

    ::MD::after_or_same ::= function --> Boolean <-- (Orderable, Orderable)
        : (not topic --> \@in_order or topic --> \@"=");

    ::MD::">=" ::= synonym of after_or_same;
    ::MDS::"≥" ::= synonym of after_or_same;

I<TODO.>

=head2 min

    ::MD::min ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity \(\"+Inf")
        : (topic --> \@in_order ?? \\0 !! \\1);

I<TODO.>

=head2 max

    ::MD::max ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity \(\"-Inf")
        : (topic --> \@in_order ?? \\1 !! \\0);

I<TODO.>

=head2 minmax

    ::MD::minmax ::= function
        --> (Orderable, Orderable) <-- (Orderable, Orderable)
        is commutative
        : (topic --> \@in_order ?? topic !! \(\\1, \\0));

I<TODO.>

=head1 ENUMERABLE DATA TYPES

=head2 Enumerable

    ::MD::Enumerable ::= type abstract
        composes Orderable and_provides_its_default
        requires_implements {in_order,pred,succ};

I<TODO.>

=head2 pred

    ::MD::pred::"" ::= function virtual --> Enumerable <-- (Enumerable);

I<TODO.>

=head2 succ

    ::MD::succ::"" ::= function virtual --> Enumerable <-- (Enumerable);

I<TODO.>

=head1 BOOLABLE DATA TYPES

=head2 Boolable

    ::MD::Boolable ::= type abstract requires_implements so;

I<TODO.>

=head2 so ?

    ::MD::so::"" ::= function virtual --> Boolean <-- (Boolable);

    ::MD::"?" ::= synonym of so;

I<TODO.>

=head1 BOOLEAN DATA TYPES

=head2 Boolean Bool

    ::MD::Boolean::"" ::= type where topic -->^ FDN__isa_Boolean
        default False
        composes {Enumerable and_provides_its_default,
            Boolable and_provides_its_default};

    ::MD::Bool ::= synonym of Boolean;

The selection contract C<Boolean> represents the finite Muldis D
Foundation type I<FDN__Boolean>.  A C<Boolean> value is a general purpose
2-valued logic boolean, or specifically it is one of the 2 values C<False>
and C<True>.  Its default value is C<False>.

I<TODO.>

Examples:

    True

    False

=head2 in_order (Boolean)

    ::MD::in_order::Boolean ::= function --> Boolean <-- (Boolean, Boolean)
        implements 1::""
        : (!\\0 or \\1);

I<TODO.>

=head2 pred (Boolean)

    ::MD::pred::Boolean ::= function
        --> type union {False,"-Inf"} <-- (Boolean)
        implements 1::""
        : (\\0 ?? False !! \(\"-Inf"));

I<TODO.>

=head2 succ (Boolean)

    ::MD::succ::Boolean ::= function
        --> type union {True,"+Inf"} <-- (Boolean)
        implements 1::""
        : (!\\0 ?? True !! \(\"+Inf"));

I<TODO.>

=head2 False ⊥

    ::MD::False ::= constant False;

    ::MDS::"⊥" ::= synonym of False;

I<TODO.>

=head2 True ⊤

    ::MD::True ::= constant True;

    ::MDS::"⊤" ::= synonym of True;

I<TODO.>

=head2 so (Boolean)

    ::MD::so::Boolean ::= function --> Boolean <-- (Boolean)
        implements 1::""
        : \\0;

I<TODO.>

=head2 not ! ¬

    ::MD::not ::= function --> Boolean <-- (Boolean)
        : (\\0 ?? False !! True);

    ::MD::"!"  ::= synonym of not;
    ::MDS::"¬" ::= synonym of not;

I<TODO.>

=head2 and all every ∧

    ::MD::and ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity True
        : (\\0 ?? \\1 !! False);

    ::MD::all   ::= synonym of and;
    ::MD::every ::= synonym of and;
    ::MDS::"∧"  ::= synonym of and;

I<TODO.>

=head2 nand not_and ⊼ ↑

    ::MD::nand ::= function --> Boolean <-- (Boolean, Boolean)
        is commutative
        : (not topic --> \@and);

    ::MD::not_and ::= synonym of nand;
    ::MDS::"⊼"    ::= synonym of nand;
    ::MDS::"↑"    ::= synonym of nand;

I<TODO.>

=head2 or any some ∨

    ::MD::or ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity False
        : (\\0 ?? True !! \\1);

    ::MD::any  ::= synonym of or;
    ::MD::some ::= synonym of or;
    ::MDS::"∨" ::= synonym of or;

I<TODO.>

=head2 nor not_or ⊽ ↓

    ::MD::nor ::= function --> Boolean <-- (Boolean, Boolean)
        is commutative
        : (not topic --> \@or);

    ::MD::not_or ::= synonym of nor;
    ::MDS::"⊽"   ::= synonym of nor;
    ::MDS::"↓"   ::= synonym of nor;

I<TODO.>

=head2 xnor iff ↔

    ::MD::xnor ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative} identity True
        : (topic --> \@"=");

    ::MD::iff  ::= synonym of xnor;
    ::MDS::"↔" ::= synonym of xnor;

I<TODO.>

=head2 xor ⊻ ↮

    ::MD::xor ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative} identity False
        : (topic --> \@"!=");

    ::MDS::"⊻" ::= synonym of xor;
    ::MDS::"↮" ::= synonym of xor;

I<TODO.>

=head2 imp implies →

    ::MD::imp ::= function --> Boolean <-- (Boolean, Boolean)
        : (\\0 ?? \\1 !! True);

    ::MD::implies ::= synonym of imp;
    ::MDS::"→"    ::= synonym of imp;

I<TODO.>

=head2 nimp not_implies ↛

    ::MD::nimp ::= function --> Boolean <-- (Boolean, Boolean)
        : (not topic --> \@imp);

    ::MD::not_implies ::= synonym of nimp;
    ::MDS::"↛"        ::= synonym of nimp;

I<TODO.>

=head2 if ←

    ::MD::if ::= function --> Boolean <-- (Boolean, Boolean)
        : (\\1 imp \\0);

    ::MDS::"←" ::= synonym of if;

I<TODO.>

=head2 nif not_if ↚

    ::MD::nif ::= function --> Boolean <-- (Boolean, Boolean)
        : (\\1 nimp \\0);

    ::MD::not_if ::= synonym of nif;
    ::MDS::"↚"   ::= synonym of nif;

I<TODO.>

=head1 NUMERIC DATA TYPES

=head2 Numeric

    ::MD::Numeric ::= type abstract
        requires_implements {is_zero,opposite,reciprocal,modulus,
            plus,minus,frac_divide,whole_divide,...};

I<TODO.>

=head2 Round_Meth

    ::MD::Round_Meth::"" ::= type
        union {1::Down,1::Up,1::To_Zero,1::To_Inf
            ,1::Half_Down,1::Half_Up,1::Half_To_Zero,1::Half_To_Inf
            ,1::Half_Even}
        default 1::To_Zero();

    ::MD::Round_Meth::Down         ::= constant \Round_Down;
    ::MD::Round_Meth::Up           ::= constant \Round_Up;
    ::MD::Round_Meth::To_Zero      ::= constant \Round_To_Zero;
    ::MD::Round_Meth::To_Inf       ::= constant \Round_To_Inf;
    ::MD::Round_Meth::Half_Down    ::= constant \Round_Half_Down;
    ::MD::Round_Meth::Half_Up      ::= constant \Round_Half_Up;
    ::MD::Round_Meth::Half_To_Zero ::= constant \Round_Half_To_Zero;
    ::MD::Round_Meth::Half_To_Inf  ::= constant \Round_Half_To_Inf;
    ::MD::Round_Meth::Half_Even    ::= constant \Round_Half_Even;

I<TODO.  Also, review most appropriate values for the constants.>

=head2 is_zero

    ::MD::is_zero::"" ::= function virtual --> Boolean <-- (Numeric);

I<TODO.>

=head2 opposite

    ::MD::opposite::"" ::= function virtual --> Numeric <-- (Numeric);

    ::MD::additive_inverse ::= synonym of opposite;

I<TODO.>

=head2 reciprocal

    ::MD::reciprocal::"" ::= function virtual --> Numeric <-- (Numeric)
        requires (\\0->is_zero->not);

    ::MD::multiplicative_inverse ::= synonym of reciprocal;

I<TODO.>

=head2 modulus abs

    ::MD::modulus::"" ::= function virtual --> Numeric <-- (Numeric);

    ::MD::abs ::= synonym of modulus;

I<TODO.>

=head2 plus +

    ::MD::plus::"" ::= function virtual --> Numeric <-- (Numeric, Numeric);

    ::MD::"+" ::= synonym of plus;

I<TODO.>

=head2 minus

    ::MD::minus::"" ::= function virtual --> Numeric <-- (Numeric, Numeric);

I<TODO.>

=head2 -

    ::MD::"-"::"" ::= function --> Numeric
        <-- type of SC_Signature
            where (topic ^>?= \(\@Numeric)
                or topic ^>?= \(\@Numeric, \@Numeric))
        : (topic --> (##>topic = 1 ?? \@opposite !! \@minus));

I<TODO.>

=head2 modulus_minus abs_minus |-|

    ::MD::modulus_minus ::= function --> Numeric <-- (Numeric, Numeric)
        : (modulus topic --> \@minus);

    ::MD::abs_minus ::= synonym of modulus_minus;
    ::MD::"|-|"     ::= synonym of modulus_minus;

I<TODO.>

=head2 times *

    ::MD::times::"" ::= function virtual --> Numeric <-- (Numeric, Numeric);

    ::MD::"*" ::= synonym of times;

I<TODO.>

=head2 frac_divide /

    ::MD::frac_divide::"" ::= function virtual
        --> Numeric <-- (Numeric, Numeric)
        requires (\\1->is_zero->not);

    ::MD::"/" ::= synonym of frac_divide;

I<TODO.>

=head2 whole_divide div

    ::MD::whole_divide::"" ::= function virtual
        --> Numeric <-- (Numeric, Numeric, Round_Meth)
        requires (\\1->is_zero->not);

    ::MD::div ::= synonym of whole_divide;

I<TODO.>

=head2 modulo mod

    ::MD::modulo::"" ::= function
        --> Numeric <-- (Numeric, Numeric, Round_Meth)
        requires (\\1->is_zero->not)
        : (\\0 - (\\1 * div(*topic)));

    ::MD::mod ::= synonym of modulo;

I<TODO.>

=head2 divide_and_modulo

    ::MD::divide_and_modulo::"" ::= function
        --> ... <-- (Numeric, Numeric, Round_Meth)
        requires (\\1->is_zero->not)
        : (...);

I<TODO.>

=head1 INTEGRAL DATA TYPES

=head2 Integral

    ::MD::Integral ::= type abstract
        composes {Enumerable, Boolable, Numeric and_provides_its_default}
        requires_implements {in_order,pred,succ,is_zero,...};

I<TODO.  Also, do something about the unimplemented Numeric operators.>

=head2 so (Integral)

    ::MD::so::Integral ::= function --> Boolean <-- (Integral)
        implements 1::""
        : (\\0->is_zero->not);

I<TODO.>

=head1 INTEGER DATA TYPES

=head2 Integer_Inf Integer Int

    ::MD::Integer_Inf ::= type where topic -->^ FDN__isa_Integer_Inf
        default 0
        composes Integral and_provides_its_default;

    ::MD::Integer ::= synonym of Integer_Inf;
    ::MD::Int     ::= synonym of Integer_Inf;

The selection contract C<Integer_Inf> represents the infinite Muldis D
Foundation type I<FDN__Integer_Inf>.  An C<Integer_Inf> value is a general
purpose integer exact numeric.  Its default value is C<0>.  Other
programming languages may name their corresponding types I<BigInt>.

I<TODO.  Also, do something about the unimplemented Numeric operators.>

Examples:

    42

    0

    \-3

    \+'-3' '50_897'

    0d39

    0xDEADBEEF

    0o644

    0b11001001

=head2 in_order (Integer)

    ::MD::in_order::Integer ::= function --> Boolean <-- (Integer, Integer)
        implements 1::""
        : (topic -->^ FDN__Integers_in_order);

I<TODO.>

=head2 pred (Integer)

    ::MD::pred::Integer ::= function --> Integer <-- (Integer)
        implements 1::""
        : (\\0 - 1);

I<TODO.>

=head2 succ (Integer)

    ::MD::succ::Integer ::= function --> Integer <-- (Integer)
        implements 1::""
        : (\\0 + 1);

I<TODO.>

=head2 is_zero (Integer)

    ::MD::is_zero::Integer ::= function --> Boolean <-- (Integer)
        implements 1::""
        : (\\0 = 0);

I<TODO.>

=head1 ACCESSIBLE DATA TYPES

=head2 Accessible

    ::MD::Accessible ::= type abstract
        requires_implements {item,has_item};

I<TODO.>

=head2 item .

    ::MD::item::"" ::= function virtual --> Any <-- (Accessible, Any);

    ::MD::"." ::= synonym of item;

I<TODO.>

=head2 has_item .?

    ::MD::has_item::"" ::= function virtual --> Boolean <-- (Accessible, Any);

    ::MD::".?" ::= synonym of has_item;

I<TODO.>

=head2 item_or_void .!

    ::MD::item_or_void::"" ::= function --> Any <-- (Accessible, Any)
        : (topic --> \@".?" ?? topic --> \@"." !! \(\Void));

    ::MD::".!" ::= synonym of item_or_void;

I<TODO.>

=head1 ARRAYISH DATA TYPES

=head2 Arrayish

    ::MD::Arrayish ::= type abstract
        composes {Accessible,...}
        requires_implements {item,has_item,...};

I<TODO.>

=head1 ARRAY DATA TYPES

=head2 Array_Inf Array

    ::MD::Array_Inf ::= type where topic -->^ FDN__isa_Array_Inf
        default []
        composes Arrayish and_provides_its_default;

    ::MD::Array ::= synonym of Array_Inf;

The selection contract C<Array_Inf> represents the infinite Muldis D
Foundation type I<FDN__Array_Inf>.  An C<Array_Inf> value is ...

I<TODO.>

=head2 item (Array)

    ::MD::item::Array ::= function --> Any <-- (Array, Integer)
        implements 1::""
        : (topic -->^ FDN__Array_elem);

I<TODO.>

=head2 has_item (Array)

    ::MD::has_item::Array ::= function --> Boolean <-- (Array, Integer)
        implements 1::""
        : (topic -->^ FDN__Array_has_elem);

I<TODO.>

=head1 BAG DATA TYPES

=head2 Bag_Inf Bag

    ::MD::Bag_Inf ::= type where topic -->^ FDN__isa_Bag_Inf
        default \+{}
        composes Baggy and_provides_its_default;

    ::MD::Bag ::= synonym of Bag_Inf;

The selection contract C<Bag_Inf> represents the infinite Muldis D
Foundation type I<FDN__Bag_Inf>.  A C<Bag_Inf> value is ...

I<TODO.>

=head1 STRUCTURE DATA TYPES

=head2 Structure_Inf Structure

    ::MD::Structure_Inf ::= type where topic -->^ FDN__isa_Structure_Inf
        default \();

    ::MD::Structure ::= synonym of Structure_Inf;

The selection contract C<Structure_Inf> represents the infinite Muldis D
Foundation type I<FDN__Structure_Inf>.  A C<Structure_Inf> value is ...

I<TODO.>

Given that almost every selection contract is a subset of
C<Structure_Inf>, the latter intentionally does not compose any interface
contracts, and only has the minimal set of its own operators, so to
minimize interference with other types' interfaces.

=head2 field .>

    ::MD::field ::= function --> Any <-- (Structure, SC_Field_Name)
        : (topic -->^ FDN__Structure_field);

    ::MD::".>" ::= synonym of field;

I<TODO.>

=head2 has_field .>?

    ::MD::has_field ::= function --> Boolean <-- (Structure, SC_Field_Name)
        : (topic -->^ FDN__Structure_has_field);

    ::MD::".>?" ::= synonym of has_field;

I<TODO.>

=head2 has_any_fields ?^>

    ::MD::has_any_fields ::= function --> Boolean <-- (Structure)
        : (topic -->^ FDN__Structure_has_any_fields);

    ::MD::"?^>" ::= synonym of has_any_fields;

I<TODO.>

=head2 count_fields #^>

    ::MD::Structure_degree ::= function --> Integer <-- (Structure)
        : (topic -->^ FDN__Structure_count_fields);

    ::MD::"#^>" ::= synonym of count_fields;

I<TODO.>

=head2 on_fields ^>

    ::MD::on_fields ::= function --> Structure <-- (Structure, SC_Field_Names)
        : (...);

    ::MD::"^>" ::= synonym of on_fields;

I<TODO.>

=head2 but_fields -^>

    ::MD::but_fields ::= function --> Structure <-- (Structure, SC_Field_Names)
        : (...);

    ::MD::"^>" ::= synonym of but_fields;

I<TODO.>

=head2 has_fields ^>?

    ::MD::has_fields ::= function --> Boolean <-- (Structure, SC_Signature)
        : (...);

    ::MD::"^>" ::= synonym of has_fields;

I<TODO.>

=head2 has_just_fields ^>?=

    ::MD::has_just_fields ::= function --> Boolean <-- (Structure, SC_Signature)
        : (...);

    ::MD::"^>" ::= synonym of has_just_fields;

I<TODO.>

=head1 ATTRIBUTIVE DATA TYPES

=head2 Attributive

    ::MD::Attributive ::= type abstract
        requires_implements {has_any_attrs,degree,on,but,has_attrs,has_just_attrs};

I<TODO.>

=head2 has_any_attrs ?^

    ::MD::has_any_attrs::"" ::= function virtual --> Boolean <-- (Attributive);

    ::MD::"?^" ::= synonym of has_any_attrs;

I<TODO.>

=head2 degree count_attrs #^

    ::MD::degree::"" ::= function virtual --> Integral <-- (Attributive);

    ::MD::count_attrs ::= synonym of degree;
    ::MD::"#^"        ::= synonym of degree;

I<TODO.>

=head2 on ^ project

    ::MD::on::"" ::= function virtual
        --> Attributive <-- (Attributive, SC_Field_Names);

    ::MD::"^"     ::= synonym of on;
    ::MD::project ::= synonym of on;

I<TODO.>

=head2 but -^ project_all_but

    ::MD::but::"" ::= function virtual
        --> Attributive <-- (Attributive, SC_Field_Names);

    ::MD::"-^"            ::= synonym of but;
    ::MD::project_all_but ::= synonym of but;

I<TODO.>

=head2 has_attrs ^?

    ::MD::has_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, SC_Signature);

    ::MD::"^?" ::= synonym of has_attrs;

I<TODO.>

=head2 has_just_attrs ^?=

    ::MD::has_just_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, SC_Signature);

    ::MD::"^?=" ::= synonym of has_just_attrs;

I<TODO.>

=head1 TUPLE DATA TYPES

=head2 Tuple_Inf Tuple

    ::MD::Tuple_Inf ::= type of Structure
        where topic has_just_fields \(constant \Tuple, \@Structure)
        default \%()
        composes {Accessible and_provides_its_default,
            Attributive and_provides_its_default};

    ::MD::Tuple ::= synonym of Tuple_Inf;

I<TODO.>

=head2 item (Tuple)

    ::MD::item::Tuple ::= function --> Any <-- (Tuple, SC_Field_Name)
        implements 1::""
        : (\\0 .> \1 .> \\1);

I<TODO.>

=head2 has_item (Tuple)

    ::MD::has_item::Tuple ::= function --> Boolean <-- (Tuple, SC_Field_Name)
        implements 1::""
        : (\\0 .> \1 .>? \\1);

I<TODO.>

=head2 has_any_attrs (Tuple)

    ::MD::has_any_attrs::Tuple ::= function --> Boolean <-- (Tuple)
        implements 1::""
        : (?^>(\\0 .> \1));

I<TODO.>

=head2 degree (Tuple)

    ::MD::degree::Tuple ::= function --> Integer <-- (Tuple)
        implements 1::""
        : (#^>(\\0 .> \1));

I<TODO.>

=head2 on (Tuple)

    ::MD::on::Tuple ::= function --> Tuple <-- (Tuple, SC_Field_Names)
        implements 1::""
        : (\\0 .> \1 ^> \\1);

I<TODO.>

=head2 but (Tuple)

    ::MD::but::Tuple ::= function --> Tuple <-- (Tuple, SC_Field_Names)
        implements 1::""
        : (\\0 .> \1 -^> \\1);

I<TODO.>

=head2 has_attrs (Tuple)

    ::MD::has_attrs::Tuple ::= function --> Boolean <-- (Tuple, SC_Signature)
        implements 1::""
        : (\\0 .> \1 ^>? \\1);

I<TODO.>

=head2 has_just_attrs (Tuple)

    ::MD::has_just_attrs::Tuple ::= function --> Boolean <-- (Tuple, SC_Signature)
        implements 1::""
        : (\\0 .> \1 ^>?= \\1);

I<TODO.>

=head1 EXTERNAL DATA TYPES

=head2 External

    ::MD::External ::= type where topic -->^ FDN__isa_External
        default (-->^ FDN__default_External);

The selection contract C<External> represents the infinite Muldis D
Foundation type I<FDN__External>.  An C<External> value is ...

I<TODO.>

=head1 SOURCE CODE DEFINING DATA TYPES

=head2 Source_Code_Meta

    ::MD::Source_Code::Source_Code_Meta_AT ::= type abstract;

    ::MD::Source_Code::Source_Code_Meta ::= type ... intersect ...;

I<TODO.>

=head2 Package

    ::MD::Source_Code::Package ::= type ...;

I<TODO.>

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::See_Also> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright © 2002-2015, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
