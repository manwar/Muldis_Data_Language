=pod

=encoding utf8

=head1 NAME

Muldis::D::Package::Muldis_D -
Muldis D core data types and operators

=head1 VERSION

This document is Muldis::D::Package::Muldis_D version 0.200.1.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document
before you read this one, which provides subservient details.

I<TODO: If it turns out that any POD renderer fails to generate proper
internal hyperlinks due to this file reusing same =head2 (under different
=head1), then duplicates will be suffixed to make them unique.>

=head1 SYNOPSIS

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script ASCII;
    package
    {
        identity My_App ::= My_App:"http://mycorp.com":"0";
        uses
        {
            MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        };
        materials
        {
            floating {::My_App, ::MD};

            `TODO: Put example routines etc here.`

        };
    };

=head1 DESCRIPTION

This document defines the Muldis D Plain Text package
C<Muldis_D:"http://muldis.com":"0.200.1"> which provides the common core
system-defined data types and operators that regular users of the language
would employ directly in their applications and schemas.

This document I<also> defines the Muldis D Plain Text package
C<Muldis_D::Synonyms:"http://muldis.com":"0.200.1"> which adds trans-ASCII
Unicode synonyms to C<Muldis_D> package entities.

=head1 PACKAGES

From one source:

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script ASCII;
    package
    {
        identity MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        materials
        {
            floating {::MD, ::MD::Source_Code};
            ...
        };
    };

From a separate source:

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script Unicode:6.2.0:UTF-8:canon;
    package
    {
        identity MDS ::= Muldis_D::Synonyms:"http://muldis.com":"0.200.1";
        uses
        {
            MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        };
        materials
        {
            floating {::MD, ::MDS};
            ...
        };
    };

=head1 MAXIMAL AND MINIMAL DATA TYPES

=head2 Anything

    ::MD::Anything ::= type default false;

    ::MD::Any ::= synonym of Anything;

The enumeration contract C<Anything> represents the infinite I<universal
type>, which is the maximal data type of the entire Muldis D type system
and consists of all values which can possibly exist.  It also represents
the infinite Muldis D Foundation type I<FDN__Anything>.  Its default value
is C<false>.  Other programming languages may name their corresponding
types I<Any> or I<Object> or I<Anything>.

=head2 Nothing

    ::MD::Nothing ::= type of {};

The enumeration contract C<Nothing> represents the finite I<empty type>,
which is the minimal data type of the entire Muldis D type system and
consists of exactly zero values.  It can not have any default value.

=head2 =

    ::MD::"=" ::= function --> Boolean <-- (Anything, Anything)
        is {commutative}
        : topic -->^ FDN__same;

    ::MD::same ::= synonym of "=";

The function C<=> results in C<true> iff its 2 conceptual arguments are
exactly the same value, and C<false> otherwise.  Other programming
languages may name their corresponding operators I<==> or I<===>.

=head2 !=

    ::MD::"!=" ::= function --> Boolean <-- (Anything, Anything)
        is {commutative}
        : topic --> "=" ?? false !! true;

    ::MD::not_same ::= synonym of "!=";
    ::MDS::"≠"     ::= synonym of "!=";

The function C<!=> results in C<false> iff its 2 conceptual arguments are
exactly the same value, and C<true> otherwise.

=head1 ORDERABLE DATA TYPES

=head2 Orderable

    ::MD::Orderable ::= type abstract
        requires_implements in_order;

I<TODO.>

=head2 in_order

    ::MD::in_order::"" ::= function virtual
        --> Boolean <-- (Orderable, Orderable);

I<TODO.>

=head1 ENUMERABLE DATA TYPES

=head2 Enumerable

    ::MD::Enumerable ::= type abstract
        composes Orderable and_provides_its_default
        requires_implements {in_order,pred,succ};

I<TODO.>

=head2 pred

    ::MD::pred::"" ::= function virtual --> Enumerable <-- (Enumerable);

I<TODO.>

=head2 succ

    ::MD::succ::"" ::= function virtual --> Enumerable <-- (Enumerable);

I<TODO.>

=head1 BOOLABLE DATA TYPES

=head2 Boolable

    ::MD::Boolable ::= type abstract requires_implements "?";

I<TODO.>

=head2 ?

    ::MD::"?"::"" ::= function virtual --> Boolean <-- (Boolable);

    ::MD::so ::= synonym of "?";

I<TODO.>

=head1 BOOLEAN DATA TYPES

=head2 Boolean

    ::MD::Boolean::"" ::= type where topic -->^ FDN__isa_Boolean
        default false
        composes {Enumerable and_provides_its_default,
            Boolable and_provides_its_default};

    ::MD::Bool ::= synonym of Boolean;

    ::MD::False ::= type of Boolean where !topic default false;
    ::MD::True  ::= type of Boolean where topic default true;

The enumeration contract C<Boolean> represents the finite Muldis D
Foundation type I<FDN__Boolean>.  A C<Boolean> value is a general purpose
2-valued logic boolean, or specifically it is one of the 2 values C<false>
and C<true>.  Its default value is C<false>.

I<TODO.>

Examples:

    true

    false

=head2 in_order

    ::MD::in_order::Boolean ::= function --> Boolean <-- (Boolean, Boolean)
        implements 1::""
        : !\\0 or \\1;

I<TODO.>

=head2 pred

    ::MD::pred::Boolean ::= function
        --> type union {False,"-Inf"} <-- (Boolean)
        implements 1::""
        : \\0 ?? false !! \(\"-Inf");

I<TODO.>

=head2 succ

    ::MD::succ::Boolean ::= function
        --> type union {True,"+Inf"} <-- (Boolean)
        implements 1::""
        : !\\0 ?? true !! \(\"+Inf");

I<TODO.>

=head2 ?

    ::MD::"?"::Boolean ::= function --> Boolean <-- (Boolean)
        implements 1::""
        : \\0;

I<TODO.>

=head2 false

    ::MD::false ::= constant false;

    ::MDS::"⊥" ::= synonym of false;

I<TODO.>

=head2 true

    ::MD::true ::= constant true;

    ::MDS::"⊤" ::= synonym of true;

I<TODO.>

=head2 not

    ::MD::not ::= function --> Boolean <-- (Boolean)
        : \\0 ?? false !! true;

    ::MD::"!"  ::= synonym of not;
    ::MDS::"¬" ::= synonym of not;

I<TODO.>

=head2 and

    ::MD::and ::= function --> Boolean <-- (Boolean, Boolean)
        is {commutative,associative,idempotent} identity true
        : (\\0 ?? \\1 !! false);

    ::MD::all   ::= synonym of and;
    ::MD::every ::= synonym of and;
    ::MDS::"∧"  ::= synonym of and;

I<TODO.>

=head1 NUMERIC DATA TYPES

=head2 Numeric

    ::MD::Numeric ::= type abstract
        requires_implements {"-"::monadic,"+","-","*","/","div"};

I<TODO.>

=head1 INTEGRAL DATA TYPES

=head2 Integral

    ::MD::Integral ::= type abstract
        composes {Enumerable, Boolable, Numeric and_provides_its_default}
        requires_implements {in_order,pred,succ,is_zero,...};

I<TODO.>

=head2 ?

    ::MD::"?"::Integral ::= function --> Boolean <-- (Integral)
        implements 1::""
        : \\0->is_zero->not;

I<TODO.>

=head2 is_zero

    ::MD::is_zero::"" ::= function virtual --> Boolean <-- (Integral);

I<TODO.>

=head1 INTEGER DATA TYPES

=head2 Inf_Integer

    ::MD::Inf_Integer ::= type where topic -->^ FDN__isa_Inf_Integer
        default 0
        composes Integral and_provides_its_default;

    ::MD::Integer ::= synonym of Inf_Integer;
    ::MD::Int     ::= synonym of Inf_Integer;

The enumeration contract C<Inf_Integer> represents the infinite Muldis D
Foundation type I<FDN__Inf_Integer>.  An C<Inf_Integer> value is a general
purpose integer exact numeric.  Its default value is C<0>.  Other
programming languages may name their corresponding types I<BigInt>.

I<TODO.>

Examples:

    42

    0

    \-3

    \+'-3' '50_897'

    0d39

    0xDEADBEEF

    0o644

    0b11001001

=head2 in_order

    ::MD::in_order::Inf_Integer ::= function
        --> Boolean <-- (Inf_Integer, Inf_Integer)
        implements 1::""
        : topic -->^ FDN__Integers_in_order;

I<TODO.>

=head2 pred

    ::MD::pred::Inf_Integer ::= function --> Inf_Integer <-- (Inf_Integer)
        implements 1::""
        : \\0 - 1;

I<TODO.>

=head2 succ

    ::MD::succ::Inf_Integer ::= function --> Inf_Integer <-- (Inf_Integer)
        implements 1::""
        : \\0 + 1;

I<TODO.>

=head2 is_zero

    ::MD::is_zero::Inf_Integer ::= function --> Boolean <-- (Inf_Integer)
        implements 1::""
        : \\0 = 0;

I<TODO.>

=head1 ARRAY DATA TYPES

=head2 Inf_Array

    ::MD::Inf_Array ::= type where topic -->^ FDN__isa_Inf_Array
        default []
        composes Arrayish and_provides_its_default;

The enumeration contract C<Inf_Array> represents the infinite Muldis D
Foundation type I<FDN__Inf_Array>.  An C<Inf_Array> value is ...

I<TODO.>

=head1 BAG DATA TYPES

=head2 Inf_Bag

    ::MD::Inf_Bag ::= type where topic -->^ FDN__isa_Inf_Bag
        default \+{}
        composes Baggy and_provides_its_default;

The enumeration contract C<Inf_Bag> represents the infinite Muldis D
Foundation type I<FDN__Inf_Bag>.  An C<Inf_Bag> value is ...

I<TODO.>

=head1 STRUCTURE DATA TYPES

=head2 Inf_Structure

    ::MD::Inf_Structure ::= type where topic -->^ FDN__isa_Inf_Structure
        default \();

The enumeration contract C<Inf_Structure> represents the infinite Muldis D
Foundation type I<FDN__Inf_Structure>.  An C<Inf_Structure> value is ...

I<TODO.>

=head1 EXTERNAL DATA TYPES

=head2 External

    ::MD::External ::= type where topic -->^ FDN__isa_External
        default \~external~'';

The enumeration contract C<External> represents the infinite Muldis D
Foundation type I<FDN__External>.  An C<External> value is ...

I<TODO.>

=head1 SOURCE CODE DEFINING DATA TYPES

=head2 Source_Code_Meta

    ::MD::Source_Code::Source_Code_Meta_AT ::= type abstract;

    ::MD::Source_Code::Source_Code_Meta ::= type ... intersect ...;

I<TODO.>

=head2 Package

    ::MD::Source_Code::Package ::= type ...;

I<TODO.>

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::See_Also> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright © 2002-2015, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
