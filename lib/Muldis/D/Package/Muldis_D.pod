=pod

=encoding utf8

=head1 NAME

Muldis::D::Package::Muldis_D -
Muldis D core data types and operators

=head1 VERSION

This document is Muldis::D::Package::Muldis_D version 0.200.1.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document
before you read this one, which provides subservient details.

=head1 SYNOPSIS

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script ASCII;
    package
    {
        identity My_App ::= My_App:"http://mycorp.com":"0";
        uses
        {
            MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        };
        materials
        {
            floating {::My_App, ::MD};

            `TODO: Put example routines etc here.`

        };
    };

=head1 DESCRIPTION

This document defines the Muldis D Plain Text package
C<Muldis_D:"http://muldis.com":"0.200.1"> which provides the common core
system-defined data types and operators that regular users of the language
would employ directly in their applications and schemas.

This document I<also> defines the Muldis D Plain Text package
C<Muldis_D::Aliases:"http://muldis.com":"0.200.1"> which adds trans-ASCII
Unicode aliases to C<Muldis_D> package entities.

=head1 PACKAGES

From one source:

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script ASCII;
    package
    {
        identity MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        materials
        {
            floating {::MD, ::MD::Source_Code};
            ...
        };
    };

From a separate source:

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script Unicode:8.0:UTF-8:canon;
    package
    {
        identity MDA ::= Muldis_D::Aliases:"http://muldis.com":"0.200.1";
        uses
        {
            MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        };
        materials
        {
            floating {::MD, ::MDA};
            ...
        };
    };

=head1 MAXIMAL AND MINIMAL DATA TYPES

=head2 Anything Any

    ::MD::Anything ::= selection default (False);

    ::MD::Any ::= alias of Anything;

The selection contract C<Anything> represents the infinite I<universal
type>, which is the maximal data type of the entire Muldis D type system
and consists of all values which can possibly exist.  It also represents
the infinite Muldis D Foundation type I<FDN__Anything>.  Its default value
is C<False>.  Other programming languages may name their corresponding
types I<Any> or I<Object> or I<Anything>.

=head2 Nothing

    ::MD::Nothing ::= selection of {};

The selection contract C<Nothing> represents the finite I<empty type>,
which is the minimal data type of the entire Muldis D type system and
consists of exactly zero values.  It can not have any default value.

=head2 same =

    ::MD::same ::= function --> Boolean <-- (Any, Any)
        is commutative
        : (topic -->^ FDN__same);

    ::MD::"=" ::= alias of same;

The function C<same> results in C<True> iff its 2 conceptual arguments are
exactly the same value, and C<False> otherwise.  Other programming
languages may name their corresponding operators I<==> or I<===>.

=head2 not_same != ≠

    ::MD::not_same ::= function negates same
        is commutative;

    ::MD::"!=" ::= alias of not_same;
    ::MDA::"≠" ::= alias of not_same;

The function C<not_same> results in C<False> iff its 2 conceptual arguments
are exactly the same value, and C<True> otherwise.

=head1 EXCUSE DATA TYPES

=head2 Excuse

    ::MD::Excuse::"" ::= interface;

I<TODO.>

=head2 Excuse::No_Reason

    ::MD::Excuse::No_Reason ::= constant (\@0)
        composes Excuse and_provides_its_default;

I<TODO.>

=head2 coalesce ?!

    ::MD::coalesce ::= function --> Any <-- (Any, Any)
        : (\.0 isa \@Excuse ?? \.1 !! \.0);

    ::MD::"?!" ::= alias of coalesce;

I<TODO.  Also, isa() needs defining.>

=head1 ORDERABLE DATA TYPES

=head2 Orderable

    ::MD::Orderable ::= interface
        requires_implements in_order;

I<TODO.>

=head2 Neg_Inf -∞

    ::MD::Neg_Inf ::= constant (\@0) composes {Orderable, Excuse};

    ::MDA::"-∞" ::= alias of Neg_Inf;

I<TODO.>

=head2 Pos_Inf +∞

    ::MD::Pos_Inf ::= constant (\@0) composes {Orderable, Excuse};

    ::MDA::"+∞" ::= alias of Pos_Inf;

I<TODO.>

=head2 in_order

    ::MD::in_order::"" ::= function virtual
        --> Boolean <-- (Orderable, Orderable);

I<TODO.>

=head2 in_order (Neg_Inf, Pos_Inf)

    ::MD::in_order::Neg_Inf_L ::= function --> Boolean <-- (Neg_Inf, Orderable)
        implements 1::""
        : (True);

    ::MD::in_order::Neg_Inf_R ::= function --> Boolean <-- (Orderable, Neg_Inf)
        implements 1::""
        : (topic --> \@same);

    ::MD::in_order::Pos_Inf_L ::= function --> Boolean <-- (Pos_Inf, Orderable)
        implements 1::""
        : (topic --> \@same);

    ::MD::in_order::Pos_Inf_R ::= function --> Boolean <-- (Orderable, Pos_Inf)
        implements 1::""
        : (True);

I<TODO.>

=head2 before <

    ::MD::before ::= function commutes after;

    ::MD::"<" ::= alias of before;

I<TODO.>

=head2 after >

    ::MD::after ::= function negates before_or_same;

    ::MD::">" ::= alias of after;

I<TODO.>

=head2 before_or_same <= ≤

    ::MD::before_or_same ::= alias of in_order;

    ::MD::"<=" ::= alias of before_or_same;
    ::MDA::"≤" ::= alias of before_or_same;

I<TODO.>

=head2 after_or_same >= ≥

    ::MD::after_or_same ::= function commutes before_or_same;

    ::MD::">=" ::= alias of after_or_same;
    ::MDA::"≥" ::= alias of after_or_same;

I<TODO.>

=head2 min

    ::MD::min ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity (Pos_Inf())
        : (topic --> \@in_order ?? \.0 !! \.1);

I<TODO.>

=head2 max

    ::MD::max ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity (Neg_Inf())
        : (topic --> \@in_order ?? \.1 !! \.0);

I<TODO.>

=head2 minmax

    ::MD::minmax ::= function
        --> (Orderable, Orderable) <-- (Orderable, Orderable)
        is commutative
        : (topic --> \@in_order ?? topic !! \%(\.1, \.0));

I<TODO.>

=head1 ENUMERABLE DATA TYPES

=head2 Enumerable

    ::MD::Enumerable ::= interface
        composes Orderable and_provides_its_default
        requires_implements {in_order,pred,succ};

I<TODO.>

=head2 pred

    ::MD::pred::"" ::= function virtual --> Enumerable <-- (Enumerable);

I<TODO.>

=head2 succ

    ::MD::succ::"" ::= function virtual --> Enumerable <-- (Enumerable);

I<TODO.>

=head1 BOOLABLE DATA TYPES

=head2 Boolable

    ::MD::Boolable ::= interface requires_implements so;

I<TODO.  For types that have a canonical way of being cast to booleans;
for collection types an empty collection is false and nonempty is true;
for numeric types, a zero is false and a nonzero is true.
Composed by: Boolean, Numeric (Integer, ...), Homogeneous (Array, Set, Relation, Bag,...).
(Conceptually but not actually composed by Attributive (Tuple, Relation,...)
due to overlap and conflicting meaning with some other composers;
Attributive instead has its own different-named versions of the Boolable ops.)>

=head2 so ?

    ::MD::so::"" ::= function virtual --> Boolean <-- (Boolable);

    ::MD::"?" ::= alias of so;

I<TODO.>

=head2 not_so !?

    ::MD::not_so ::= function negates so;

    ::MD::"!?" ::= alias of not_so;

I<TODO.>

=head1 BOOLEAN DATA TYPES

=head2 Boolean Bool

    ::MD::Boolean::"" ::= selection where (topic -->^ FDN__isa_Boolean)
        default (False)
        composes {Enumerable and_provides_its_default,
            Boolable and_provides_its_default};

    ::MD::Bool ::= alias of Boolean;

The selection contract C<Boolean> represents the finite Muldis D
Foundation type I<FDN__Boolean>.  A C<Boolean> value is a general purpose
2-valued logic boolean, or specifically it is one of the 2 values C<False>
and C<True>.  Its default value is C<False>.

I<TODO.>

Examples:

    True

    False

=head2 in_order (Boolean)

    ::MD::in_order::Boolean ::= function --> Boolean <-- (Boolean, Boolean)
        implements 1::""
        : (!\.0 or \.1);

I<TODO.>

=head2 pred (Boolean)

    ::MD::pred::Boolean ::= function --> {False, Neg_Inf} <-- (Boolean)
        implements 1::""
        : (\.0 ?? False !! Neg_Inf());

I<TODO.>

=head2 succ (Boolean)

    ::MD::succ::Boolean ::= function --> {True, Pos_Inf} <-- (Boolean)
        implements 1::""
        : (!\.0 ?? True !! Pos_Inf());

I<TODO.>

=head2 False ⊥

    ::MD::False ::= constant (False);

    ::MDA::"⊥" ::= alias of False;

I<TODO.>

=head2 True ⊤

    ::MD::True ::= constant (True);

    ::MDA::"⊤" ::= alias of True;

I<TODO.>

=head2 so (Boolean)

    ::MD::so::Boolean ::= function --> Boolean <-- (Boolean)
        implements 1::""
        : (\.0);

I<TODO.>

=head2 not ! ¬

    ::MD::not ::= function negates so::Boolean;

    ::MD::"!"  ::= alias of not;
    ::MDA::"¬" ::= alias of not;

I<TODO.>

=head2 and ∧

    ::MD::and ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity (True)
        : (\.0 ?? \.1 !! False);

    ::MDA::"∧"  ::= alias of and;

I<TODO.>

=head2 nand not_and ⊼ ↑

    ::MD::nand ::= function negates and
        is commutative;

    ::MD::not_and ::= alias of nand;
    ::MDA::"⊼"    ::= alias of nand;
    ::MDA::"↑"    ::= alias of nand;

I<TODO.>

=head2 or ∨

    ::MD::or ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity (False)
        : (\.0 ?? True !! \.1);

    ::MDA::"∨" ::= alias of or;

I<TODO.>

=head2 nor not_or ⊽ ↓

    ::MD::nor ::= function negates or
        is commutative;

    ::MD::not_or ::= alias of nor;
    ::MDA::"⊽"   ::= alias of nor;
    ::MDA::"↓"   ::= alias of nor;

I<TODO.>

=head2 xnor iff ↔

    ::MD::xnor ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative} identity (True)
        : (topic --> \@same);

    ::MD::iff  ::= alias of xnor;
    ::MDA::"↔" ::= alias of xnor;

I<TODO.>

=head2 xor ⊻ ↮

    ::MD::xor ::= function negates xnor
        is {associative,commutative} identity (False);

    ::MDA::"⊻" ::= alias of xor;
    ::MDA::"↮" ::= alias of xor;

I<TODO.>

=head2 imp implies →

    ::MD::imp ::= function --> Boolean <-- (Boolean, Boolean)
        : (\.0 ?? \.1 !! True);

    ::MD::implies ::= alias of imp;
    ::MDA::"→"    ::= alias of imp;

I<TODO.>

=head2 nimp not_implies ↛

    ::MD::nimp ::= function negates imp;

    ::MD::not_implies ::= alias of nimp;
    ::MDA::"↛"        ::= alias of nimp;

I<TODO.>

=head2 if ←

    ::MD::if ::= function commutes imp;

    ::MDA::"←" ::= alias of if;

I<TODO.>

=head2 nif not_if ↚

    ::MD::nif ::= function commutes nimp;

    ::MD::not_if ::= alias of nif;
    ::MDA::"↚"   ::= alias of nif;

I<TODO.>

=head1 NUMERIC DATA TYPES

=head2 Numeric

    ::MD::Numeric ::= interface
        composes Boolable
        requires_implements {so,opposite,reciprocal,modulus,
            plus,minus,frac_divide,whole_divide,...};

I<TODO.>

=head2 Round_Meth

    ::MD::Round_Meth::"" ::= selection
        union {1::Down,1::Up,1::To_Zero,1::To_Inf
            ,1::Half_Down,1::Half_Up,1::Half_To_Zero,1::Half_To_Inf
            ,1::Half_Even}
        default (1::To_Zero());

    ::MD::Round_Meth::Down         ::= constant (\@0);
    ::MD::Round_Meth::Up           ::= constant (\@0);
    ::MD::Round_Meth::To_Zero      ::= constant (\@0);
    ::MD::Round_Meth::To_Inf       ::= constant (\@0);
    ::MD::Round_Meth::Half_Down    ::= constant (\@0);
    ::MD::Round_Meth::Half_Up      ::= constant (\@0);
    ::MD::Round_Meth::Half_To_Zero ::= constant (\@0);
    ::MD::Round_Meth::Half_To_Inf  ::= constant (\@0);
    ::MD::Round_Meth::Half_Even    ::= constant (\@0);

I<TODO.  Also, review most appropriate values for the constants.>

=head2 so (Numeric)

    ::MD::so::Numeric ::= function virtual --> Boolean <-- (Numeric)
        implements 1::"";

I<TODO.>

=head2 is_zero

    ::MD::is_zero ::= function negates so::Numeric;

I<TODO.>

=head2 opposite

    ::MD::opposite::"" ::= function virtual --> Numeric <-- (Numeric);

    ::MD::additive_inverse ::= alias of opposite;

I<TODO.>

=head2 reciprocal

    ::MD::reciprocal::"" ::= function virtual --> Numeric <-- (Numeric)
        requires (?\.0);

    ::MD::multiplicative_inverse ::= alias of reciprocal;

I<TODO.>

=head2 modulus abs

    ::MD::modulus::"" ::= function virtual --> Numeric <-- (Numeric);

    ::MD::abs ::= alias of modulus;

I<TODO.>

=head2 plus +

    ::MD::plus::"" ::= function virtual --> Numeric <-- (Numeric, Numeric);

    ::MD::"+" ::= alias of plus;

I<TODO.>

=head2 minus

    ::MD::minus::"" ::= function virtual --> Numeric <-- (Numeric, Numeric);

I<TODO.>

=head2 -

    ::MD::"-" ::= function --> Numeric <-- {(Numeric), (Numeric, Numeric)}
        : (topic --> (degree(topic) = 1 ?? \@opposite !! \@minus));

I<TODO.>

=head2 modulus_minus abs_minus |-|

    ::MD::modulus_minus ::= function --> Numeric <-- (Numeric, Numeric)
        : (modulus topic --> \@minus);

    ::MD::abs_minus ::= alias of modulus_minus;
    ::MD::"|-|"     ::= alias of modulus_minus;

I<TODO.>

=head2 times *

    ::MD::times::"" ::= function virtual --> Numeric <-- (Numeric, Numeric);

    ::MD::"*" ::= alias of times;

I<TODO.>

=head2 frac_divide /

    ::MD::frac_divide::"" ::= function virtual
        --> Numeric <-- (Numeric, Numeric)
        requires (?\.1);

    ::MD::"/" ::= alias of frac_divide;

I<TODO.>

=head2 whole_divide div

    ::MD::whole_divide::"" ::= function virtual
        --> Numeric <-- (Numeric, Numeric, Round_Meth)
        requires (?\.1);

    ::MD::div ::= alias of whole_divide;

I<TODO.>

=head2 modulo mod

    ::MD::modulo::"" ::= function
        --> Numeric <-- (Numeric, Numeric, Round_Meth)
        requires (?\.1)
        : (\.0 - (\.1 * topic --> \@div));

    ::MD::mod ::= alias of modulo;

I<TODO.>

=head2 divide_and_modulo

    ::MD::divide_and_modulo::"" ::= function
        --> (Numeric, Numeric) <-- (Numeric, Numeric, Round_Meth)
        requires (?\.1)
        : (\%(topic --> \@div, topic --> \@mod));

I<TODO.>

=head1 INTEGRAL DATA TYPES

=head2 Integral

    ::MD::Integral ::= interface
        composes {Enumerable, Numeric and_provides_its_default}
        requires_implements {in_order,pred,succ,so,...};

I<TODO.  Also, do something about the unimplemented Numeric operators.>

=head1 INTEGER DATA TYPES

=head2 Integer_Inf Integer Int

    ::MD::Integer_Inf ::= selection where (topic -->^ FDN__isa_Integer_Inf)
        default (0)
        composes Integral and_provides_its_default;

    ::MD::Integer ::= alias of Integer_Inf;
    ::MD::Int     ::= alias of Integer_Inf;

    ::MD::Integer_NN ::= selection of Integer where (topic >= 0);

    ::MD::Integer_P ::= selection of Integer_NN where (topic > 0) default (1);

The selection contract C<Integer_Inf> represents the infinite Muldis D
Foundation type I<FDN__Integer_Inf>.  An C<Integer_Inf> value is a general
purpose integer exact numeric.  Its default value is C<0>.  Other
programming languages may name their corresponding types I<BigInt>.

I<TODO.  Also, do something about the unimplemented Numeric operators.>

Examples:

    42

    0

    \-3

    \+'-3' '50_897'

    0d39

    0xDEADBEEF

    0o644

    0b11001001

=head2 in_order (Integer)

    ::MD::in_order::Integer ::= function --> Boolean <-- (Integer, Integer)
        implements 1::""
        : (topic -->^ FDN__Integers_in_order);

I<TODO.>

=head2 pred (Integer)

    ::MD::pred::Integer ::= function --> Integer <-- (Integer)
        implements 1::""
        : (\.0 - 1);

I<TODO.>

=head2 succ (Integer)

    ::MD::succ::Integer ::= function --> Integer <-- (Integer)
        implements 1::""
        : (\.0 + 1);

I<TODO.>

=head2 so (Integer)

    ::MD::so::Integer ::= function --> Boolean <-- (Integer)
        implements 1::""
        : (\.0 != 0);

I<TODO.>

=head1 ACCESSIBLE DATA TYPES

=head2 Accessible

    ::MD::Accessible ::= interface
        requires_implements {".",".?",".!"};

I<TODO.  For types that support simple accessor-based lookup of single values;
for one-dimensional collections of pairs that support lookup by one
pair element of the other pair element, and every pair in the
collection has a distinct first element.
Does not have anything to say related to either enumerating elements or
to slicing a subset elements into a new collection.
Accessible just provides certain convenient shared names for operators that
otherwise have distinct names on the composing types.
Composed by: Positional (Array, String,...), Tuple, Dictionary, etc.
(Conceptually also composed by Capsule, but isn't to avoid conflicts.)>

=head2 .

    ::MD::"."::"" ::= function virtual --> Any <-- (Accessible, Any)
        requires (topic --> \@".?");

I<TODO.>

=head2 .?

    ::MD::".?"::"" ::= function virtual --> Boolean <-- (Accessible, Any);

I<TODO.>

=head2 .!

    ::MD::".!"::"" ::= function virtual --> Any <-- (Accessible, Any);

I<TODO.>

=head1 HOMOGENEOUS DATA TYPES

=head2 Homogeneous

    ::MD::Homogeneous::"" ::= interface
        composes Boolable
        requires_implements {so,count,has,nest,unnest,any,where,map,reduce,...};

I<TODO.  For types whose values are conceptually homogeneous collections
of distinct integral-weighted objects, where the weights may or may not be
constrained to 1 (each element can only appear once),
either with a canonical order of elements or with no canonical order.
Composed by: Positional (Array, String, etc), Setty (Set, Relation),
Bag, Tuple_Bag, Dictionary, etc.
Subtypes also composing Positional are ordered, and others are not.
Subtypes also composing Setty ensure elements appear just once, others don't.
(Conceptually more or less all collection types can be thought of as being
collections over 2 dimensions, heterogeneous/Attributive and Homogeneous;
Relation and Tuple_Bag formally are multiples in both dimensions, while the
other types are formally multiples in just one of those dimensions.)>

I<TODO.  Note that for all the regular function-taking element-wise
Homogeneous operators that are logically supposed to work with each
collection member in isolation and/or shouldn't put significance on either
duplicate members or member position in the collection, including the likes
of {any, where, map} etc, but not including the likes of {reduce}, the
operators will only be passing the asset portion (where applicable) of the
member to the higher-order function, and not say the index-asset pair for a
Positional or the asset-count pair for a Baggy.  Note that for a Relation
or Tuple_Bag each entire Tuple is the member asset, and for a Dictionary
the pair is the asset.  (With the corresponding attribute-wise Tuple
operators, they are given the whole attribute name-value pair.)  The main
reason for this is to help ensure consistency of results while supporting a
variety of collection implementations including ones that are lazy, such as
by not eagerly counting duplicates, or that use distributed computation.
For that matter, the likes of {reduce} should probably be treated the same
way; see also the 'repeater' function trait that helps optimize it.
Surely, any time when one may think these operations need to know the
baggy count or positional index, its for a problem best solved differently.>

=head2 so (Homogeneous) has_any_members

    ::MD::so::Homogeneous ::= function virtual --> Boolean <-- (Homogeneous)
        implements 1::"";

    ::MD::has_any_members ::= alias of so::Homogeneous;

I<TODO.>

=head2 is_empty

    ::MD::is_empty ::= function negates so::Homogeneous;

I<TODO.>

=head2 count cardinality #

    ::MD::count::"" ::= function virtual --> Integral <-- (Homogeneous);

    ::MD::cardinality ::= alias of count;
    ::MD::"#"         ::= alias of count;

I<TODO.>

=head2 has ∋

    ::MD::has::"" ::= function virtual --> Boolean <-- (Homogeneous, Any);

    ::MDA::"∋" ::= alias of has;

I<TODO.>

=head2 not_has ∌

    ::MD::not_has ::= function negates has;

    ::MDA::"∌" ::= alias of not_has;

I<TODO.>

=head2 in ∈

    ::MD::in ::= function commutes has;

    ::MDA::"∈" ::= alias of in;

I<TODO.>

=head2 not_in ∉

    ::MD::not_in ::= function commutes not_has;

    ::MDA::"∉" ::= alias of not_in;

I<TODO.>

=head2 nest group

    ::MD::nest::"" ::= function virtual --> Homogeneous <-- (Homogeneous)
        requires (...);

    ::MD::group ::= alias of nest;

I<TODO.>

=head2 unnest ungroup

    ::MD::unnest::"" ::= function virtual --> Homogeneous <-- (Homogeneous)
        requires (...);

    ::MD::ungroup ::= alias of unnest;

I<TODO.>

=head2 any there_exists ∃

    ::MD::any::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Primed_Func_Ref);

    ::MD::there_exists ::= alias of any;
    ::MDA::"∃"         ::= alias of any;

I<TODO.  Result is true when at least one member evaluates to true.
This is logically equivalent to testing if a same-topic 'where' result is nonempty,
but 'any' is instead virtual with applicable Foundation-level functions to
aid efficiency with less-savvy optimizers that don't know to short-circuit.>

=head2 none there_does_not_exist ∄

    ::MD::none ::= function negates any;

    ::MD::there_does_not_exist ::= alias of none;
    ::MDA::"∄"                 ::= alias of none;

I<TODO.  Result is true when no member evaluates to true.>

=head2 all for_all ∀

    ::MD::all ::= function --> Boolean <-- (Homogeneous, Primed_Func_Ref)
        : (\.0 none negated_func(of : \.1, passing_args : \@(0)));

    ::MD::for_all ::= alias of all;
    ::MDA::"∀"    ::= alias of all;

I<TODO.  Result is true when no member evaluates to false.>

=head2 all_isa

    ::MD::all_isa ::= function --> Boolean <-- (Homogeneous, Reference)
        : (\.0 all (\@isa assuming topic ^ \@(1)));

I<TODO.>

=head2 where

    ::MD::where::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Primed_Func_Ref);

I<TODO.  The primed-func-ref is expected to be a Capsule with 2 asset attrs
named 'func' and 'args', which are a Reference and a Tuple respectively.
The 'args' can be any Tuple that doesn't have a '0' attr.
The function referenced by 'func' is expected to take a Tuple argument
whose '0' attr is a member of the collection and whose other attrs match
those given in 'args'.>

=head2 filtering

    ::MD::filtering ::= function commutes where;

I<TODO.>

=head2 map

    ::MD::map::"" ::= function virtual
        --> Homogeneous <-- (Homogeneous, Primed_Func_Ref);

I<TODO.  The primed-func-ref is as per that of 'where'.>

=head2 reduce

    ::MD::reduce::"" ::= function virtual
        --> Any <-- (Homogeneous, Primed_Func_Ref);

I<TODO.  The primed-func-ref is expected to be a Capsule with 2 asset attrs
named 'func' and 'args', which are a Reference and a Tuple respectively.
The 'args' can be any Tuple that doesn't have either '0' or '1' attrs.
The function referenced by 'func' is expected to take a Tuple argument
whose '0' and '1' attrs are members of the collection and whose other attrs match
those given in 'args'.
Depending on the collection subtype, order of 0,1 may or may not be significant.>

=head1 POSITIONAL DATA TYPES

=head2 Positional

    ::MD::Positional ::= interface
        composes {Orderable, Accessible, Homogeneous and_provides_its_default, ...}
        requires_implements {so,count,elem,has_index,has,nest,unnest,any,where,map,reduce,
            first_index,last_index,slice,catenate,index_succ_all_matches,...};

I<TODO.  For types that support integer-index-based lookup of values;
for collections of index-value pairs where all indexes are distinct;
for collections you can enumerate in canonical order;
the collection indexes might not be zero-based in the general case but must be dense.
Composed by: Array, String, Blob, Text, etc.>

=head2 Excuse::No_Such_Index

    ::MD::Excuse::No_Such_Index ::= constant (\@0) composes Excuse;

I<TODO.>

=head2 in_order (Positional)

    ::MD::in_order::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 1::""
    : (
        i ::= (topic --> \@index_succ_all_matches);
      <--
        if not \.0 .? i then
            e1 ::= True
        else if not \.1 .? i then
            False
        else
            e2 ::= (\.0.i in_order \.1.i);

        e1 ::?= \~?'This is the case where LHS is a leading subsequence of or is equal to RHS.';
        e2 ::?= \~?'This will succeed iff in_order() is defined for the element type.';
    );

I<TODO.>

=head2 elem . (Positional)

    ::MD::elem::"" ::= function virtual --> Any <-- (Positional, Integral)
        requires (topic --> \@has_index);

    ::MD::"."::Positional ::= function --> Any <-- (Positional, Integral)
        implements 1::""
        requires (topic --> \@has_index)
        : (topic --> \@elem);

I<TODO.>

=head2 has_index .? (Positional)

    ::MD::has_index::"" ::= function virtual --> Boolean <-- (Positional, Integral);

    ::MD::".?"::Positional ::= function --> Boolean <-- (Positional, Integral)
        implements 1::""
        : (topic --> \@has_index);

I<TODO.>

=head2 elem_or_excuse .! (Positional)

    ::MD::elem_or_excuse ::= function --> Any <-- (Positional, Integral)
        : (topic --> \@has_index ?? topic --> \@elem !! Excuse::No_Such_Index());

    ::MD::".!"::Positional ::= function --> Any <-- (Positional, Integral)
        implements 1::""
        : (topic --> \@elem_or_excuse);

I<TODO.>

=head2 first_index

    ::MD::first_index::"" ::= function virtual --> Integral <-- (Positional)
        requires (?\.0);

I<TODO.>

=head2 last_index

    ::MD::last_index::"" ::= function virtual --> Integral <-- (Positional)
        requires (?\.0);

I<TODO.>

=head2 slice

    ::MD::slice::"" ::= function virtual
        --> Positional <-- (Positional, Interval);

I<TODO.  Need to clarify constraints, eg is this a strict subsequence
operation or is it more like an intersection.>

=head2 first

    ::MD::first ::= function --> Any <-- (Positional)
        requires (?\.0)
        : (\.0 . first_index(\.0));

I<TODO.>

=head2 nonfirst

    ::MD::nonfirst ::= function --> Positional <-- (Positional)
        requires (?\.0)
        : (\.0 slice first_index(\.0)^..last_index(\.0));

I<TODO.>

=head2 last

    ::MD::last ::= function --> Any <-- (Positional)
        requires (?\.0)
        : (\.0 . last_index(\.0));

I<TODO.>

=head2 nonlast

    ::MD::nonlast ::= function --> Positional <-- (Positional)
        requires (?\.0)
        : (\.0 slice first_index(\.0)..^last_index(\.0));

I<TODO.>

=head2 catenate ~

    ::MD::catenate::"" ::= function virtual
        --> Positional <-- (Positional, Positional)
        is associative;

    ::MD::"~" ::= alias of catenate;

I<TODO.>

=head2 index_succ_all_matches

    ::MD::index_succ_all_matches::"" ::= function virtual
        --> Integral <-- (Positional, Positional)
        is commutative;

I<TODO.>

=head1 ARRAY DATA TYPES

=head2 Array_Inf Array

    ::MD::Array_Inf ::= selection where (topic -->^ FDN__isa_Array_Inf)
        default ([])
        composes Positional and_provides_its_default;

    ::MD::Array ::= alias of Array_Inf;

The selection contract C<Array_Inf> represents the infinite Muldis D
Foundation type I<FDN__Array_Inf>.  An C<Array_Inf> value is ...

I<TODO.>

=head2 so (Array)

    ::MD::so::Array ::= function --> Boolean <-- (Array)
        implements 1::""
        : (\.0 != []);

I<TODO.>

=head2 count (Array)

    ::MD::count::Array ::= function --> Integer_NN <-- (Array)
        implements 1::""
        : (topic -->^ FDN__Array_count);

I<TODO.>

=head2 elem (Array)

    ::MD::elem::Array ::= function --> Any <-- (Array, Integer_NN)
        implements 1::""
        requires (topic --> \@has_index)
        : (topic -->^ FDN__Array_elem);

I<TODO.>

=head2 has_index (Array)

    ::MD::has_index::Array ::= function --> Boolean <-- (Array, Integer_NN)
        implements 1::""
        : (topic -->^ FDN__Array_has_index);

I<TODO.  True if given array index exists.>

=head2 has (Array)

    ::MD::has::Array ::= function --> Boolean <-- (Array, Any)
        implements 1::""
        : (topic -->^ FDN__Array_has);

I<TODO.  True if given element value exists at any index.>

=head2 nest (Array)

    ::MD::nest::Array ::= function --> Array <-- (Array)
        implements 1::""
        requires (...)
        : (topic -->^ FDN__Array_nest);

I<TODO.>

=head2 unnest (Array)

    ::MD::unnest::Array ::= function --> Array <-- (Array)
        implements 1::""
        requires (...)
        : (topic -->^ FDN__Array_unnest);

I<TODO.>

=head2 any (Array)

    ::MD::any::Array ::= function --> Boolean <-- (Array, Primed_Func_Ref)
        implements 1::""
        : (topic -->^ FDN__Array_any);

I<TODO.>

=head2 where (Array)

    ::MD::where::Array ::= function --> Array <-- (Array, Primed_Func_Ref)
        implements 1::""
        : (topic -->^ FDN__Array_where);

I<TODO.>

=head2 map (Array)

    ::MD::map::Array ::= function --> Array <-- (Array, Primed_Func_Ref)
        implements 1::""
        : (topic -->^ FDN__Array_map);

I<TODO.>

=head2 reduce (Array)

    ::MD::reduce::Array ::= function --> Any <-- (Array, Primed_Func_Ref)
        implements 1::""
        : (topic -->^ FDN__Array_reduce);

I<TODO.>

=head2 first_index

    ::MD::first_index::Array ::= function --> Integer_NN <-- (Array)
        implements 1::""
        requires (?\.0)
        : (0);

I<TODO.>

=head2 last_index

    ::MD::last_index::Array ::= function --> Integer_NN <-- (Array)
        implements 1::""
        requires (?\.0)
        : (-- #\.0);

I<TODO.>

=head2 slice

    ::MD::slice::Array ::= function --> Array <-- (Array, Interval)
        implements 1::""
        : (topic -->^ FDN__Array_slice);

I<TODO.>

=head2 catenate (Array)

    ::MD::catenate::Array ::= function --> Array <-- (Array, Array)
        implements 1::""
        is associative identity ([])
        : (topic -->^ FDN__Array_catenate);

I<TODO.>

=head2 index_succ_all_matches (Array)

    ::MD::index_succ_all_matches::Array ::= function
        --> Integer_NN <-- (Array, Array)
        implements 1::""
        is commutative
        : (topic -->^ FDN__Array_index_succ_all_matches);

I<TODO.  While conceivably implementable at a higher level, make low level
for perceived efficiency.>

=head1 SETTY DATA TYPES

=head2 Setty

    ::MD::Setty ::= interface
        composes Homogeneous
        requires_implements {so,count,has,nest,unnest,any,where,map,reduce,...};

I<TODO.  For collections that make sure each element can only appear once.
Composed by: Set, Relation.>

=head1 SET DATA TYPES

=head2 Set_Inf Set

    ::MD::Set_Inf::"" ::= selection of Capsule
        where (Capsule_has_tag_asset( topic, \Set, \@1::_Asset ))
        default ({})
        composes Setty and_provides_its_default;

    ::MD::Set ::= alias of Set_Inf;

    ::MD::Set_Inf::_Asset ::= selection of Bag
        where (...);

I<TODO. Update 'where' to say quantity for each distinct member is 1,
using a Foundation function specific to that purpose.>

=head2 so (Set)

    ::MD::so::Set ::= function --> Boolean <-- (Set)
        implements 1::""
        : (\.0 != {});

I<TODO.>

=head2 count (Set)

    ::MD::count::Set ::= function --> Integer_NN <-- (Set)
        implements 1::""
        : (Capsule_asset(\.0) ->count);

I<TODO.>

=head2 has (Set)

    ::MD::has::Set ::= function --> Boolean <-- (Set, Any)
        implements 1::""
        : (Capsule_asset(\.0) has \.1);

I<TODO.>

=head2 nest (Set)

    ::MD::nest::Set ::= function --> Set <-- (Set)
        implements 1::""
        requires (...)
        : (select_Capsule(\Set, Capsule_asset(\.0) ->nest));

I<TODO.>

=head2 unnest (Set)

    ::MD::unnest::Set ::= function --> Set <-- (Set)
        implements 1::""
        requires (...)
        : (select_Capsule(\Set, Capsule_asset(\.0) ->unnest));

I<TODO.>

=head2 any (Set)

    ::MD::any::Set ::= function --> Boolean <-- (Set, Primed_Func_Ref)
        implements 1::""
        : (Capsule_asset(\.0) any \.1);

I<TODO.>

=head2 where (Set)

    ::MD::where::Set ::= function --> Set <-- (Set, Primed_Func_Ref)
        implements 1::""
        : (select_Capsule(\Set, Capsule_asset(\.0) where \.1));

I<TODO.>

=head2 map (Set)

    ::MD::map::Set ::= function --> Set <-- (Set, Primed_Func_Ref)
        implements 1::""
        : (select_Capsule(\Set, Capsule_asset(\.0) map \.1));

I<TODO.>

=head2 reduce (Set)

    ::MD::reduce::Set ::= function --> Any <-- (Set, Primed_Func_Ref)
        implements 1::""
        : (select_Capsule(\Set, Capsule_asset(\.0) reduce \.1));

I<TODO.>

=head1 BAG DATA TYPES

=head2 Bag_Inf Bag

    ::MD::Bag_Inf ::= selection where (topic -->^ FDN__isa_Bag_Inf)
        default (\+{})
        composes Homogeneous;

    ::MD::Bag ::= alias of Bag_Inf;

The selection contract C<Bag_Inf> represents the infinite Muldis D
Foundation type I<FDN__Bag_Inf>.  A C<Bag_Inf> value is ...

I<TODO.>

=head2 so (Bag)

    ::MD::so::Bag ::= function --> Boolean <-- (Bag)
        implements 1::""
        : (\.0 != \+{});

I<TODO.>

=head2 count (Bag)

    ::MD::count::Bag ::= function --> Integer_NN <-- (Bag)
        implements 1::""
        : (topic -->^ FDN__Bag_count);

I<TODO.>

=head2 has (Bag)

    ::MD::has::Bag ::= function --> Boolean <-- (Bag, Any)
        implements 1::""
        : (topic -->^ FDN__Bag_has);

I<TODO.>

=head2 nest (Bag)

    ::MD::nest::Bag ::= function --> Bag <-- (Bag)
        implements 1::""
        requires (...)
        : (topic -->^ FDN__Bag_nest);

I<TODO.>

=head2 unnest (Bag)

    ::MD::unnest::Bag ::= function --> Bag <-- (Bag)
        implements 1::""
        requires (...)
        : (topic -->^ FDN__Bag_unnest);

I<TODO.>

=head2 any (Bag)

    ::MD::any::Bag ::= function --> Boolean <-- (Bag, Primed_Func_Ref)
        implements 1::""
        : (topic -->^ FDN__Bag_any);

I<TODO.>

=head2 where (Bag)

    ::MD::where::Bag ::= function --> Bag <-- (Bag, Primed_Func_Ref)
        implements 1::""
        : (topic -->^ FDN__Bag_where);

I<TODO.>

=head2 map (Bag)

    ::MD::map::Bag ::= function --> Bag <-- (Bag, Primed_Func_Ref)
        implements 1::""
        : (topic -->^ FDN__Bag_map);

I<TODO.>

=head2 reduce (Bag)

    ::MD::reduce::Bag ::= function --> Any <-- (Bag, Primed_Func_Ref)
        implements 1::""
        : (topic -->^ FDN__Bag_reduce);

I<TODO.>

=head1 ATTRIBUTIVE DATA TYPES

=head2 Attributive

    ::MD::Attributive ::= interface
        requires_implements {has_any_attrs,degree,on,but,extend,has_attrs,has_just_attrs};

I<TODO.  For types that support attribute-name-based lookup of values;
for collections of name-value pairs where all names are distinct;
for typically heterogeneous collections.
Composed by: Tuple, Relation, Tuple_Bag.

=head2 Excuse::No_Such_Attr

    ::MD::Excuse::No_Such_Attr ::= constant (\@0) composes Excuse;

I<TODO.>

=head2 has_any_attrs ?^

    ::MD::has_any_attrs::"" ::= function virtual --> Boolean <-- (Attributive);

    ::MD::"?^" ::= alias of has_any_attrs;

I<TODO.>

=head2 is_nullary !?^

    ::MD::is_nullary ::= function negates has_any_attrs;

    ::MD::"!?^" ::= alias of is_nullary;

I<TODO.>

=head2 degree #^

    ::MD::degree::"" ::= function virtual --> Integral <-- (Attributive);

    ::MD::"#^" ::= alias of degree;

I<TODO.>

=head2 on ^ project

    ::MD::on::"" ::= function virtual
        --> Attributive <-- (Attributive, Attr_Names)
        requires (...);

    ::MD::"^"     ::= alias of on;
    ::MD::project ::= alias of on;

I<TODO.  Also, this is analagous to set intersect.>

=head2 from

    ::MD::from ::= function commutes on;

I<TODO.>

=head2 but -^ project_all_but

    ::MD::but::"" ::= function virtual
        --> Attributive <-- (Attributive, Attr_Names)
        requires (...);

    ::MD::"-^"            ::= alias of but;
    ::MD::project_all_but ::= alias of but;

I<TODO.  Also, this is analagous to set difference.>

=head2 extend +^

    ::MD::extend::"" ::= function virtual
        --> Attributive <-- (Attributive, Attributive)
        requires (...)
        is {associative,commutative};

    ::MD::"+^" ::= alias of extend;

I<TODO.  Also, this is analagous to set union (disjoint).>

I<Note: There is no version of 'extend' that takes a routine; one can just
use the above version plus an eg-tuple selector. In the case of relation
extend, one can do the aforementioned within a 'map' routine, for the
routine version; they can use join/cross-product for the static version.>

=head2 has_attrs ^?

    ::MD::has_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, Signature);

    ::MD::"^?" ::= alias of has_attrs;

I<TODO.>

=head2 has_just_attrs ^?=

    ::MD::has_just_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, Signature);

    ::MD::"^?=" ::= alias of has_just_attrs;

I<TODO.>

=head1 TUPLE DATA TYPES

=head2 Tuple_Inf Tuple

    ::MD::Tuple_Inf ::= selection where (topic -->^ FDN__isa_Tuple_Inf)
        default (\%())
        composes {Accessible and_provides_its_default,
            Attributive and_provides_its_default};

    ::MD::Tuple ::= alias of Tuple_Inf;

The selection contract C<Tuple_Inf> represents the infinite Muldis D
Foundation type I<FDN__Tuple_Inf>.  A C<Tuple_Inf> value is ...

I<TODO.>

=head2 has_any_attrs (Tuple)

    ::MD::has_any_attrs::Tuple ::= function --> Boolean <-- (Tuple)
        implements 1::""
        : (\.0 != \%());

I<TODO.>

=head2 degree (Tuple)

    ::MD::degree::Tuple ::= function --> Integer_NN <-- (Tuple)
        implements 1::""
        : (topic -->^ FDN__Tuple_degree);

I<TODO.>

=head2 attr . (Tuple)

    ::MD::attr ::= function --> Any <-- (Tuple, Attr_Name)
        requires (topic --> \@has_attr)
        : (topic -->^ FDN__Tuple_attr);

    ::MD::"."::Tuple ::= function --> Any <-- (Tuple, Attr_Name)
        implements 1::""
        requires (topic --> \@has_attr)
        : (topic --> \@attr);

I<TODO.>

=head2 has_attr .? (Tuple)

    ::MD::has_attr ::= function --> Boolean <-- (Tuple, Attr_Name)
        : (topic -->^ FDN__Tuple_has_attr);

    ::MD::".?"::Tuple ::= function --> Boolean <-- (Tuple, Attr_Name)
        implements 1::""
        : (topic --> \@has_attr);

I<TODO.>

=head2 attr_or_excuse .! (Tuple)

    ::MD::attr_or_excuse ::= function --> Any <-- (Tuple, Attr_Name)
        : (topic --> \@has_attr ?? topic --> \@attr !! Excuse::No_Such_Attr());

    ::MD::".!"::Tuple ::= function --> Any <-- (Tuple, Attr_Name)
        implements 1::""
        : (topic --> \@attr_or_excuse);

I<TODO.>

=head2 on (Tuple)

    ::MD::on::Tuple ::= function --> Tuple <-- (Tuple, Attr_Names)
        implements 1::""
        requires (...)
        : (topic -->^ FDN__Tuple_on);

I<TODO.>

=head2 but (Tuple)

    ::MD::but::Tuple ::= function --> Tuple <-- (Tuple, Attr_Names)
        implements 1::""
        requires (...)
        : (topic -->^ FDN__Tuple_but);

I<TODO.>

=head2 extend (Tuple)

    ::MD::extend::Tuple ::= function --> Tuple <-- (Tuple, Tuple)
        implements 1::""
        requires (...)
        is {associative,commutative} identity (\%())
        : (topic -->^ FDN__Tuple_extend);

I<TODO.>

=head2 has_attrs (Tuple)

    ::MD::has_attrs::Tuple ::= function --> Boolean <-- (Tuple, Signature)
        implements 1::""
        : (...);

I<TODO.>

=head2 has_just_attrs (Tuple)

    ::MD::has_just_attrs::Tuple ::= function --> Boolean <-- (Tuple, Signature)
        implements 1::""
        : (...);

I<TODO.>

=head2 any_attrs

    ::MD::any_attrs ::= function --> Boolean <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_any_attrs);

I<TODO.>

=head2 none_of_attrs

    ::MD::none_of_attrs ::= function negates any_attrs;

I<TODO.>

=head2 all_attrs

    ::MD::all_attrs ::= function --> Boolean <-- (Tuple, Primed_Func_Ref)
        : (\.0 none_of_attrs negated_func(of : \.1, passing_args : \@(0)));

I<TODO.>

=head2 attrs_where

    ::MD::attrs_where ::= function --> Tuple <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_attrs_where);

I<TODO.>

=head2 attrs_map

    ::MD::attrs_map ::= function --> Tuple <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_attrs_map);

I<TODO.>

=head2 attrs_reduce

    ::MD::attrs_reduce ::= function --> Any <-- (Tuple, Primed_Func_Ref)
        : (topic -->^ FDN__Tuple_attrs_reduce);

I<TODO.>

=head1 RELATION DATA TYPES

=head2 Relation_Inf Relation

    ::MD::Relation_Inf::"" ::= selection of Capsule
        where (Capsule_has_tag_asset( topic, \Relation, \@1::_Asset ))
        default (\?%{})
        composes {Setty, Attributive};

    ::MD::Relation ::= alias of Relation_Inf;

    ::MD::Relation_Inf::_Asset ::= selection of Tuple_Bag
        where (...);

I<TODO.  See also definition of Set in terms of Bag, which Relation mirrors.>

=head1 TUPLE-BAG DATA TYPES

=head2 Tuple_Bag_Inf Tuple_Bag

    ::MD::Tuple_Bag_Inf::"" ::= selection of Capsule
        where (Capsule_has_tag_asset( topic, \Tuple_Bag, \@1::_Asset ))
        default (\+%{})
        composes {Homogeneous, Attributive};

    ::MD::Tuple_Bag ::= alias of Tuple_Bag_Inf;

    ::MD::Tuple_Bag_Inf::_Asset ::= selection of Tuple
        where (...);

I<TODO.>

=head1 CAPSULE DATA TYPES

=head2 Capsule

    ::MD::Capsule::"" ::= selection where (topic -->^ FDN__isa_Capsule)
        default (select_Capsule(False, False));

The selection contract C<Capsule> represents the infinite Muldis D
Foundation type I<FDN__Capsule>.  An C<Capsule> value is ...

I<TODO.  We will want a literal syntax for Capsule values, and probably
more tersely named tag/asset operator names.>

Given that almost every selection contract is a subset of
C<Capsule>, the latter intentionally does not compose any interface
contracts, and only has the minimal set of its own operators, so to
minimize interference with other types' interfaces.

=head2 select_Capsule

    ::MD::select_Capsule ::= function --> Capsule <-- (Any, Any)
        : (topic -->^ FDN__Capsule_select);

I<TODO.>

=head2 Capsule_tag

    ::MD::Capsule_tag ::= function --> Any <-- (Capsule)
        : (topic -->^ FDN__Capsule_tag);

I<TODO.>

=head2 Capsule_asset

    ::MD::Capsule_asset ::= function --> Any <-- (Capsule)
        : (topic -->^ FDN__Capsule_asset);

I<TODO.>

=head2 Capsule_has_tag_asset

    ::MD::Capsule_has_tag_asset ::= function
        --> Boolean <-- (Capsule, Any, Reference)
        : (Capsule_tag(\.0) = \.1 and (Capsule_asset(\.0) isa \.2));

I<TODO.>

=head1 EXTERNAL DATA TYPES

=head2 External

    ::MD::External ::= selection where (topic -->^ FDN__isa_External)
        default (-->^ FDN__default_External);

The selection contract C<External> represents the infinite Muldis D
Foundation type I<FDN__External>.  An C<External> value is ...

I<TODO.>

=head1 SOURCE CODE BEHAVIOURAL DATA TYPES

I<TODO.>

=head2 Source_Code::Package_List

    ::MD::Source_Code::Package_List::"" ::= selection of Capsule
        where (Capsule_has_tag_asset( topic, \Package_List, \@1::_Asset ))
        default (select_Capsule( \Package_List, [] ));

    ::MD::Source_Code::Package_List::_Asset ::= selection of Array
        where (topic all_isa (selection of {Package, Decoration} default Package()));

I<TODO.>

=head2 Source_Code::Package

    ::MD::Source_Code::Package::"" ::= selection of Capsule
        where (Capsule_has_tag_asset( topic, \Package, \@1::_Asset ))
        default (select_Capsule( \Package, 1::_Asset() ));

    ::MD::Source_Code::Package::_Asset ::= selection of Tuple
        where (...);

I<TODO.>

=head2 Source_Code::negated_func

    ::MD::Source_Code::negated_func ::= function --> Primed_Func_Ref
        <-- (of : Primed_Func_Ref, passing_args : Attr_Names)
    : (
        (function : (
            not(
                (\.of.args +^ (topic ^ \.passing_args)) --> (\.of.func)
            )
        )) assuming topic
    );

I<TODO.  This expects the original function is from Tuple to Boolean.>

=head1 SOURCE CODE ANNOTATION DATA TYPES

I<TODO.>

=head2 Source_Code::Annotation

    ::MD::Source_Code::Annotation::"" ::= interface;

I<TODO.>

=head2 Source_Code::Annotation::Comment

    ::MD::Source_Code::Annotation::Comment ::= selection of Capsule
        where (Capsule_has_tag_asset( topic, \Comment, \@Text ))
        default (\~?'')
        composes Annotation;

I<TODO.>

=head1 SOURCE CODE DECORATION DATA TYPES

I<TODO.  Generally speaking, all Decoraction types are declared by a
package that is not Muldis_D, such as in the Muldis_D::Plain_Text package.>

I<TODO:  The decoration data types may loosely resemble template defs so
that decorations don't necessarily have to be attached to all
behavioral/annotation nodes they are conceptually adjacent / apply to but
rather can be in some nearby parent context and refer to behavioral/etc
nodes by name.>

=head2 Source_Code::Decoration

    ::MD::Source_Code::Decoration::"" ::= interface;

I<TODO.>

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::See_Also> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright © 2002-2015, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
