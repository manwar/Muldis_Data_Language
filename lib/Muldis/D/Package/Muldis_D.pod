=pod

=encoding utf8

=head1 NAME

Muldis::D::Package::Muldis_D -
Muldis D core data types and operators

=head1 VERSION

This document is Muldis::D::Package::Muldis_D version 0.200.1.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document
before you read this one, which provides subservient details.

=head1 SYNOPSIS

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script ASCII;
    package
    {
        identity My_App ::= My_App:"http://mycorp.com":"0";
        uses
        {
            MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        };
        materials
        {
            floating {::My_App, ::MD};

            `TODO: Put example routines etc here.`

        };
    };

=head1 DESCRIPTION

This document defines the Muldis D Plain Text package
C<Muldis_D:"http://muldis.com":"0.200.1"> which provides the common core
system-defined data types and operators that regular users of the language
would employ directly in their applications and schemas.

This document I<also> defines the Muldis D Plain Text package
C<Muldis_D::Aliases:"http://muldis.com":"0.200.1"> which adds trans-ASCII
Unicode synonyms to C<Muldis_D> package entities.

=head1 PACKAGES

From one source:

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script ASCII;
    package
    {
        identity MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        materials
        {
            floating {::MD, ::MD::Source_Code};
            ...
        };
    };

From a separate source:

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1";
    script Unicode:8.0:UTF-8:canon;
    package
    {
        identity MDA ::= Muldis_D::Aliases:"http://muldis.com":"0.200.1";
        uses
        {
            MD ::= Muldis_D:"http://muldis.com":"0.200.1";
        };
        materials
        {
            floating {::MD, ::MDA};
            ...
        };
    };

=head1 MAXIMAL AND MINIMAL DATA TYPES

=head2 Anything Any

    ::MD::Anything ::= selection default False;

    ::MD::Any ::= alias of Anything;

The selection contract C<Anything> represents the infinite I<universal
type>, which is the maximal data type of the entire Muldis D type system
and consists of all values which can possibly exist.  It also represents
the infinite Muldis D Foundation type I<FDN__Anything>.  Its default value
is C<False>.  Other programming languages may name their corresponding
types I<Any> or I<Object> or I<Anything>.

=head2 Nothing

    ::MD::Nothing ::= selection of {};

The selection contract C<Nothing> represents the finite I<empty type>,
which is the minimal data type of the entire Muldis D type system and
consists of exactly zero values.  It can not have any default value.

=head2 same =

    ::MD::same ::= function --> Boolean <-- (Any, Any)
        is commutative
        : (topic -->^ FDN__same);

    ::MD::"=" ::= alias of same;

The function C<same> results in C<True> iff its 2 conceptual arguments are
exactly the same value, and C<False> otherwise.  Other programming
languages may name their corresponding operators I<==> or I<===>.

=head2 not_same != ≠

    ::MD::not_same ::= function negates same
        is commutative;

    ::MD::"!=" ::= alias of not_same;
    ::MDA::"≠" ::= alias of not_same;

The function C<not_same> results in C<False> iff its 2 conceptual arguments
are exactly the same value, and C<True> otherwise.

=head1 ORDERABLE DATA TYPES

=head2 Orderable

    ::MD::Orderable ::= interface
        requires_implements in_order;

I<TODO.>

=head2 in_order

    ::MD::in_order::"" ::= function virtual
        --> Boolean <-- (Orderable, Orderable);

I<TODO.>

=head2 before <

    ::MD::before ::= function commutes after;

    ::MD::"<" ::= alias of before;

I<TODO.>

=head2 after >

    ::MD::after ::= function negates before_or_same;

    ::MD::">" ::= alias of after;

I<TODO.>

=head2 before_or_same <= ≤

    ::MD::before_or_same ::= alias of in_order;

    ::MD::"<=" ::= alias of before_or_same;
    ::MDA::"≤" ::= alias of before_or_same;

I<TODO.>

=head2 after_or_same >= ≥

    ::MD::after_or_same ::= function commutes before_or_same;

    ::MD::">=" ::= alias of after_or_same;
    ::MDA::"≥" ::= alias of after_or_same;

I<TODO.>

=head2 min

    ::MD::min ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity \(\"+Inf")
        : (topic --> \@in_order ?? \\0 !! \\1);

I<TODO.>

=head2 max

    ::MD::max ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity \(\"-Inf")
        : (topic --> \@in_order ?? \\1 !! \\0);

I<TODO.>

=head2 minmax

    ::MD::minmax ::= function
        --> (Orderable, Orderable) <-- (Orderable, Orderable)
        is commutative
        : (topic --> \@in_order ?? topic !! \(\\1, \\0));

I<TODO.>

=head1 ENUMERABLE DATA TYPES

=head2 Enumerable

    ::MD::Enumerable ::= interface
        composes Orderable and_provides_its_default
        requires_implements {in_order,pred,succ};

I<TODO.>

=head2 pred

    ::MD::pred::"" ::= function virtual --> Enumerable <-- (Enumerable);

I<TODO.>

=head2 succ

    ::MD::succ::"" ::= function virtual --> Enumerable <-- (Enumerable);

I<TODO.>

=head1 BOOLABLE DATA TYPES

=head2 Boolable

    ::MD::Boolable ::= interface requires_implements so;

I<TODO.>

=head2 so ?

    ::MD::so::"" ::= function virtual --> Boolean <-- (Boolable);

    ::MD::"?" ::= alias of so;

I<TODO.>

=head2 not_so !?

    ::MD::not_so ::= function negates so;

    ::MD::"!?" ::= alias of not_so;

I<TODO.>

=head1 BOOLEAN DATA TYPES

=head2 Boolean Bool

    ::MD::Boolean::"" ::= selection where topic -->^ FDN__isa_Boolean
        default False
        composes {Enumerable and_provides_its_default,
            Boolable and_provides_its_default};

    ::MD::Bool ::= alias of Boolean;

The selection contract C<Boolean> represents the finite Muldis D
Foundation type I<FDN__Boolean>.  A C<Boolean> value is a general purpose
2-valued logic boolean, or specifically it is one of the 2 values C<False>
and C<True>.  Its default value is C<False>.

I<TODO.>

Examples:

    True

    False

=head2 in_order (Boolean)

    ::MD::in_order::Boolean ::= function --> Boolean <-- (Boolean, Boolean)
        implements 1::""
        : (!\\0 or \\1);

I<TODO.>

=head2 pred (Boolean)

    ::MD::pred::Boolean ::= function --> {False, "-Inf"} <-- (Boolean)
        implements 1::""
        : (\\0 ?? False !! \(\"-Inf"));

I<TODO.>

=head2 succ (Boolean)

    ::MD::succ::Boolean ::= function --> {True, "+Inf"} <-- (Boolean)
        implements 1::""
        : (!\\0 ?? True !! \(\"+Inf"));

I<TODO.>

=head2 False ⊥

    ::MD::False ::= constant False;

    ::MDA::"⊥" ::= alias of False;

I<TODO.>

=head2 True ⊤

    ::MD::True ::= constant True;

    ::MDA::"⊤" ::= alias of True;

I<TODO.>

=head2 so (Boolean)

    ::MD::so::Boolean ::= function --> Boolean <-- (Boolean)
        implements 1::""
        : \\0;

I<TODO.>

=head2 not ! ¬

    ::MD::not ::= function negates so::Boolean;

    ::MD::"!"  ::= alias of not;
    ::MDA::"¬" ::= alias of not;

I<TODO.>

=head2 and all every ∧

    ::MD::and ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity True
        : (\\0 ?? \\1 !! False);

    ::MD::all   ::= alias of and;
    ::MD::every ::= alias of and;
    ::MDA::"∧"  ::= alias of and;

I<TODO.>

=head2 nand not_and ⊼ ↑

    ::MD::nand ::= function negates and
        is commutative;

    ::MD::not_and ::= alias of nand;
    ::MDA::"⊼"    ::= alias of nand;
    ::MDA::"↑"    ::= alias of nand;

I<TODO.>

=head2 or any some ∨

    ::MD::or ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity False
        : (\\0 ?? True !! \\1);

    ::MD::any  ::= alias of or;
    ::MD::some ::= alias of or;
    ::MDA::"∨" ::= alias of or;

I<TODO.>

=head2 nor not_or ⊽ ↓

    ::MD::nor ::= function negates or
        is commutative;

    ::MD::not_or ::= alias of nor;
    ::MDA::"⊽"   ::= alias of nor;
    ::MDA::"↓"   ::= alias of nor;

I<TODO.>

=head2 xnor iff ↔

    ::MD::xnor ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative} identity True
        : (topic --> \@"=");

    ::MD::iff  ::= alias of xnor;
    ::MDA::"↔" ::= alias of xnor;

I<TODO.>

=head2 xor ⊻ ↮

    ::MD::xor ::= function negates xnor
        is {associative,commutative} identity False;

    ::MDA::"⊻" ::= alias of xor;
    ::MDA::"↮" ::= alias of xor;

I<TODO.>

=head2 imp implies →

    ::MD::imp ::= function --> Boolean <-- (Boolean, Boolean)
        : (\\0 ?? \\1 !! True);

    ::MD::implies ::= alias of imp;
    ::MDA::"→"    ::= alias of imp;

I<TODO.>

=head2 nimp not_implies ↛

    ::MD::nimp ::= function negates imp;

    ::MD::not_implies ::= alias of nimp;
    ::MDA::"↛"        ::= alias of nimp;

I<TODO.>

=head2 if ←

    ::MD::if ::= function commutes imp;

    ::MDA::"←" ::= alias of if;

I<TODO.>

=head2 nif not_if ↚

    ::MD::nif ::= function commutes nimp;

    ::MD::not_if ::= alias of nif;
    ::MDA::"↚"   ::= alias of nif;

I<TODO.>

=head1 NUMERIC DATA TYPES

=head2 Numeric

    ::MD::Numeric ::= interface
        composes Boolable
        requires_implements {so,opposite,reciprocal,modulus,
            plus,minus,frac_divide,whole_divide,...};

I<TODO.>

=head2 Round_Meth

    ::MD::Round_Meth::"" ::= selection
        union {1::Down,1::Up,1::To_Zero,1::To_Inf
            ,1::Half_Down,1::Half_Up,1::Half_To_Zero,1::Half_To_Inf
            ,1::Half_Even}
        default 1::To_Zero();

    ::MD::Round_Meth::Down         ::= constant \Round_Down;
    ::MD::Round_Meth::Up           ::= constant \Round_Up;
    ::MD::Round_Meth::To_Zero      ::= constant \Round_To_Zero;
    ::MD::Round_Meth::To_Inf       ::= constant \Round_To_Inf;
    ::MD::Round_Meth::Half_Down    ::= constant \Round_Half_Down;
    ::MD::Round_Meth::Half_Up      ::= constant \Round_Half_Up;
    ::MD::Round_Meth::Half_To_Zero ::= constant \Round_Half_To_Zero;
    ::MD::Round_Meth::Half_To_Inf  ::= constant \Round_Half_To_Inf;
    ::MD::Round_Meth::Half_Even    ::= constant \Round_Half_Even;

I<TODO.  Also, review most appropriate values for the constants.>

=head2 so (Numeric)

    ::MD::so::Numeric ::= function virtual --> Boolean <-- (Numeric)
        implements 1::"";

I<TODO.>

=head2 is_zero

    ::MD::is_zero ::= function negates so::Numeric;

I<TODO.>

=head2 opposite

    ::MD::opposite::"" ::= function virtual --> Numeric <-- (Numeric);

    ::MD::additive_inverse ::= alias of opposite;

I<TODO.>

=head2 reciprocal

    ::MD::reciprocal::"" ::= function virtual --> Numeric <-- (Numeric)
        requires (?\\0);

    ::MD::multiplicative_inverse ::= alias of reciprocal;

I<TODO.>

=head2 modulus abs

    ::MD::modulus::"" ::= function virtual --> Numeric <-- (Numeric);

    ::MD::abs ::= alias of modulus;

I<TODO.>

=head2 plus +

    ::MD::plus::"" ::= function virtual --> Numeric <-- (Numeric, Numeric);

    ::MD::"+" ::= alias of plus;

I<TODO.>

=head2 minus

    ::MD::minus::"" ::= function virtual --> Numeric <-- (Numeric, Numeric);

I<TODO.>

=head2 -

    ::MD::"-" ::= function --> Numeric <-- {(Numeric), (Numeric, Numeric)}
        : (topic --> (#^>topic = 1 ?? \@opposite !! \@minus));

I<TODO.>

=head2 modulus_minus abs_minus |-|

    ::MD::modulus_minus ::= function --> Numeric <-- (Numeric, Numeric)
        : (modulus topic --> \@minus);

    ::MD::abs_minus ::= alias of modulus_minus;
    ::MD::"|-|"     ::= alias of modulus_minus;

I<TODO.>

=head2 times *

    ::MD::times::"" ::= function virtual --> Numeric <-- (Numeric, Numeric);

    ::MD::"*" ::= alias of times;

I<TODO.>

=head2 frac_divide /

    ::MD::frac_divide::"" ::= function virtual
        --> Numeric <-- (Numeric, Numeric)
        requires (?\\1);

    ::MD::"/" ::= alias of frac_divide;

I<TODO.>

=head2 whole_divide div

    ::MD::whole_divide::"" ::= function virtual
        --> Numeric <-- (Numeric, Numeric, Round_Meth)
        requires (?\\1);

    ::MD::div ::= alias of whole_divide;

I<TODO.>

=head2 modulo mod

    ::MD::modulo::"" ::= function
        --> Numeric <-- (Numeric, Numeric, Round_Meth)
        requires (?\\1)
        : (\\0 - (\\1 * div(*topic)));

    ::MD::mod ::= alias of modulo;

I<TODO.>

=head2 divide_and_modulo

    ::MD::divide_and_modulo::"" ::= function
        --> (Numeric, Numeric) <-- (Numeric, Numeric, Round_Meth)
        requires (?\\1)
        : (\(div(*topic), mod(*topic)));

I<TODO.>

=head1 INTEGRAL DATA TYPES

=head2 Integral

    ::MD::Integral ::= interface
        composes {Enumerable, Numeric and_provides_its_default}
        requires_implements {in_order,pred,succ,so,...};

I<TODO.  Also, do something about the unimplemented Numeric operators.>

=head1 INTEGER DATA TYPES

=head2 Integer_Inf Integer Int

    ::MD::Integer_Inf ::= selection where topic -->^ FDN__isa_Integer_Inf
        default 0
        composes Integral and_provides_its_default;

    ::MD::Integer ::= alias of Integer_Inf;
    ::MD::Int     ::= alias of Integer_Inf;

The selection contract C<Integer_Inf> represents the infinite Muldis D
Foundation type I<FDN__Integer_Inf>.  An C<Integer_Inf> value is a general
purpose integer exact numeric.  Its default value is C<0>.  Other
programming languages may name their corresponding types I<BigInt>.

I<TODO.  Also, do something about the unimplemented Numeric operators.>

Examples:

    42

    0

    \-3

    \+'-3' '50_897'

    0d39

    0xDEADBEEF

    0o644

    0b11001001

=head2 in_order (Integer)

    ::MD::in_order::Integer ::= function --> Boolean <-- (Integer, Integer)
        implements 1::""
        : (topic -->^ FDN__Integers_in_order);

I<TODO.>

=head2 pred (Integer)

    ::MD::pred::Integer ::= function --> Integer <-- (Integer)
        implements 1::""
        : (\\0 - 1);

I<TODO.>

=head2 succ (Integer)

    ::MD::succ::Integer ::= function --> Integer <-- (Integer)
        implements 1::""
        : (\\0 + 1);

I<TODO.>

=head2 so (Integer)

    ::MD::so::Integer ::= function --> Boolean <-- (Integer)
        implements 1::""
        : (\\0 != 0);

I<TODO.>

=head1 ACCESSIBLE DATA TYPES

=head2 Accessible

    ::MD::Accessible ::= interface
        requires_implements {item,has_item};

I<TODO.>

=head2 item .

    ::MD::item::"" ::= function virtual --> Any <-- (Accessible, Any)
        requires (topic --> \@".?");

    ::MD::"." ::= alias of item;

I<TODO.>

=head2 has_item .?

    ::MD::has_item::"" ::= function virtual --> Boolean <-- (Accessible, Any);

    ::MD::".?" ::= alias of has_item;

I<TODO.>

=head2 item_or_void .!

    ::MD::item_or_void ::= function --> Any <-- (Accessible, Any)
        : (topic --> \@".?" ?? topic --> \@"." !! \(\Void));

    ::MD::".!" ::= alias of item_or_void;

I<TODO.>

=head1 COLLECTIVE DATA TYPES

=head2 Collective

    ::MD::Collective::"" ::= interface
        composes Boolable
        requires_implements {so,count,has,group,ungroup,where,map,reduce,...};

I<TODO.>

=head2 so (Collective)

    ::MD::so::Collective ::= function virtual --> Boolean <-- (Collective)
        implements 1::"";

I<TODO.>

=head2 is_empty

    ::MD::is_empty ::= function negates so::Collective;

I<TODO.>

=head2 count cardinality #

    ::MD::count::"" ::= function virtual --> Integral <-- (Collective);

    ::MD::cardinality ::= alias of count;
    ::MD::"#"         ::= alias of count;

I<TODO.>

=head2 has ∋

    ::MD::has::"" ::= function virtual --> Boolean <-- (Collective, Any);

    ::MDA::"∋" ::= alias of has;

I<TODO.>

=head2 not_has ∌

    ::MD::not_has ::= function negates has;

    ::MDA::"∌" ::= alias of not_has;

I<TODO.>

=head2 in ∈

    ::MD::in ::= function commutes has;

    ::MDA::"∈" ::= alias of in;

I<TODO.>

=head2 not_in ∉

    ::MD::not_in ::= function commutes not_has;

    ::MDA::"∉" ::= alias of not_in;

I<TODO.>

=head2 group

    ::MD::group::"" ::= function virtual --> Collective <-- (Collective)
        requires (...);

I<TODO.>

=head2 ungroup

    ::MD::ungroup::"" ::= function virtual --> Collective <-- (Collective)
        requires (...);

I<TODO.>

=head2 where

    ::MD::where::"" ::= function virtual
        --> Collective <-- (Collective, SC_Primed_Func_Ref);

I<TODO.>

=head2 map

    ::MD::map::"" ::= function virtual
        --> Collective <-- (Collective, SC_Primed_Func_Ref);

I<TODO.>

=head2 reduce

    ::MD::reduce::"" ::= function virtual
        --> Collective <-- (Collective, SC_Primed_Func_Ref);

I<TODO.>

=head1 ARRAYISH DATA TYPES

=head2 Arrayish

    ::MD::Arrayish ::= interface
        composes {Accessible,...}
        requires_implements {item,has_item,...};

I<TODO.>

=head1 ARRAY DATA TYPES

=head2 Array_Inf Array

    ::MD::Array_Inf ::= selection where topic -->^ FDN__isa_Array_Inf
        default []
        composes Arrayish and_provides_its_default;

    ::MD::Array ::= alias of Array_Inf;

The selection contract C<Array_Inf> represents the infinite Muldis D
Foundation type I<FDN__Array_Inf>.  An C<Array_Inf> value is ...

I<TODO.>

=head2 item (Array)

    ::MD::item::Array ::= function --> Any <-- (Array, Integer)
        implements 1::""
        requires (topic --> \@".?")
        : (topic -->^ FDN__Array_elem);

I<TODO.>

=head2 has_item (Array)

    ::MD::has_item::Array ::= function --> Boolean <-- (Array, Integer)
        implements 1::""
        : (topic -->^ FDN__Array_has_elem);

I<TODO.>

=head1 BAG DATA TYPES

=head2 Bag_Inf Bag

    ::MD::Bag_Inf ::= selection where topic -->^ FDN__isa_Bag_Inf
        default \+{}
        composes Baggy and_provides_its_default;

    ::MD::Bag ::= alias of Bag_Inf;

The selection contract C<Bag_Inf> represents the infinite Muldis D
Foundation type I<FDN__Bag_Inf>.  A C<Bag_Inf> value is ...

I<TODO.>

=head1 STRUCTURE DATA TYPES

=head2 Structure_Inf Structure

    ::MD::Structure_Inf ::= selection where topic -->^ FDN__isa_Structure_Inf
        default \();

    ::MD::Structure ::= alias of Structure_Inf;

The selection contract C<Structure_Inf> represents the infinite Muldis D
Foundation type I<FDN__Structure_Inf>.  A C<Structure_Inf> value is ...

I<TODO.>

Given that almost every selection contract is a subset of
C<Structure_Inf>, the latter intentionally does not compose any interface
contracts, and only has the minimal set of its own operators, so to
minimize interference with other types' interfaces.

=head2 has_any_fields ?^>

    ::MD::has_any_fields ::= function --> Boolean <-- (Structure)
        : (topic != \());

    ::MD::"?^>" ::= alias of has_any_fields;

I<TODO.>

=head2 Structure_is_nullary !?^>

    ::MD::Structure_is_nullary ::= function negates has_any_fields;

    ::MD::"!?^>" ::= alias of Structure_is_nullary;

I<TODO.>

=head2 Structure_degree #^>

    ::MD::Structure_degree ::= function --> Integer <-- (Structure)
        : (topic -->^ FDN__Structure_degree);

    ::MD::"#^>" ::= alias of Structure_degree;

I<TODO.>

=head2 field .>

    ::MD::field ::= function --> Any <-- (Structure, SC_Field_Name)
        : (topic -->^ FDN__Structure_field);

    ::MD::".>" ::= alias of field;

I<TODO.>

=head2 has_field .>?

    ::MD::has_field ::= function --> Boolean <-- (Structure, SC_Field_Name)
        : (topic -->^ FDN__Structure_has_field);

    ::MD::".>?" ::= alias of has_field;

I<TODO.>

=head2 field_or_void .>!

    ::MD::field_or_void ::= function --> Any <-- (Structure, SC_Field_Name)
        : (topic --> \@".>?" ?? topic --> \@".>" !! \(\Void));

    ::MD::".>!" ::= alias of field_or_void;

I<TODO.>

=head2 on_fields ^>

    ::MD::on_fields ::= function --> Structure <-- (Structure, SC_Field_Names)
        requires (...)
        : (topic -->^ FDN__Structure_on_fields);

    ::MD::"^>" ::= alias of on_fields;

I<TODO.>

=head2 but_fields -^>

    ::MD::but_fields ::= function --> Structure <-- (Structure, SC_Field_Names)
        requires (...)
        : (topic -->^ FDN__Structure_but_fields);

    ::MD::"-^>" ::= alias of but_fields;

I<TODO.>

=head2 Structure_extend +^>

    ::MD::Structure_extend ::= function --> Structure <-- (Structure, Structure)
        requires (...)
        is {associative,commutative} identity \()
        : (topic -->^ FDN__Structure_extend);

    ::MD::"+^>" ::= alias of Structure_extend;

I<TODO.>

=head2 has_fields ^>?

    ::MD::has_fields ::= function --> Boolean <-- (Structure, SC_Signature)
        : (...);

    ::MD::"^>?" ::= alias of has_fields;

I<TODO.>

=head2 has_just_fields ^>?=

    ::MD::has_just_fields ::= function --> Boolean <-- (Structure, SC_Signature)
        : (...);

    ::MD::"^>?=" ::= alias of has_just_fields;

I<TODO.>

=head1 ATTRIBUTIVE DATA TYPES

=head2 Attributive

    ::MD::Attributive ::= interface
        requires_implements {has_any_attrs,degree,on,but,extend,has_attrs,has_just_attrs};

I<TODO.>

=head2 has_any_attrs ?^

    ::MD::has_any_attrs::"" ::= function virtual --> Boolean <-- (Attributive);

    ::MD::"?^" ::= alias of has_any_attrs;

I<TODO.>

=head2 is_nullary !?^

    ::MD::is_nullary ::= function negates has_any_attrs;

    ::MD::"!?^" ::= alias of is_nullary;

I<TODO.>

=head2 degree #^

    ::MD::degree::"" ::= function virtual --> Integral <-- (Attributive);

    ::MD::"#^" ::= alias of degree;

I<TODO.>

=head2 on ^ project

    ::MD::on::"" ::= function virtual
        --> Attributive <-- (Attributive, SC_Field_Names)
        requires (...);

    ::MD::"^"     ::= alias of on;
    ::MD::project ::= alias of on;

I<TODO.  Also, this is analagous to set intersect.>

=head2 but -^ project_all_but

    ::MD::but::"" ::= function virtual
        --> Attributive <-- (Attributive, SC_Field_Names)
        requires (...);

    ::MD::"-^"            ::= alias of but;
    ::MD::project_all_but ::= alias of but;

I<TODO.  Also, this is analagous to set difference.>

=head2 extend +^

    ::MD::extend::"" ::= function virtual
        --> Attributive <-- (Attributive, Attributive)
        requires (...)
        is {associative,commutative};

    ::MD::"+^" ::= alias of extend;

I<TODO.  Also, this is analagous to set union (disjoint).>

I<Note: There is no version of 'extend' that takes a routine; one can just
use the above version plus an eg-tuple selector. In the case of relation
extend, one can do the aforementioned within a 'map' routine, for the
routine version; they can use join/cross-product for the static version.>

=head2 has_attrs ^?

    ::MD::has_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, SC_Signature);

    ::MD::"^?" ::= alias of has_attrs;

I<TODO.>

=head2 has_just_attrs ^?=

    ::MD::has_just_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, SC_Signature);

    ::MD::"^?=" ::= alias of has_just_attrs;

I<TODO.>

=head1 TUPLE DATA TYPES

=head2 Tuple_Inf Tuple

    ::MD::Tuple_Inf ::= selection of Structure
        where topic has_just_fields \(constant \Tuple, \@Structure)
        default \%()
        composes {Accessible and_provides_its_default,
            Attributive and_provides_its_default};

    ::MD::Tuple ::= alias of Tuple_Inf;

I<TODO.>

=head2 has_any_attrs (Tuple)

    ::MD::has_any_attrs::Tuple ::= function --> Boolean <-- (Tuple)
        implements 1::""
        : (topic != \%());

I<TODO.>

=head2 degree (Tuple)

    ::MD::degree::Tuple ::= function --> Integer <-- (Tuple)
        implements 1::""
        : (#^>(\\0 .> \1));

I<TODO.>

=head2 item (Tuple)

    ::MD::item::Tuple ::= function --> Any <-- (Tuple, SC_Field_Name)
        implements 1::""
        requires (topic --> \@".?")
        : (\\0 .> \1 .> \\1);

I<TODO.>

=head2 has_item (Tuple)

    ::MD::has_item::Tuple ::= function --> Boolean <-- (Tuple, SC_Field_Name)
        implements 1::""
        : (\\0 .> \1 .>? \\1);

I<TODO.>

=head2 on (Tuple)

    ::MD::on::Tuple ::= function --> Tuple <-- (Tuple, SC_Field_Names)
        implements 1::""
        requires (...)
        : (\(\Tuple, \\0 .> \1 ^> \\1));

I<TODO.>

=head2 but (Tuple)

    ::MD::but::Tuple ::= function --> Tuple <-- (Tuple, SC_Field_Names)
        implements 1::""
        requires (...)
        : (\(\Tuple, \\0 .> \1 -^> \\1));

I<TODO.>

=head2 extend (Tuple)

    ::MD::extend::Tuple ::= function --> Tuple <-- (Tuple, Tuple)
        implements 1::""
        requires (...)
        is {associative,commutative} identity \%()
        : (\(\Tuple, (\\0 .> \1) +^> (\\1 .> \1)));

I<TODO.>

=head2 has_attrs (Tuple)

    ::MD::has_attrs::Tuple ::= function --> Boolean <-- (Tuple, SC_Signature)
        implements 1::""
        : (\\0 .> \1 ^>? \\1);

I<TODO.>

=head2 has_just_attrs (Tuple)

    ::MD::has_just_attrs::Tuple ::= function --> Boolean <-- (Tuple, SC_Signature)
        implements 1::""
        : (\\0 .> \1 ^>?= \\1);

I<TODO.>

=head1 EXTERNAL DATA TYPES

=head2 External

    ::MD::External ::= selection where topic -->^ FDN__isa_External
        default (-->^ FDN__default_External);

The selection contract C<External> represents the infinite Muldis D
Foundation type I<FDN__External>.  An C<External> value is ...

I<TODO.>

=head1 SOURCE CODE DEFINING DATA TYPES

=head2 Source_Code_Meta

    ::MD::Source_Code::Source_Code_Meta_AT ::= interface;

    ::MD::Source_Code::Source_Code_Meta ::= selection ... intersect ...;

I<TODO.>

=head2 Package

    ::MD::Source_Code::Package ::= selection ...;

I<TODO.>

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::See_Also> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright © 2002-2015, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
