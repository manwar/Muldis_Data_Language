=pod

=encoding utf8

=head1 NAME

Muldis::D::Plain_Text -
How to format Muldis D Plain Text

=head1 VERSION

This document is Muldis::D::Plain_Text version 0.200.1.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document
before you read this one, which provides subservient details.

=head1 DESCRIPTION

This document defines the grammar that all non-hosted plain-text Muldis D
source code must conform to when it claims to be written in the
C<Muldis_D:Plain_Text:"http://muldis.com":"0.200.1"> (B<MDPT>) language.

This grammar is meant to be more illustrative to human readers than
executable, as is typical for standards documents; you wouldn't likely be
able to just hand if off to a parser-generator and expect it to work as is.
But it should still have enough information to derive an executable parser.

Note that the standard filename extension for files with such source code
is C<.mdpt>, though as per standard UNIX conventions, such Muldis D source
code files can in fact have any filename extension when there is other
context to interpret them with.  Filename extensions are more for the
benefit of the operating system or command shell or users than for a Muldis
D implementation, the latter just cares about the content of the file.

I<TODO: Comment about resolving package names to package source files;
the CompUnitRepo concept of Perl 6 would be a good precedent.
That will probably go somewhere else in the spec rather than here.>

A primary feature of Muldis D is a grammar that is small and simple while
still being quite rich and expressive.  As much as possible of the language
is defined in terms of ordinary packages, types and routines, in exactly
the same manner as users write their own code in.  Therefore, a Muldis D
grammar has no special knowledge of, or specific syntax for, the vast
majority of the language, and mainly just concerns itself with the minimal
syntactic framework for defining generic types and routines, generic
expressions and statements, and has special handling for just a small
number of data types or routines.  A key benefit of this is that it is very
easy for users to extend the language with new features that look and work
in the same way as the system-defined ones, and are drop-in substitutable
for them, rather than user-defined things being second-class citizens.  The
design also means it is much easier to implement the Muldis D language
itself, a large part of the langauge can be bootstrapped, and both parsers
and generators of Muldis D Plain Text can be simple and easy to make.

Muldis D Plain Text has a I<linear syntax>, and is designed to be easily
handled by a single-pass parser, or at least a single-pass lexer; all the
context that one needs to know for how to parse or lex any arbitrary
substring of code is provided by prior code, or any required lookahead is
just by a few characters in general.  Therefore, a parser/lexer can easily
work on a streaming input like a file-handle where you can't go back
earlier in the stream.  Often this means a parser/lexer can work with
little RAM.

Also the grammar is designed that any amount of whitespace can be added or
omitted next to most non-alphanumeric characters (which happen to be next
to alphanumeric tokens) without that affecting the meaning of the code at
all, except obviously for within character string literals.  And long
binary or character or numeric or identifier strings can be split into
arbitrary-size substrings, without affecting the meaning.  And many
elements are identified by name rather than ordinal position, so to some
degree the order they appear has no effect on the meaning.  So programmers
can easily format (separate, indent, linewrap, order) code how they like,
and making an automated code reformatter shouldn't be difficult.  Often,
named elements can also be omitted entirely for brevity, in which case the
parser would use context to supply default values for those elements.

=head1 GRAMMAR INTERPRETATION

I<TODO: Describe the grammar itself and how to interpret it.  Meanwhile,
keep in mind that the grammar is inspired by both EBNF and Perl 6 rules.>

B<WARNING: THE PERL 6 GRAMMAR USED TO DEFINE THE SYNTAX IS OUT OF DATE WITH
THE LATEST PERL 6; FOR EXAMPLE, I NEED TO USE '%'|'%%' RATHER THAN OR IN
ADDITION TO THE '**' FOR SEPARATOR-DEFINED REPETITIONS ... SEE SYNOPSIS 5.>
- ** takes number or range on right
- % takes list item separator on right, eg allows "x,y" but not "x,y,"
- %% is like % but allows separator to end the list, eg allows "x,y,"

=head1 GENERAL STRUCTURE

Each Muldis D Plain Text code file is either a I<module> or a I<depot>.  A
I<module> is a strictly read-only store featuring executable code, and if
it has any data, that data takes the form of constant declarations.  A
I<depot> is a possibly-updateable store featuring data, but also may have
code that could be updated at runtime using data-definition operations.

Modules directly correspond to the typical concept of a programming
language source code file, and are typically distributed bare, either as
C<.mdpt> plain text files (optionally executable or containing a shebang /
C<#!> line), or compiled to a machine code object file or cross-compiled to
source-code of some other language, for example Perl.

Modules also directly represent all the functionality that is either
traditionally built-in to a DBMS, or to the Muldis D language itself, or
that is provideable by third-party language extensions (this includes
Postgres' "extension" concept), or for functionality that is conceivably
low-level enough to likely be implemented at least partially external to
the Muldis D environment, such that some internals aren't user-visible.

Depots directly represent what is traditionally considered to be "the
database", mainly the actual user data which is read or manipulated at
runtime, but also user code (or "the schema") which is subject to be
updateable at runtime by data-definition operations.  A depot can
optionally be read-only, either all the time or to specific user mounts.

Both depots and modules can declare other modules as external dependencies
by which they are partially defined, but nothing can declare a depot as a
dependency.  As such, any data type definitions including parts of "the
schema" that both "the database" and one or more applications/modules using
it need to know about or directly see, should be declared in modules.

Depots typically exist in an implementation-defined storage format, such as
a set of binary files optimized for fast reads and updates by the DBMS,
which may possibly exist across multiple physical machines or just in RAM
or on disks, examples being a Postgres data directory or SQLite database
file or some key-value store.  However, depots can also exist as C<.mdpt>
plain text files, a format especially useful for interchange, and that
format specifically is what this document defines I<depot> grammar for.

I<TODO: Talk about how the "main program" is determined.>

I<TODO: Talk about how modules are versioned and depots are not.>

I<TODO: Talk about value literals or things in the context of host languages,
each of the former is a depot from the perspective of the grammar.>

I<TODO: Talk about the post-20150226-concept of packages vs modules etc and
what Script Name declarations apply to or don't eg Muldis D source code
in the form of Blob vs Text values or files vs not files.>

I<TODO: Talk about that the main reason for declaring most entities with
absolute-qualified names like eg Pkgname.NS.NS.foo is because packages are
multi-level namespaces and with unqualified names like most programming
languages one would have to do a lot more code scanning to know what entity
they were actually looking at.  A further reason is it means declarations
can be grouped more logically for human reading than being forced to put
everything with a common namespace together.>

The root grammar token for Muldis D Plain Text is C<MDPT>.

=head1 START

Grammar:

    <MDPT> ::=
        ^ <shebang_line>? <versioned_grammar> $

See the sections in this file named L<SHEBANG LINE> and L</VERSIONED
GRAMMAR> for more details.

=head1 SHEBANG LINE

Grammar:

    <shebang_line> ::=
        '#!' <shebang_directive> <shebang_ws_break>

    <shebang_directive> ::=
        ...

    <shebang_ws_break> ::=
        ...

A C<shebang_line>, if it exists, must be the first characters of the text
file, and consists of a magic number which expressed as ASCII or UTF-8 is
C<#!>, followed by a Unix-like interpreter directive or path to an
executable that can interpret Muldis D Plain Text files.  When a Muldis D
Plain Text file starts with a shebang line, it can be invoked directly as
if it were an executable on a Unix-like system.  The format of
C<shebang_directive> isn't defined in this document; see the appropriate
external Unix/etc documentation for that; however, the Muldis D Plain Text
file must have at least one line-breaking whitespace character of some kind
following it, which is how we know where the Muldis D code begins.

Examples:

    #!/usr/bin/env muldisdre

=head1 VERSIONED GRAMMAR

Grammar:

    <versioned_grammar> ::=
        <ws>?
            <language_name> <ws> ';'
            [<script_name> <ws> ';']?
            <unversioned_grammar>
        <ws>?

See the sections in this file named L</LANGUAGE NAME>, L</SCRIPT NAME>,
and L</UNVERSIONED GRAMMAR> for more details.

=head1 LANGUAGE NAME

Grammar:

    <language_name> ::=
        <ln_family_name>
        ':' <ln_syntax_name>
        ':' <ln_authority>
        ':' <ln_version_number>

    <ln_family_name> ::=
        Muldis_D

    <ln_syntax_name> ::=
        Plain_Text

    <ln_authority> ::=
        <gen_ctx_name>

    <ln_version_number> ::=
        <gen_ctx_name>

As per the VERSIONING section of L<Muldis::D>, code written in Muldis D
Plain Text, whether I<module> or I<depot>, must start by declaring the
fully-qualified Muldis D language name it is written in.

SEE ALSO http://design.perl6.org/S11.html#Versioning FOR GUIDANCE...

Examples:

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1"

    Muldis_D:Plain_Text:"http://example.com":"42"

=head1 SCRIPT NAME

Grammar:

    <script_name> ::=
        ...

The Script Name indicates the primary script of the Muldis D code,
meaning is character repertoire and/or character encoding and/or character
normalization.  Under the assumption that a C<Muldis_D:Plain_Text> parser
might be reading the source code as binary data or otherwise as
unnormalized character data, declaring the Script Name makes it completely
unambiguous as to what characters it is to be treating the input as.

For a simple example, a Script Name of C<ASCII> says every literal source
code character is a 7-bit ASCII character (and representing any non-ASCII
characters is being done with escape sequences), and this is recommended
for any C<Muldis_D:Plain_Text> file that doesn't need to be something else.
For various legacy 8-bit formats the Script Name can tell us if we're using
C<Latin1> or C<CP1252> or C<EBCDIC> etc.  For Unicode the Script Name would
have multiple parts, such as C<Unicode(6.2.0,UTF-8,canon)>, indicating
expected repertoire, and encoding (useful more with ones lacking BOMs); but
at the very least it is useful with normalization; if C<compat> is declared
then the source code is folded before it is parsed so possibly distinct
literal characters in the original code are seen as identical character
strings by the main parser, while C<canon> would not do this folding.

A Muldis D parser would possibly scan through the same source code multiple
times filtering by a variety of text encodings until it can read a Muldis D
language name declaring the same encoding that the name is itself written
in, and then from that point it would expect the whole file to be that
declared encoding or it would consider the code invalid.

Examples:

    script ASCII;

    script Unicode:6.2.0:UTF-8:canon;

=head1 WHITESPACE

Grammar:

    <ws> ::=
        <ws_sans_comments> % <quoted_ws_comment_str>

    <ws_sans_comments> ::=
        [' ' | '\t' | '\n' | '\f' | '\r']*

    <quoted_ws_comment_str> ::=
        '`' <-[`]>* '`'

Note that C<ws_sans_comments> is meant to be more comprehensive and include
any character that Unicode considers to be whitespace.

=head1 IDENTIFIERS

Grammar:

    <gen_ctx_name> ::=
        <nonquoted_name_str> | <quoted_name_str>

    <nonquoted_name_str> ::=
        <[ a..z A..Z _ ]> <[ a..z A..Z 0..9 _ ]>*

    <quoted_name_str> ::=
        '"' <-[\"]>* '"'

    <field_name> ::=
        <nonord_field_name> | <ord_field_name>

    <nonord_field_name> ::=
        <gen_ctx_name>

    <ord_field_name> ::=
        <Integer>

    <expr_name> ::=
        <gen_ctx_name>

=head1 UNVERSIONED GRAMMAR

Grammar:

    <unversioned_grammar> ::=
        <module> | <depot>

See the sections in this file named
L</MODULE SPECIFICATION>, and L</DEPOT SPECIFICATION>, for more details.

=head1 STRATEGIES FOR PARSING

Muldis D Plain Text is designed to be easy to parse, where one can use a
multi-stage pipeline with simple rules at each step, and typically the work
of parsing can be done in a highly parallel fashion, where each part of the
code can be parsed properly with very little or no knowledge of what came
before or after it.

In particular, earlier stages of the pipeline can complete successfully
even in the face of syntax errors, as the latter would be caught in a later
pipeline stage where more meaningful error messages can be given.

For the purposes of this documentation section, we will assume that the
source code has already been processed from any binary or other formats
into a single character string token having a well-known
character repertoire that is compatible with Unicode.  This may have
involved scanning ahead for a C<language_name> or in particular a
C<script_name> directive should that have been needed to resolve ambiguity.

Note that it is assumed that all parsing stages following the above
assumption are completely lossless, and that any stages which conceptually
would lose information actually maintain all of it in (generally)
C<Plain_Text>-specific metadata so the original source string could be
reassembled from the parse form in all its details, including for example
the exact character escape sequences and whitespace used.  Also maintained
as useful for debugging is knowledge of what line numbers and character
positions within a line each token ranged over in the original source.

=head2 Pipeline Stage 1

Stage 1 in the parsing pipeline is to separate out any leading
C<shebang_line> that might prefix the code.  The primary output of stage 1
is a single character string token with the code itself, and any leading
shebang is metadata.

Grammar:

    <ps1> ::=
        ^ <shebang_line>? <ps2> $

=head2 Pipeline Stage 2

Broadly speaking, Muldis D Plain Text code is made up of 2 primary
grammatical contexts which are mutually disjoint and complementary; one of
these is anywhere outside all quoted strings, and its complement is
anywhere inside any quoted string; quoted strings don't overlap or nest, or
if they appear to, any inner ones are just regular string contents.

Stage 2 in the parsing pipeline is to split the single input
character string token on all transition points between those grammatical
contexts.  The output of stage 2 is an array of character string tokens
such that catenating them in order gives the input token.  Each output
token is either one of the delimiters by itself, or is the characters
between a delimiter pair, or is the characters between 2 delimited strings.

Grammar:

    <ps2> ::=
        <ps2_nonquoted> % <ps2_quoted>

    <ps2_nonquoted> ::=
        <-['"`]>*

    <ps2_quoted> ::=
          ['\'' <-[']>* '\'']
        | ['"'  <-["]>* '"' ]
        | ['`'  <-[`]>* '`' ]

=head3 Pipeline Stage 3

Stage 3 in the parsing pipeline is to take any tokens from stage 2
representing a quoted context, and for each one, if it contains any
character escape sequences, to replace those escape sequences with the
actual characters they represent.  The output of stage 3 has the same
format as the output of stage 2 but that there are no escape sequences in
any of the character strings.

Grammar:

    <ps3_quoted_sans_delimiters> ::=
        <ps3_nonescaped> | <ps3_escaped>

    <ps3_nonescaped> ::=
        [<-[\\]> .*]?

    <ps3_escaped> ::=
        '\\' [<-[\\]> | <escaped_char>]*

Note that the definition of C<escaped_char> includes an escape sequence
each for a single-quote and a double-quote.  Note that the C<escaped_char>
option doesn't exist for C<`>, just C<'> and C<">.

=head3 Pipeline Stage 4

Stage 4 in the parsing pipeline is to merge runs of consecutive (apart from
any invervening whitespace) quoted context tokens of the same kind,
specifically those delimited by either single-quotes or double-quotes, into
a single quoted context token of that same kind, because such runs are
logically a single token that just would have been split for readability.
An exception is backtick-quoted strings, which are left unmerged, and in
the end they would be merged back into whitespace tokens anyway.
The output of stage 4 is of the same format as of stage 2 or 3.

=head3 Pipeline Stage 5

Stage 5 in the parsing pipeline is to take any tokens from stage 2
representing a nonquoted context, and for each one, split it into tokens by
character class, that is just on the transition between any 2 characters
not of the same one of the 5 character groups shown.

Grammar:

    <ps5_nonquoted> ::=
          <ps5_alphanumeric_char>+
        | <ps5_standalone_char>+
        | <ps5_symbolic_char>+
        | <ps5_whitespace_char>+
        | <ps5_illegal_char>+

    <ps5_alphanumeric_char> ::=
        <[ a..z A..Z 0..9 _ ]>

    <ps5_standalone_char> ::=
        '\\' | ',' | ';' | '(' | ')' | '[' | ']' | '{' | '}'

    <ps5_symbolic_char> ::=
          '!' | '#' | '$' | '%' | '&' | '*' | '+' | '-' | '.' | '/'
        | ':' | '<' | '=' | '>' | '?' | '@' | '^' | '|' | '~'
        | '¬' | '±' | '×' | '÷'
        | '←' | '↑' | '→' | '↓' | '↔' | '↚' | '↛' | '↮'
        | '∀' | '∃' | '∄' | '∅' | '∆' | '∈' | '∉' | '∋' | '∌' | '∖'
        | '∞' | '∧' | '∨' | '∩' | '∪' | '≠' | '≤' | '≥' | '⊂' | '⊃'
        | '⊄' | '⊅' | '⊆' | '⊇' | '⊈' | '⊉' | '⊤' | '⊥' | '⊻' | '⊼'
        | '⊽' | '⊿' | '⋊' | '⋈' | '⋉'
        | '▷' | '⟕' | '⟖' | '⟗' | '⨝' | '⨯'

    <ps5_illegal_char> ::=
        ...

Note that the illegal category includes all characters not explicitly
mentioned in the other categories; in general these are only allowed to
appear literally in quoted context.

Note that the symbolic category is arbitrary in the trans-ASCII range and
is highly subject to gain or lose characters over time.

Note that, while in theory supporting bareword Greek letters may make math
or logic expressions more pleasant, for now they aren't partly to avoid
confusion with similar-looking ASCII letters, and because its hard to know
where to draw the line if one wanted to include the whole un-accented Greek
alphabet, not just C<[ Α..Ρ Σ..Ω α..ω ]>; so in the end, simplicity rules.

=head3 Pipeline Stage 6

Stage 6 in the parsing pipeline is to split any nonquoted context tokens
consisting of multiple <ps5_standalone_char> into multiple tokens such that
each such individual character becomes its own token.

=head3 Pipeline Stage 7

Stage 7 in the parsing pipeline is to split any nonquoted context tokens
consisting of multiple <ps5_symbolic_char> into multiple tokens where those
tokens contain characters well-known to C<Plain_Text> for special uses such
as meta-operator characters.

Grammar:

    <ps7_nonquoted_symbolic_grouping> ::=
          '???'
        | '!!!'
        | '??'
        | '!!'
        | '!'
        | '::='
        | '::'
        | ':='
        | ':'
        | '-->'
        | '<--'
        | '->'
        | '<-'
        | '...'
        | '$'

Where any of the shown symbolic character sequences exist, each sequence
becomes its own token, and any runs of symbolics besides those each become
their own token also.  When looking for sequences, evaluation is
left-to-right and the longest match wins between multiple matches.

Generally speaking, the parsing of nonquoted context symbolic character
runs is complete following stage 7, and each remaining token is not likely
to be split again or be merged with other tokens.

Because the above sequences are special to C<Plain_Text>, whitespace is
optional between them and symbolic operator calls/syntax because there is
considered no ambiguity.

=head3 Pipeline Stage 8

Stage 8 in the parsing pipeline is about distinguishing nonquoted context
tokens consisting of C<ps5_alphanumeric_char> between alpha and numeric,
where the former are typically keywords or bareword identifiers and the
latter are typically numeric literals.

Grammar:

    <ps8_alphanumeric> ::=
        <ps8_alpha> | <ps8_numeric>

    <ps8_alpha> ::=
        <[ a..z A..Z _ ]> <[ a..z A..Z 0..9 _ ]>*

    <ps8_numeric> ::=
        <[ 0..9 ]> <[ a..z A..Z 0..9 _ ]>*

Note that this shown split is very broad and includes invalid tokens;
further details are in the regular grammar.

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::SeeAlso> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright © 2002-2015, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
