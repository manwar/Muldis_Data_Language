=pod

=encoding utf8

=head1 NAME

Muldis::D::Plain_Text -
How to format Muldis D Plain Text

=head1 VERSION

This document is Muldis::D::Plain_Text version 0.200.1.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document
before you read this one, which provides subservient details.

=head1 DESCRIPTION

This document defines the grammar that all non-hosted plain-text Muldis D
source code must conform to when it claims to be written in the
C<Muldis_D:Plain_Text:"http://muldis.com":"0.200.1"> (B<MDPT>) language.

This grammar is meant to be more illustrative to human readers than
executable, as is typical for standards documents; you wouldn't likely be
able to just hand if off to a parser-generator and expect it to work as is.
But it should still have enough information to derive an executable parser.

Note that the standard filename extension for files with such source code
is C<.mdpt>, though as per standard UNIX conventions, such Muldis D source
code files can in fact have any filename extension when there is other
context to interpret them with.  Filename extensions are more for the
benefit of the operating system or command shell or users than for a Muldis
D implementation, the latter just cares about the content of the file.

I<TODO: Comment about resolving package names to package source files;
the CompUnitRepo concept of Perl 6 would be a good precedent.
That will probably go somewhere else in the spec rather than here.>

A primary feature of Muldis D is a grammar that is small and simple while
still being quite rich and expressive.  As much as possible of the language
is defined in terms of ordinary packages, types and routines, in exactly
the same manner as users write their own code in.  Therefore, a Muldis D
grammar has no special knowledge of, or specific syntax for, the vast
majority of the language, and mainly just concerns itself with the minimal
syntactic framework for defining generic types and routines, generic
expressions and statements, and has special handling for just a small
number of data types or routines.  A key benefit of this is that it is very
easy for users to extend the language with new features that look and work
in the same way as the system-defined ones, and are drop-in substitutable
for them, rather than user-defined things being second-class citizens.  The
design also means it is much easier to implement the Muldis D language
itself, a large part of the langauge can be bootstrapped, and both parsers
and generators of Muldis D Plain Text can be simple and easy to make.

Muldis D Plain Text has a I<linear syntax>, and is designed to be easily
handled by a single-pass parser, or at least a single-pass lexer; all the
context that one needs to know for how to parse or lex any arbitrary
substring of code is provided by prior code, or any required lookahead is
just by a few characters in general.  Therefore, a parser/lexer can easily
work on a streaming input like a file-handle where you can't go back
earlier in the stream.  Often this means a parser/lexer can work with
little RAM.

Also the grammar is designed that any amount of whitespace can be added or
omitted next to most non-alphanumeric characters (which happen to be next
to alphanumeric tokens) without that affecting the meaning of the code at
all, except obviously for within character string literals.  And long
binary or character or numeric or identifier strings can be split into
arbitrary-size substrings, without affecting the meaning.  And many
elements are identified by name rather than ordinal position, so to some
degree the order they appear has no effect on the meaning.  So programmers
can easily format (separate, indent, linewrap, order) code how they like,
and making an automated code reformatter shouldn't be difficult.  Often,
named elements can also be omitted entirely for brevity, in which case the
parser would use context to supply default values for those elements.

=head1 GRAMMAR INTERPRETATION

I<TODO: Describe the grammar itself and how to interpret it.  Meanwhile,
keep in mind that the grammar is inspired by both EBNF and Perl 6 rules.>

    About separator-defined repetitions:
    - ** takes number or range on right
    - % takes list item separator on right, eg allows "x,y" but not "x,y,"
    - %% is like % but allows separator to end the list, eg allows "x,y,"

=head1 GENERAL STRUCTURE

I<TODO: Rewrite the following to just use "package".>

Each Muldis D Plain Text code file is either a I<module> or a I<depot>.  A
I<module> is a strictly read-only store featuring executable code, and if
it has any data, that data takes the form of constant declarations.  A
I<depot> is a possibly-updateable store featuring data, but also may have
code that could be updated at runtime using data-definition operations.

Modules directly correspond to the typical concept of a programming
language source code file, and are typically distributed bare, either as
C<.mdpt> plain text files (optionally executable or containing a shebang /
C<#!> line), or compiled to a machine code object file or cross-compiled to
source-code of some other language, for example Perl.

Modules also directly represent all the functionality that is either
traditionally built-in to a DBMS, or to the Muldis D language itself, or
that is provideable by third-party language extensions (this includes
Postgres' "extension" concept), or for functionality that is conceivably
low-level enough to likely be implemented at least partially external to
the Muldis D environment, such that some internals aren't user-visible.

Depots directly represent what is traditionally considered to be "the
database", mainly the actual user data which is read or manipulated at
runtime, but also user code (or "the schema") which is subject to be
updateable at runtime by data-definition operations.  A depot can
optionally be read-only, either all the time or to specific user mounts.

Both depots and modules can declare other modules as external dependencies
by which they are partially defined, but nothing can declare a depot as a
dependency.  As such, any data type definitions including parts of "the
schema" that both "the database" and one or more applications/modules using
it need to know about or directly see, should be declared in modules.

Depots typically exist in an implementation-defined storage format, such as
a set of binary files optimized for fast reads and updates by the DBMS,
which may possibly exist across multiple physical machines or just in RAM
or on disks, examples being a Postgres data directory or SQLite database
file or some key-value store.  However, depots can also exist as C<.mdpt>
plain text files, a format especially useful for interchange, and that
format specifically is what this document defines I<depot> grammar for.

I<TODO: Talk about how the "main program" is determined.>

I<TODO: Talk about how modules are versioned and depots are not.>

I<TODO: Talk about value literals or things in the context of host languages,
each of the former is a depot from the perspective of the grammar.>

I<TODO: Talk about the post-20150226-concept of packages vs modules etc and
what Script Name declarations apply to or don't eg Muldis D source code
in the form of Blob vs Text values or files vs not files.>

I<TODO: Talk about that the main reason for declaring most entities with
absolute-qualified names like eg Pkgname.NS.NS.foo is because packages are
multi-level namespaces and with unqualified names like most programming
languages one would have to do a lot more code scanning to know what entity
they were actually looking at.  A further reason is it means declarations
can be grouped more logically for human reading than being forced to put
everything with a common namespace together.>

The root grammar token for Muldis D Plain Text is C<< <MDPT> >>.

=head1 START

Grammar:

    <MDPT> ::=
        ^ <shebang_line>? <versioned_source_code> $

See the sections in this file named L<SHEBANG LINE> and L</VERSIONED
SOURCE CODE> for more details.

=head1 SHEBANG LINE

Grammar:

    <shebang_line> ::=
        '#!' <shebang_directive> <shebang_whitespace_break>

    <shebang_directive> ::=
        ...

    <shebang_whitespace_break> ::=
        ...

A C<< <shebang_line> >>, if it exists, must be the first characters of the
text file, and consists of a magic number which expressed as ASCII or UTF-8
is C<#!>, followed by a Unix-like interpreter directive or path to an
executable that can interpret Muldis D Plain Text files.  When a Muldis D
Plain Text file starts with a shebang line, it can be invoked directly as
if it were an executable on a Unix-like system.  The format of
C<< <shebang_directive> >> isn't defined in this document; see the appropriate
external Unix/etc documentation for that; however, the Muldis D Plain Text
file must have at least one line-breaking whitespace character of some kind
following it, which is how we know where the Muldis D code begins.

Examples:

    #!/usr/bin/env muldisdre

=head1 VERSIONED SOURCE CODE

Grammar:

    <versioned_source_code> ::=
        <sp>
            <language_name> <sp> ';' <sp>
            [<foundational_indicator> <sp> ';' <sp>]?
            [<script_name> <sp> ';' <sp>]?
            [<package> <sp> ';' <sp>]*
        <sp>

See the sections in this file named L</LANGUAGE NAME>, L<FOUNDATIONAL
INDICATOR>, L</SCRIPT NAME>, and L</PACKAGE SPECIFICATION>, for more details.

=head1 LANGUAGE NAME

Grammar:

    <language_name> ::=
        <ln_family_name>
        ':' <ln_syntax_name>
        ':' <ln_authority>
        ':' <ln_version_number>

    <ln_family_name> ::=
        Muldis_D

    <ln_syntax_name> ::=
        Plain_Text

    <ln_authority> ::=
        <gen_ctx_name>

    <ln_version_number> ::=
        <gen_ctx_name>

As per the VERSIONING section of L<Muldis::D>, code written in Muldis D
Plain Text, whether I<module> or I<depot>, must start by declaring the
fully-qualified Muldis D language name it is written in.

SEE ALSO http://design.perl6.org/S11.html#Versioning FOR GUIDANCE...

Examples:

    Muldis_D:Plain_Text:"http://muldis.com":"0.200.1"

    Muldis_D:Plain_Text:"http://example.com":"42"

=head1 FOUNDATIONAL INDICATOR

Grammar:

    <foundational_indicator> ::=
        foundational

The C<foundational_indicator> pragma determines with a broad granularity
how large the effective Muldis D grammar is that a programmer may employ
with their Muldis D code.

minimal subset, directly correspond,...

I<TODO.>

=head1 SCRIPT NAME

Grammar:

    <script_name> ::=
        script ...

The Script Name indicates the primary script of the Muldis D code,
meaning is character repertoire and/or character encoding and/or character
normalization.  Under the assumption that a C<Muldis_D:Plain_Text> parser
might be reading the source code as binary data or otherwise as
unnormalized character data, declaring the Script Name makes it completely
unambiguous as to what characters it is to be treating the input as.

For a simple example, a Script Name of C<ASCII> says every literal source
code character is a 7-bit ASCII character (and representing any non-ASCII
characters is being done with escape sequences), and this is recommended
for any C<Muldis_D:Plain_Text> file that doesn't need to be something else.
For various legacy 8-bit formats the Script Name can tell us if we're using
C<Latin1> or C<CP1252> or C<EBCDIC> etc.  For Unicode the Script Name would
have multiple parts, such as C<Unicode(8.0,UTF-8,canon)>, indicating
expected repertoire, and encoding (useful more with ones lacking BOMs); but
at the very least it is useful with normalization; if C<compat> is declared
then the source code is folded before it is parsed so possibly distinct
literal characters in the original code are seen as identical character
strings by the main parser, while C<canon> would not do this folding.

A Muldis D parser would possibly scan through the same source code multiple
times filtering by a variety of text encodings until it can read a Muldis D
language name declaring the same encoding that the name is itself written
in, and then from that point it would expect the whole file to be that
declared encoding or it would consider the code invalid.

Examples:

    script ASCII;

    script Unicode:8.0:UTF-8:canon;

=head1 CHARACTER CLASSES

Grammar:

    <unrestricted_char> ::=
          <alphanumeric_char>
        | <quoting_char>
        | <bracketing_char>
        | <symbolic_char>
        | <whitespace_char>

    <alphanumeric_char> ::=
        <alpha_char> | <digit_char>

    <alpha_char> ::=
        <[ A..Z _ a..z ]>

    <digit_char> ::=
        <[ 0..9 ]>

    <quoting_char> ::=
        <["'`]>

    <bracketing_char> ::=
        '(' | ')' | '[' | ']' | '{' | '}'

    <symbolic_char> ::=
        <special_symbolic_char> | <regular_symbolic_char>

    <special_symbolic_char> ::=
        '!' | ',' | ':' | ';' | '\\'

    <regular_symbolic_char> ::=
          '#' | '$' | '%' | '&' | '*' | '+' | '-' | '.' | '/'
        | '<' | '=' | '>' | '?' | '@' | '^' | '|' | '~'
        | '¬' | '±' | '×' | '÷'
        | '←' | '↑' | '→' | '↓' | '↔' | '↚' | '↛' | '↮'
        | '∀' | '∃' | '∄' | '∅' | '∆' | '∈' | '∉' | '∋' | '∌' | '∖'
        | '∞' | '∧' | '∨' | '∩' | '∪' | '≠' | '≤' | '≥' | '⊂' | '⊃'
        | '⊄' | '⊅' | '⊆' | '⊇' | '⊈' | '⊉' | '⊤' | '⊥' | '⊻' | '⊼'
        | '⊽' | '⊿' | '⋊' | '⋈' | '⋉'
        | '▷' | '⟕' | '⟖' | '⟗' | '⨝' | '⨯'

    <whitespace_char> ::=
        ' ' | '\t' | '\n' | '\f' | '\r'

The Muldis D Plain Text grammar recognizes 7 distinct character classes,
which are mutually disjoint proper subsets of the character repertoire
identified by the Script Name: I<alphanumeric>, I<quoting>, I<bracketing>,
I<symbolic>, I<whitespace>, I<restricted>, I<illegal>; the first 5 are
collectively I<unrestricted>.

The 5 I<unrestricted> classes are the more syntactically interesting ones
and represent characters that may appear anywhere in Plain Text source
code.  In contrast, I<restricted> characters may only appear literally
inside of a quoted string, and I<illegal> characters may not appear
literally in source code at all.

All printable characters of the ASCII repertoire are I<unrestricted>, as
are the small number of non-printable ASCII characters named in C<<
<whitespace_char> >>; all other (non-printable) ASCII characters are
I<illegal>.

The vast majority of non-ASCII Unicode characters are I<restricted>, the
only exceptions being the small number named in C<< <symbolic_char> >> or
C<< <whitespace_char> >>; any non-ASCII Unicode control characters not
otherwise named are I<illegal>.

Regardless of character class, all characters may be logically represented
in terms of character escape sequences, but only inside of a quoted string.

Note that the symbolic category is arbitrary in the trans-ASCII range and
is highly subject to gain or lose characters over time.

Note that, while in theory supporting bareword Greek letters may make math
or logic expressions more pleasant, for now they aren't partly to avoid
confusion with similar-looking ASCII letters, and because its hard to know
where to draw the line if one wanted to include the whole un-accented Greek
alphabet, not just C<[ Α..Ρ Σ..Ω α..ω ]>; so in the end, simplicity rules.

=head1 ESCAPED CHARACTERS

Grammar:

    <escaped_char> ::=
          '\\a' | '\\q'
        | '\\t' | '\\n' | '\\f' | '\\r'
        | '\\c<' [
              ['0b' <nc2>+]
            | ['0o' <nc8>+]
            | ['0d'? <nc10>+]
            | ['0x' <nc16>+]
          ] '>'

The meanings of the simple character escape sequences are:

    Esc | Unicode   | Unicode         | Chr | Literal character used
    Seq | Codepoint | Character Name  | Lit | for when not escaped
    ----+-----------+-----------------+-----+------------------------------
    \a  | 0x27      | APOSTROPHE      | '   | delimit Text/opaque literals
    \q  | 0x22      | QUOTATION MARK  | "   | delimit quoted names
    \t  | 0x9       | CHAR... TAB...  |     | control char horizontal tab
    \n  | 0xA       | LINE FEED (LF)  |     | ctrl char line feed / newline
    \f  | 0xC       | FORM FEED (FF)  |     | control char form feed
    \r  | 0xD       | CARR. RET. (CR) |     | control char carriage return

There is currently just one complex escape sequence, of the format C<<
\c<...> >>, that supports specifying characters in terms of their Unicode
abstract codepoint number.  One reason for this feature is to empower more
elegant passing of Unicode-savvy Plain_Text source code through a
communications channel that is more limited, such as to 7-bit ASCII.

Examples:

    \a

    \n

    \c<0x263A>

    \c<65>

Note that Plain_Text eschews built-in support for a C<< \c<...> >> format
that specifies characters in terms of their Unicode character name, for
example C<< \c<LATIN SMALL LETTER OU> >>.  Instead, it is left to the
domain of non-core Muldis D packages to support such a feature.  The main
reason for this is to avoid an unconditionally-mandatory complex dependency
that is the Unicode character database.

=head1 DIVIDING SPACE

Grammar:

    <sp> ::=
        [<whitespace> | <quoted_sp_comment_str>]*

    <whitespace> ::=
        <whitespace_char>+

    <quoted_sp_comment_str> ::=
        '`' <-[`]>* '`'

The primary function of I<dividing space>, represented by C<< <sp> >>, is
to disambiguate the boundaries of otherwise-consecutive grammar tokens.

Once Muldis D Plain Text code is parsed, any dividing space is just
discardable non-semantic metadata for its wider context, but during a parse
its presence is often critical to properly interpret the wider context.

The grammar doesn't specify this explicitly for simplicity, but anywhere a
C<< <sp> >> token appears, it should be interpreted as carrying a number of
look-around assertions regarding adjacent tokens.

In the context of any C<< <foo> <sp> <bar> >>, these syntax rules apply:

=over

=item *

If C<< <foo> >> and C<< <bar> >> are of different character classes
(alphanumeric vs quoting vs bracketing vs symbolic vs whitespace) then C<<
<sp> >> is allowed to be empty.

=item *

Otherwise, if C<< <foo> >> and C<< <bar> >> are both alphanumeric then C<<
<sp> >> must be nonempty.

=item *

Otherwise, if C<< <foo> >> and C<< <bar> >> are both quoting or bracketing
or whitespace then C<< <sp> >> is allowed to be empty.

=item *

Otherwise, C<< <foo> >> and C<< <bar> >> are both symbolic; whether or not
C<< <sp> >> is allowed to be empty or not depends on the specific sequence
of symbolic characters in the original source code, as described by the
subsequent syntax rules.

=item *

If either C<< <foo> >> or C<< <bar> >> or both are either C<,> or C<;> or
C<\> then C<< <sp> >> is allowed to be empty.

=item *

Otherwise, if exactly one of C<< <foo> >> or C<< <bar> >> is C<:> and the
other doesn't have that character then C<< <sp> >> is allowed to be empty.

=item *

Otherwise, if C<< <foo> >> is either C<!> or C<:=> then C<< <sp> >> is
allowed to be empty.

=item *

Otherwise, C<< <sp> >> must be nonempty.

=back

The secondary function of I<dividing space> is to empower users to format
their code for easier readability through appropriate linebreaks,
indentation, and other kinds of spacing, as they see fit; what they choose
here has no impact on the behavior of the code.

The tertiary function of I<dividing space> is to empower the placement of
code comments or visual dividers almost anywhere, but with the caveat that
comments written this way are not introspectable as comments in the parsed
code, and rather are treated like insignificant whitespace.  This style of
comment defined with backtick-quoted strings should just be used for the
likes of visual dividers or less important comments or for when you want to
quickly "comment out" some source code rather than deleting it.

For more important comments that are introspectable as such, see the
section in this file named C<GENERIC VALUE EXPRESSIONS>.

Examples:

    `This does something.`

=head1 KEYWORDS

Muldis D Plain Text has a number of keywords, both alphanumeric and
symbolic, which have special meaning in certain contexts.  However, it does
not have any reserved words so users can still define identifiers having
any character string they want.

The keywords use a proper subset of the same syntax otherwise available for
user-defined identifiers.  In any contexts where it would otherwise be
ambiguous as to whether a term is a keyword versus the name of some entity,
the parser will always take the keyword interpretation.  For all such
cases, Muldis D Plain Text provides syntax options that explicitly
disambiguate in favor of the non-keyword choice.  Since every entity name
C<foo> is allowed to be double-quoted anywhere it appears like C<"foo">,
while all keywords only have a single syntax each which is non-quoted, a
non-quoted C<foo> will always favor the keyword while a quoted C<"foo">
will always favor the entity name.

These are keywords within a C<< <language_name> >>:

    Muldis_D
    Plain_Text

These are keywords within the outer areas of source code:

    has_segment
    package
    package_segment
    script
    searching
    using
    ::?=
    ::=

These are keywords within the heading of a package entity declaration:

    abstract
    and_provides_its_default
    associative
    commutative
    composes
    constant
    default
    folded
    from
    function
    idempotent
    identity
    implements
    is
    normalize
    of
    overrides
    procedure
    requires
    requires_implements
    signature
    singleton
    synonym
    to
    type
    union
    via
    virtual
    where
    ::?=
    ::=
    :
    -->
    <--

These are keywords only within an C<< <expr> >> or C<< <stmt> >>, not
including the headings of nested package entity declarations:

    default
    else
    fail
    false
    given
    if
    not
    then
    topic
    true
    when
    ::?=
    ::=
    :=
    -->
    <--
    ->
    <-
    ???
    !!!
    ??
    !!
    !

These are used as list/pair separators in various places:

    ::
    :
    ;;
    ;
    ,

Finally, the backslash C<\> is used heavily to indicate value literals of
many different kinds, disambiguating them from other things.

Muldis D Plain Text purposefully keeps its set of keywords small, therefore
giving users the maximum amount of flexibility to effectively define
whatever operator/etc names they want for use as barewords, and the full
complement of system-defined types and operators are defined using the same
tools users have, so if you don't see something in the lists you would
expect to be system-defined, i's likely they're defined in libraries.

=head1 IDENTIFIERS

Grammar:

    <alphanumeric_name> ::=
        <alpha_char> <alphanumeric_char>*

    <symbolic_name> ::=
        <symbolic_char>+

    <quoted_name> ::=
        <quoted_name_seg> % <sp>

    <quoted_name_seg> ::=
        <qns_nonescaped> | <qns_escaped>

    <qns_nonescaped> ::=
        '"' [<-["\\]> <-["]>*]? '"'

    <qns_escaped> ::=
        '"' '\\' [<-["\\]> | <escaped_char>]* '"'

    <generic_name> ::=
        <alphanumeric_name> | <quoted_name>

    <fixed_name> ::=
        <alphanumeric_name> | <symbolic_name>

    <field_name> ::=
        <nonord_field_name> | <ord_field_name>

    <nonord_field_name> ::=
        <generic_name>

    <ord_field_name> ::=
        <nn_Integer>

    <expr_name> ::=
        <generic_name>

    <var_name> ::=
        <generic_name>

    <pkg_entity_name> ::=
          <absolute_name>
        | <relative_name>
        | <floating_name>

    <absolute_name> ::=
        '::' <sp> <floating_name>

    <relative_name> ::=
        <digit_char>+ [<sp> '::' <sp> <floating_name>]?

    <floating_name> ::=
        <generic_name> % [<sp> '::' <sp>]

    <folder_name> ::=
        <absolute_name>

    <material_name> ::=
        <absolute_name>

    <generic_func_name> ::=
        <pkg_entity_name>

    <foundation_const_name> ::=
          FDN__false
        | FDN__true
        | FDN__default_External
        | ...

    <foundation_func_name> ::=
          FDN__isa_Boolean
        | FDN__isa_Integer_Inf
        | FDN__isa_Array_Inf
        | FDN__isa_Bag_Inf
        | FDN__isa_Structure_Inf
        | FDN__isa_External
        | FDN__same
        | FDN__Int_from_Text_10
        | FDN__Int_from_Text_16
        | FDN__Integers_in_order
        | FDN__Array_elem
        | FDN__Array_has_elem
        | FDN__Structure_field
        | FDN__Structure_has_field
        | ...

A C<< <generic_name> >> is a I<generic context entity name>, which can be
used in any context that is expecting I<a> Muldis D entity name in the
general sense, without restrictions.  Examples of use are when declaring
any named entity or with general type/routine/etc invocation syntax that
allows any entity of the respective kind, or for field names.

A C<< <fixed_name> >> is for use within value expressions with certain
common cases of function (or constant) invocations where an unqualified
operator name appears next to its operands without any parenthesis to group
the operands under the operator.  The I<fixed> name comes from such
invocations being usually qualified as I<prefix> or I<infix> or I<postfix>.

A C<< <pkg_entity_name> >> is for use when either declaring or referencing
package entities (types, constants, functions, procedures, synonyms, etc)
which live within a multi-level namespace.

=head1 PACKAGE SPECIFICATION

Grammar:

    <package> ::=
        package <sp>
        '{' <sp>
            <pkg_identity> <sp> ';' <sp>
            [<pkg_uses> <sp> ';' <sp>]?
            [<pkg_materials> <sp> ';' <sp>]?
        <sp> '}'

    <pkg_identity> ::=
        identity <sp> <x> <sp> '::=' <sp> <x>

    <pkg_uses> ::=
        uses <sp>
        '{' <sp>
            [<x> <sp> '::=' <sp> <x> <sp> ';' <sp>]*
        <sp> '}'

    <pkg_materials> ::=
        materials <sp>
        '{' <sp>
            [<pkg_materials_floating> <sp> ';' <sp>]?
            folders...
            binders...
            [<named_material> <sp> ';' <sp>]*
        <sp> '}'

    <pkg_materials_floating> ::=
        floating <sp>
        '{' <sp>
            [<folder_name> <sp> ',' <sp>]*
        <sp> '}'

    <named_material> ::=
        <material_name> <sp> '::=' <sp> <material>

I<TODO.  See also about binders, folder declarations, etc.>

=head1 MATERIAL SPECIFICATION

Grammar:

    <material> ::=
        <synonym> | <contract> | <constant> | <function> | <procedure>

    <synonym> ::=
        synonym <sp> of <sp> <pkg_entity_name>

I<TODO.>

A C<< <material> >> specifies a new material (routine or contract) that
lives in a package.

=head2 Contract Specification

Grammar:

    <contract> ::=
        ...

I<TODO.>

=head2 Constant Specification

Grammar:

    <constant> ::=
        ...

I<TODO.>

=head2 Function Specification

Grammar:

    <function> ::=
        ...

I<TODO.>

=head2 Procedure Specification

Grammar:

    <procedure> ::=
        ...

I<TODO.>

=head1 GENERIC VALUE EXPRESSIONS

Grammar:

    <expr> ::=
        <named_expr> | <annotating_expr> | <anon_expr>

    <named_expr> ::=
          <expr_name>
        | <naming_expr>
        | <aliasing_expr>

    <naming_expr> ::=
        <expr_name> <sp> '::=' <sp> <anon_expr>

    <aliasing_expr> ::=
        <expr_name> <sp> '::=' <sp> <named_expr>

    <annotating_expr> ::=
        <annotated_expr> '::?=' <annotation_expr>

    <annotated_expr> ::=
        <expr>

    <annotation_expr> ::=
        <expr>

    <anon_expr> ::=
          <delimiting_expr>
        | <topic_expr>
        | <opaque_literal_expr>
        | <collection_selector_expr>
        | <invocation_expr>
        | <conditional_expr>
        | <fail_expr>
        | ...

    <delimiting_expr> ::=
        '(' <sp> [
            <naming_expr> | <aliasing_expr> | <result_expr> | <sp>
        ] % ';' <sp> ')'

    <result_expr> ::=
          ['<--' <sp> <expr>]
        | [['<--' <sp>]? <anon_expr>]

    <topic_expr> ::=
        topic

    <fail_expr> ::=
        fail

An C<< <expr> >> is a Muldis D I<generic context value expression>, which
can be used in any context that is expecting I<a> value but has no
expectation that said value belongs to a specific data type.  In the
general case, an expression denoting any value of the C<Anything> type may
be used where you see C<< <expr> >>, any further restrictions would be
provided by the context.

Iff an C<< <expr> >> is an C<< <expr_name> >>, then this means
that the parent C<< <expr> >> is having at least one of its children
declared with an explicit name rather than inline, and then the C<<
<expr_name> >> is the invocation name of that child.

Iff an C<< <expr> >> is a C<< <naming_expr> >>, then the C<< <anon_expr> >>
element of the C<< <named_expr> >> is being declared with an explicit name,
and the C<< <expr_name> >> element of the C<< <named_expr> >> is that name.
Outside of the context of a C<< <naming_expr> >>, the system will generate
an implicitly-used name for the C<< <anon_expr> >> element.  Iff an C<<
<expr> >> is instead an C<< <aliasing_expr> >>, then it is in fact
declaring a new node itself (rather than simply naming its child node); the
new node is simply declaring an alias for another node, namely its C<<
<named_expr> >> element.

Iff an C<< <expr> >> is an C<< <annotating_expr> >>, then the C<<
<annotated_expr> >> element of the C<< <annotating_expr> >> is being given
an explicit introspectable code annotation whose value is the C<<
<annotation_expr> >> element.  Keep in mind that C<::?=> binds tighter than
nearly anything, so you may have to use parenthesis when you want the
annotation to associate with a non-leaf node.  The most typical kind of
annotation is a code comment expressed as a C<Comment> literal, or it may
be a C<Set> of what would otherwise be individual annotations.

An C<< <annotation_expr> >> is subject to the additional rule that it must
be a completely foldable constant.  It may not contain a C<< <topic_expr> >>.

Iff an C<< <expr> >> is a C<< <delimiting_expr> >>, then it is interpreted
simply as if it were its child C<< <expr> >> element; the primary reason
that the C<< <delimiting_expr> >> grammar element exists is to assist the
parser in determining the boundaries of an C<< <expr> >> where code
otherwise might be ambiguous or be interpreted differently than desired due
to nesting precedence rules.

A C<< <delimiting_expr> >> is subject to the additional rule that it must
contain exactly one C<< <result_expr> >> element, which provides its value.

Iff an C<< <expr> >> is a C<< <topic_expr> >>, then it represents the value
of the expression-containing routine's sole argument.

Iff an C<< <expr> >> is a C<< <fail_expr> >>, then any attempt at runtime
to take that node's value will throw an exception, and so it should only
appear as a child of a C<< <conditional_expr> >> node, one that is
performing an assertion that its other inputs are reasonable.

See the sections in this file named L</OPAQUE LITERAL EXPRESSIONS>,
L</COLLECTION SELECTOR EXPRESSIONS>, L</INVOCATION EXPRESSIONS>, and
L</CONDITIONAL EXPRESSIONS> for more details.

Examples:

    `an expr_name node`
    foo_expr

    `a naming_expr node`
    bar_expr ::= factorial( foo_expr )

    5 + 42 ::?= \~?'this is an introspectable comment attached to the 42'

    myfoo ::?= \~?'this is a comment on the elsewhere-declared node named foo'

    `a delimiting_expr node`
    (x ::= y + 2; <-- x * x)

    `this uses one too`
    (x + y) * z

    `this is the routine's argument`
    topic

    `some assertion failed`
    fail

I<TODO: ADD SIGNAL SENDING AND OTHER MISC EXPRESSIONS.>

=head1 OPAQUE LITERAL EXPRESSIONS

Grammar:

    <opaque_literal_expr> ::=
          <Boolean>
        | <Integer>
        | <Ratio>
        | <Float>
        | <Blob>
        | <Text>

An C<< <opaque_literal_expr> >> is an C<< <expr> >> that denotes a value
literal specific to some system-defined data type that has its own special
Muldis D Plain Text selector syntax, and this literal syntax explicitly has
no child C<< <expr> >> nodes, as in conventional terms it is for selecting
scalar values.

=head2 Boolean Literals

Grammar:

    <Boolean> ::=
        '\\?'? [false | true]

A C<< <Boolean> >> node represents a value of the Muldis D C<Boolean>
type, which is a general purpose logical boolean value.  The C<Boolean>
type is a fundamental type of the Muldis D type system, and this is the
canonical grammar for them.

Examples:

    true

    false

    \?true

=head2 Integer Literals

Grammar:

    <Integer> ::=
        <nonquoted_int> | <quoted_int>

    <nonquoted_int> ::=
        ['\\+' | '\\-']? <nonsigned_int>

    <quoted_int> ::=
        <qu_num_head> <qu_asigned_int> <qu_num_tail>

    <qu_num_head> ::=
        '\\+' '\''

    <qu_asigned_int> ::=
        <asigned_int> <qu_num_mid>?

    <qu_num_mid> ::=
        <num_seg> % <qu_num_sp>

    <qu_num_sp> ::=
        '\'' <sp> '\''

    <qu_num_tail> ::=
        '\''

    <asigned_int> ::=
        <num_sign>? <nonsigned_int>

    <num_sign> ::=
        '+' | '-'

    <nonsigned_int> ::=
        <num_radix_mark>? <num_seg>

    <num_radix_mark> ::=
        0 <[bodx]>

    <num_seg> ::=
        <num_char>+

    <num_char> ::=
        <nc2> | <nc8> | <nc10> | <nc16>

    <nc2> ::=
        <[ 0..1 _ ]>

    <nc8> ::=
        <[ 0..7 _ ]>

    <nc10> ::=
        <[ 0..9 _ ]>

    <nc16> ::=
        <[ 0..9 A..F _ a..f ]>

An C<< <Integer> >> node represents a value of the Muldis D C<Integer>
type, which is a general purpose integer exact numeric value.  The C<Integer>
type is a fundamental type of the Muldis D type system, and this is the
canonical grammar for them.

This grammar supports writing C<Integer> literals in any of the numeric
bases {2,8,10,16} using conventional syntax.  The literal may optionally
contain underscore characters (C<_>), which exist just to help with visual
formatting, such as for C<10_000_000>.

This grammar is subject to the following additional rules:

=over

=item *

If C<< <num_radix_mark> >> is omitted or is C<0d> then every
C<< <num_char> >> must be a C<< <nc10> >>.

=item *

Otherwise, if C<< <num_radix_mark> >> is C<0b> or C<0o> or C<0x> then every
C<< <num_char> >> must be a C<< <nc2> >> or C<< <nc8> >> or C<< <nc16> >>
respectively.

=back

TODO: UPDATE THIS!
Unlike with most common programming languages, the Muldis D Plain Text
canonical syntax for its simpler numeric types requires each literal to be
quoted like C<\+'foo'> when the literal C<foo> contains anything other than
digits or any of the characters C<[bodx._]>.  This includes all negative
numbers plus all rational numbers whose denominators are integral powers of
neither 2 nor 10, for example C<\+'-3'> and C<\+'1/43'>.  The quoted syntax
is permitted for all simpler numeric literals but the simpler bareword
syntax is canonical for non-negatives such as C<0x420F> and C<3.14159>.

Muldis D Plain Text still permits the restricted numeric values to be
expressed bare as users are accustomed to, for example C<-3> or C<1/43>,
but in that case they would be interpreted as more complicated value
expressions having operator calls, such as the additive inverse of a
positive integer or the rational division of 2 integers, respectively.

Typically these bare or quoted alternatives would logically denote the same
values as each other as users would expect, assuming that code is using the
core package C<Muldis_D> which defines C<-> and C</> etc over C<Integer>;
however, that might not be the case if alternate definitions of C<-> etc
are in scope of the code; the quoted forms are guaranteed to not change
meaning no matter what packages or routines are in scope of the code.

The primary rationale for this design is that that the Muldis D Plain Text
grammar is kept simpler by avoiding the only special
cases for a symbolic character immediately preceding an alphanumeric token.
There should be no surprise or ambiguity for users when a digit is preceded
by a run of symbolics C<ω> as to how it will be interpreted; for example,
C<ω3> and C<ω(3)> and C<ωx> (where C<x> is 3) will be parsed in exactly the
same way with respect to the symbolic even when it contains a C<-> etc.

A quoted C<< <Integer> >> may optionally be split into 1..N quoted segments
where each pair of consecutive segments is separated by dividing space;
this segmenting ability is provided to support code that contains very long
numeric literals while still being well formatted (no extra long lines).

Examples:

    42

    0

    \-3

    \+'-3' '50_897'

    0d39

    0xDEADBEEF

    0o644

    0b11001001

=head2 Ratio Literals

Grammar:

    <Ratio> ::=
        <nonquoted_ratio> | <quoted_ratio>

    <nonquoted_ratio> ::=
        ['\\+' | '\\-']? <nonsigned_int> '.' <num_seg>

    <quoted_ratio> ::=
        <qu_num_head> [
              [<qu_asigned_int> '.' <qu_num_mid>]
            | [<qu_asigned_int> '/' <qu_asigned_int>]
        ] <qu_num_tail>

A C<< <Ratio> >> node represents a value of the Muldis D C<Ratio>
type, which is a general purpose rational exact numeric value.

The C<Ratio> type is not a fundamental type of the Muldis D type system, but
rather is a subtype by constraint of the C<Structure> type, and all C<Ratio>
values can be selected in terms of C<< <Structure> >> grammar nodes.
However, C<< <Ratio> >> is the canonical grammar for all C<Ratio> values.

Examples:

    3.14159

    0.0

    \+'5/3'

    \-4.72

    \+'-472/100'

    0xDEADBEEF.FACE

    \+'-0o402'

    0b1.1

=head2 Float Literals

Grammar:

    <Float> ::=
        <nonquoted_float> | <quoted_float>

    <nonquoted_float> ::=
        ['\\+' | '\\-']? <nonsigned_int> ['.' <num_seg>]? 'p' <num_seg>

    <quoted_float> ::=
        <qu_num_head> [
              [<qu_asigned_int> ['.' <qu_num_mid>]?
                'p' <num_sign>? <qu_num_mid>]
            | [<qu_asigned_int> '*' <qu_asigned_int> '^' <qu_asigned_int>]
        ] <qu_num_tail>

A C<< <Float> >> node represents a value of the Muldis D C<Float>
type, which is a general purpose floating-point exact numeric value.

The C<Float> type is not a fundamental type of the Muldis D type system, but
rather is a subtype by constraint of the C<Structure> type, and all C<Float>
values can be selected in terms of C<< <Structure> >> grammar nodes.
However, C<< <Float> >> is the canonical grammar for all C<Float> values.

Examples:

    4.5207196p37

    0p0

    \-17.62p15

    \+'314159*10^-5'

    0x1f.0p3

    0x1.aaaaaaaaaaaabp1

    \+'0b1011101101*10^-11011'

=head2 Blob Literals

Grammar:

    <Blob> ::=
        '\\~+' ['\'' [
              ['0b' <nc2>*]
            | ['0o' <nc8>*]
            | ['0x' <nc16>*]
        ]? '\''] % <sp>

A C<< <Blob> >> node represents a value of the Muldis D C<Blob> type, which
is a general purpose bit string.

The C<Blob> type is not a fundamental type of the Muldis D type system, but
rather is a subtype by constraint of the C<Structure> type, and all C<Blob>
values can be selected in terms of C<< <Structure> >> grammar nodes.
However, C<< <Blob> >> is the canonical grammar for all C<Blob> values.

This grammar supports writing C<Blob> literals in any of the numeric bases
{2,8,16} using conventional syntax.  The literal may optionally contain
underscore characters (C<_>), which exist just to help with visual
formatting.  A C<< <Blob> >> may optionally be split into 1..N segments
where each pair of consecutive segments is separated by dividing space.

Examples:

    \~+''

    \~+'0xA705E'

    \~+'0o523504376'

    \~+'0b00101110100010'

=head2 Text Literals

Grammar:

    <Text> ::=
        '\\~'? [<Text_seg> % <sp>]

    <Text_seg> ::=
        <ts_nonescaped> | <ts_escaped>

    <ts_nonescaped> ::=
        '\'' [<-['\\]> <-[']>*]? '\''

    <ts_escaped> ::=
        '\'' '\\' [<-['\\]> | <escaped_char>]* '\''

A C<< <Text> >> node represents a value of the Muldis D C<Text> type, which
is a general purpose character string.

The C<Text> type is not a fundamental type of the Muldis D type system, but
rather is a subtype by constraint of the C<Structure> type, and all C<Text>
values can be selected in terms of C<< <Structure> >> grammar nodes.
However, C<< <Text> >> is the canonical grammar for all C<Text> values.

Examples:

    'Ceres'

    'サンプル'

    ''

    '\This isn\at not escaped.\n'

    '\\c<0x263A>\c<65>'

    \~'Green'

=head1 COLLECTION SELECTOR EXPRESSIONS

Grammar:

    <collection_selector_expr> ::=
          <Array>
        | <Set>
        | <Bag>
        | <Structure>
        | <Tuple>
        | <Relation>
        | <Tuple_Bag>
        | <source_code_selector_expr>

A C<< <collection_selector_expr> >> is an C<< <expr> >> that denotes a
value literal specific to some system-defined data type that has its own
special Muldis D Plain Text selector syntax, and this literal syntax
explicitly does have child C<< <expr> >> nodes in the general case, as in
conventional terms it is for selecting values representing collections of
other values.

=head2 Array Selectors

I<TODO.>

=head2 Set Selectors

I<TODO.>

=head2 Bag Selectors

I<TODO.>

=head2 Structure Selectors

I<TODO.>

=head2 Tuple Selectors

I<TODO.>

=head2 Relation Selectors

I<TODO.>

=head2 Tuple-Bag Selectors

I<TODO.>

=head2 Selectors For Source Code Elements

Grammar:

    <source_code_selector_expr> ::=
          <SC_Identifier>
        | <SC_Heading>
        | <SC_Renaming>
        | ...

I<TODO.>

=head1 INVOCATION EXPRESSIONS

Grammar:

    <invocation_expr> ::=
          <constant_invo_expr>
        | <generic_func_invo_expr>
        | <fixed_func_invo_expr>
        | <foundation_invo_expr>

I<< TODO: DON'T FORGET TO INCLUDE THE COMMON CASE OF --> WHERE THE FUNCTION
OR (INTERNALLY RECURSIVE) CONSTANT IS DECLARED INLINE WITH ITS CALL! >>

=head2 Constant Invocation Expressions

Grammar:

    <constant_invo_expr> ::=
        ...

I<TODO.>

=head2 Generic Function Invocation Expressions

Grammar:

    <generic_func_invo_expr> ::=
        <generic_func_args> <sp> '-->' <sp> <generic_func_ref>

    <generic_func_ref> ::=
        <expr>

    <generic_func_args> ::=
        <expr>

I<TODO.>

A C<< <generic_func_ref> >> denotes a C<Reference> value naming a function;
it may be either a C<Reference> value literal or an inline-defined C<function>.

I<FORGET NOT THE OPTIONAL TRAILING :: IN FOO().>

=head2 Fixed Function Invocation Expressions

Grammar:

    <fixed_func_invo_expr> ::=
        ...

    <infix_func_invo_expr> ::=
        ...

    <infix_func_name_or_op_same> ::=
        <special_infix_op_same> | <regular_infix_func_name>

    <special_infix_op_same> ::=
        '='

I<TODO: Note, special_infix_op_same etc are subject to be renamed maybe.
Say that it is just syntactic sugar for a specific foundation_func_invo_expr
but we special-case it because we don't want "=" to change based on what
packages are in scope, same as "!" meta or "??!!" or ":=" etc don't change.
Note, this only affects '=' when called like an infix op syntactically,
same as with ! etc; calling it as -->"=" or "="() gets the reg func if exists.>

I<The grammar-recognized not/!x is just syntactic sugar for x??f!!t and will
parse into a ??!! node having source-code-meta indicating not/! was used;
the meta also distinguishes !(foo = bar) from foo != bar; the not/!
empathetically does NOT parse into a routine call, not even a foundation.
The grammar for Logical-Not Meta Operator Expressions is discussed with
Fixed Function Invocation Expressions since syntactically it modifies that;
but its result combines a generic function invo expr with a conditional expr.>

I<TODO.>

I<TODO: FORGET NOT THE ps5_nonquoted_symbolic_grouping.>

=head2 Foundation Invocation Expressions

Grammar:

    <foundation_invo_expr> ::=
        <foundation_const_invo_expr> | <foundation_func_invo_expr>

    <foundation_const_invo_expr> ::=
        '(' <sp> '-->^' <sp> <foundation_const_name> <sp> ')'

    <foundation_func_invo_expr> ::=
        <generic_func_args> <sp> '-->^' <sp> <foundation_func_name>

I<TODO.>

I<Because all non-core low-levels will be invoked via a generic core proxy
or three, the list of core routines SHOULD be spelled out in Plain_Text,
as changes to them WOULD change the Plain_Text version.>

=head1 CONDITIONAL EXPRESSIONS

Grammar:

    <conditional_expr> ::=
          <nonshort_if_else_expr>
        | <short_if_else_expr>
        | <nonshort_given_when_def_expr>
        | <short_given_when_def_expr>

=head2 Non-Short-Circuiting If-Else Expressions

I<TODO.>

=head2 Short-Circuiting If-Else Expressions

I<TODO.>

=head2 Non-Short-Circuiting Given-When-Default Expressions

I<TODO.>

=head2 Short-Circuiting Given-When-Default Expressions

I<TODO.>

=head1 LANGUAGE MNEMONICS

Muldis D Plain Text is designed to respect a variety of mnemonics that
bring it some self-similarity and an association between syntax and
semantics so that it is easier to read and write Muldis D code.  Some of
these mnemonics are more about self-similarity and others are more about
shared traits with other languages.

I<TODO.>

A C<::=> is I<what-binding> while a C<::?=> is I<why-binding>.

    : - key/asset separator in most pairwise collections
    ? - booleans or sets (and relations) or some predicate eg for existence
    + - numbers or bags (and tuple-bags)
    ~ - arrays (and text and blob)
    % - tuples or relations (and tuple-bags)
    @ - field names or headings (and chain-identifiers and renamings)
    \ - value literal or selector (or topic field accessor)
    & - subject-to-update parameter/etc or procedure
    ! - booleans or voidlikes
    ^ - raising something up - bootstrap on foundation, or attribute projection, or number to a power
    . - collection item accessor or existence test
    = - association of 2 things, either for comparison or binding or assignment

    [] - homogeneous ordered collection of element - arrays/statements/etc - ordinal+universal
    {} - homogeneous nonordered collection of member - bags/sets/dictionaries/etc - universal+ordinal
    () - heterogeneous aordered collection of field - structures/tuples - nominal+universal

When combining symbols to represent both collection type and element type,
show collection first as master and element next as subservient,
so eg ?% is relation, +% is tuple-bag while ~+ is blob.

=head1 NESTING PRECEDENCE RULES

I<TODO.  These are listed from tightest at the top to loosest at the bottom.>

    terms - base literals or delimited anything or special selector syntax,
        including inline func/type/etc decls, or foo::bar::etc or func/const foo()
    why-binding infix ::?=
    what-expr-binding-infix ::=
    generic universal routine call infix: args --> rtn or args -->^ rtn
    symbolic in/pre/postfix and ! meta-op (bareword)
    alpha in/pre/postfix and 'not' meta-op (bareword)
    conditional ternaries or n-aries: ??!! / if-then-else / ???!!! / given-when-default
    assignment infix := and assignment meta-op :=foo and proc foo()
    what-stmt-binding infix ::&=

=head1 STRATEGIES FOR PARSING

Muldis D Plain Text is designed to be easy to parse, where one can use a
multi-stage pipeline with simple rules at each step, and typically the work
of parsing can be done in a highly parallel fashion, where each part of the
code can be parsed properly with very little or no knowledge of what came
before or after it.

In particular, earlier stages of the pipeline can complete successfully
even in the face of syntax errors, as the latter would be caught in a later
pipeline stage where more meaningful error messages can be given.

For the purposes of this documentation section, we will assume that the
source code has already been processed from any binary or other formats
into a single character string token having a well-known
character repertoire that is compatible with Unicode.  This may have
involved scanning ahead for a C<< <language_name> >> or in particular a
C<< <script_name> >> directive should that have been needed to resolve ambiguity.

Note that it is assumed that all parsing stages following the above
assumption are completely lossless, and that any stages which conceptually
would lose information actually maintain all of it in (generally)
C<Plain_Text>-specific metadata so the original source string could be
reassembled from the parse form in all its details, including for example
the exact character escape sequences and whitespace used.  Also maintained
as useful for debugging is knowledge of what line numbers and character
positions within a line each token ranged over in the original source.

Note that it is assumed that every token indicated as being a I<character
string> would in likely practice be some other type whose payload is the
character string and it is tagged to say how the string was interpreted,
so that tokens can more easily be further processed in isolation, the work
to consider their wider context having already been done.

=head2 Pipeline Stage 1

Stage 1 in the parsing pipeline is to split off any leading C<< <shebang_line> >>
that might prefix the code.  The primary output of stage 1 is a single
character string token with the code itself, and any leading shebang is
metadata.  Further stages below only consider this primary as their input.

Grammar:

    <ps1> ::=
        ^ <shebang_line>? <ps2> $

=head2 Pipeline Stage 2

Broadly speaking, Muldis D Plain Text code is made up of 2 primary
grammatical contexts which are mutually disjoint and complementary; one of
these is anywhere outside all quoted strings, and its complement is
anywhere inside any quoted string; quoted strings don't overlap or nest, or
if they appear to, any inner ones are just regular string contents.

Stage 2 in the parsing pipeline is to split the single input
character string token on all transition points between those grammatical
contexts.  The output of stage 2 is an array of character string tokens
such that catenating them in order gives the input token.  Each output
token is either one of the delimiters by itself, or is the characters
between a delimiter pair, or is the characters between 2 delimited strings.
Alternately, the output of stage 2 is an array of parse nodes where each
node either represents a nonquoted context or a quoted context, the latter
bundling up what its delimiters were.

Grammar:

    <ps2> ::=
        <ps2_nonquoted> % <ps2_quoted>

    <ps2_nonquoted> ::=
        <-['"`]>*

    <ps2_quoted> ::=
        <ps2_single_quoted> | <ps2_double_quoted> | <ps2_backtick_quoted>

    <ps2_single_quoted> ::=
        '\'' <-[']>* '\''

    <ps2_double_quoted> ::=
        '"' <-["]>* '"'

    <ps2_backtick_quoted> ::=
        '`' <-[`]>* '`' 

=head3 Pipeline Stage 3

Stage 3 in the parsing pipeline is to take any tokens from stage 2
representing a nonquoted context, and for each one, split it into tokens by
character class, that is just on the transition between any 2 characters
not of the same one of the 5 character groups shown.  The output of stage 3
is an array of character string tokens such that each output token is
either the same as an input token or is a non-overlapping substring of one.
Alternately, each parse node from stage 2 representing a nonquoted context
has been replaced by an array of 1..N parse nodes, one per new substring.

Grammar:

    <ps3_nonquoted> ::=
          <alphanumeric_char>
        | <bracketing_char>
        | <symbolic_char>
        | <whitespace_char>

=head3 Pipeline Stage 4

Stage 4 in the parsing pipeline is to split any nonquoted context tokens
consisting of multiple C<< <bracketing_char> >> into multiple tokens such that
each such individual character becomes its own token.  The output of stage
4 is an array of character string tokens, or parse nodes, as per stage 3.

=head3 Pipeline Stage 5

Stage 5 in the parsing pipeline is to split any nonquoted context tokens
consisting of multiple C<< <symbolic_char> >> into multiple tokens where those
tokens contain characters well-known to C<Plain_Text> for special uses such
as meta-operator characters.  The output of stage 5 is an array of
character string tokens, or parse nodes, as per stage 3.

Grammar:

    <ps5_nonquoted_symbolic_grouping> ::=
          '!'
        | ','
        | '::?='
        | '::='
        | '::'
        | ':='
        | ':'
        | ';'
        | '\\'

Where any of the shown symbolic character sequences exist, each sequence
becomes its own token, and any runs of symbolics besides those each become
their own token also.  When looking for sequences, evaluation is
left-to-right and the longest match wins between multiple matches.

Generally speaking, the parsing of nonquoted context symbolic character
runs is complete following stage 5, and each remaining token is not likely
to be split again or be merged with other tokens.

=head3 Pipeline Stage 6

Stages 6 and later in the parsing pipeline focus more on combining adjacent
tokens or parse nodes of known kinds into subtrees of other node types,
that progressively add more semantic meaning to the parse tree, and the
syntax becomes metadata rather than something needed to execute the code.

Stage 6 in the parsing pipeline is to collect any runs of consecutive
tokens or parse nodes, where each represents either a backtick-quoted
string or nonquoted C<< <whitespace> >>, beneath a parse node
representing the run; this new node is logically treated as insignificant
(other than for its role in separating otherwise adjacent things)
dividing space, and becomes non-semantic metadata for its wider context.

=head3 Pipeline Stage 7

Stage 7 in the parsing pipeline is to collect any runs of consecutive
(apart from any invervening dividing space) quoted context tokens or parse
nodes of the same kind, specifically those delimited by either
single-quotes or double-quotes, beneath a parse node representing the run.
Such runs are logically a single contiguous quoted string (except possibly
for matters of escape sequences) but were split for readability.

=head3 Pipeline Stage 8

Stage 8 in the parsing pipeline is to take any tokens from stage 2
representing a single-quoted or double-quoted context, and for each one, if
it contains any character escape sequences, to replace those escape
sequences with the actual characters they represent.  Any C<'...'> or
C<\?'...'> or C<"..."> represent character data, either C<Text> or
C<SC_Comment> literals or quoted identifiers, and the valid formats for both
within the quoted contexts are identical.  Note that for a run, each
individual quoted context is treated in isolation, as some may be formatted
for escape sequences and some may not.  Also using single-quoted contexts
for some or all of their literals are the C<Blob> (C<\~+'...'>) or
C<Integer> or C<Ratio> or C<Float> (C<\+'...'> for all 3) and they have
their own interpretation formats different from those of character strings.

Grammar:

    <ps8_quoted_sans_delimiters> ::=
        <ps8_chars_nonescaped> | <ps8_chars_escaped>

    <ps8_chars_nonescaped> ::=
        [<-[\\]> .*]?

    <ps8_chars_escaped> ::=
        '\\' [<-[\\]> | <escaped_char>]*

Note that the definition of C<< <escaped_char> >> includes an escape sequence
each for a single-quote and a double-quote.

=head3 Pipeline Stage 9

Stage 9 in the parsing pipeline is to isolate any literals specific to
certain numeric types, which are a particular run of
C<< <alphanumeric_char> >> optionally with some C<< <symbolic_char> >>,
and further optionally split (when long) using dividing space.

Grammar:

    <ps9_numeric> ::=
        <ps9_nonquoted_numeric> | <ps9_quoted_numeric>

    <ps9_nonquoted_numeric> ::=
        <digit_char> <alphanumeric_char>* ['.' <alphanumeric_char>]?

    <ps9_quoted_numeric> ::=
        '\\+' <ps2_single_quoted> % <sp>

Note that the above actually allows invalid numeric literals, however
anything matching the above pattern will be a syntax error if it doesn't
otherwise match a stricter numeric definition.

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::See_Also> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright © 2002-2015, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
