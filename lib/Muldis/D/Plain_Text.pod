=pod

=encoding utf8

=head1 NAME

Muldis::D::Plain_Text -
How to format Muldis D Plain Text

=head1 VERSION

This document is Muldis::D::Plain_Text version 0.200.

=head1 PREFACE

This document is part of the Muldis D language specification, whose root
document is L<Muldis::D>; you should read that root document
before you read this one, which provides subservient details.

=head1 DESCRIPTION

This document defines the grammar that all non-hosted plain-text Muldis D
source code must conform to when it claims to be written in the
C<Muldis_D:Plain_Text:"http://muldis.com":"0.200"> (B<MDPT>) language.

This grammar is meant to be more illustrative to human readers than
executable, as is typical for standards documents; you wouldn't likely be
able to just hand if off to a parser-generator and expect it to work as is.
But it should still have enough information to derive an executable parser.

Note that the standard filename extension for files with such source code
is C<.mdpt>, though as per standard UNIX conventions, such Muldis D source
code files can in fact have any filename extension when there is other
context to interpret them with.  Filename extensions are more for the
benefit of the operating system or command shell or users than for a Muldis
D implementation, the latter just cares about the content of the file.

I<TODO: Comment about resolving package names to package source files;
the CompUnitRepo concept of Perl 6 would be a good precedent.
That will probably go somewhere else in the spec rather than here.>

A primary feature of Muldis D is a grammar that is small and simple while
still being quite rich and expressive.  As much as possible of the language
is defined in terms of ordinary packages, types and routines, in exactly
the same manner as users write their own code in.  Therefore, a Muldis D
grammar has no special knowledge of, or specific syntax for, the vast
majority of the language, and mainly just concerns itself with the minimal
syntactic framework for defining generic types and routines, generic
expressions and statements, and has special handling for just a small
number of data types or routines.  A key benefit of this is that it is very
easy for users to extend the language with new features that look and work
in the same way as the system-defined ones, and are drop-in substitutable
for them, rather than user-defined things being second-class citizens.  The
design also means it is much easier to implement the Muldis D language
itself, a large part of the langauge can be bootstrapped, and both parsers
and generators of Muldis D Plain Text can be simple and easy to make.

Muldis D Plain Text has a I<linear syntax>, and is designed to be easily
handled by a single-pass parser, or at least a single-pass lexer; all the
context that one needs to know for how to parse or lex any arbitrary
substring of code is provided by prior code, or any required lookahead is
just by a few characters in general.  Therefore, a parser/lexer can easily
work on a streaming input like a file-handle where you can't go back
earlier in the stream.  Often this means a parser/lexer can work with
little RAM.

Also the grammar is designed that any amount of whitespace can be added or
omitted next to most non-alphanumeric characters (which happen to be next
to alphanumeric tokens) without that affecting the meaning of the code at
all, except obviously for within character string literals.  And long
binary or character or numeric or identifier strings can be split into
arbitrary-size substrings, without affecting the meaning.  And many
elements are identified by name rather than ordinal position, so to some
degree the order they appear has no effect on the meaning.  So programmers
can easily format (separate, indent, linewrap, order) code how they like,
and making an automated code reformatter shouldn't be difficult.  Often,
named elements can also be omitted entirely for brevity, in which case the
parser would use context to supply default values for those elements.

=head1 GRAMMAR INTERPRETATION

I<TODO: Describe the grammar itself and how to interpret it.  Meanwhile,
keep in mind that the grammar is inspired by both EBNF and Perl 6 rules.>

=head1 GENERAL STRUCTURE

Each Muldis D Plain Text code file is either a I<module> or a I<depot>.  A
I<module> is a strictly read-only store featuring executable code, and if
it has any data, that data takes the form of constant declarations.  A
I<depot> is a possibly-updateable store featuring data, but also may have
code that could be updated at runtime using data-definition operations.

Modules directly correspond to the typical concept of a programming
language source code file, and are typically distributed bare, either as
C<.mdpt> plain text files (optionally executable or containing a shebang /
C<#!> line), or compiled to a machine code object file or cross-compiled to
source-code of some other language, for example Perl.

Modules also directly represent all the functionality that is either
traditionally built-in to a DBMS, or to the Muldis D language itself, or
that is provideable by third-party language extensions (this includes
Postgres' "extension" concept), or for functionality that is conceivably
low-level enough to likely be implemented at least partially external to
the Muldis D environment, such that some internals aren't user-visible.

Depots directly represent what is traditionally considered to be "the
database", mainly the actual user data which is read or manipulated at
runtime, but also user code (or "the schema") which is subject to be
updateable at runtime by data-definition operations.  A depot can
optionally be read-only, either all the time or to specific user mounts.

Both depots and modules can declare other modules as external dependencies
by which they are partially defined, but nothing can declare a depot as a
dependency.  As such, any data type definitions including parts of "the
schema" that both "the database" and one or more applications/modules using
it need to know about or directly see, should be declared in modules.

Depots typically exist in an implementation-defined storage format, such as
a set of binary files optimized for fast reads and updates by the DBMS,
which may possibly exist across multiple physical machines or just in RAM
or on disks, examples being a Postgres data directory or SQLite database
file or some key-value store.  However, depots can also exist as C<.mdpt>
plain text files, a format especially useful for interchange, and that
format specifically is what this document defines I<depot> grammar for.

I<TODO: Talk about how the "main program" is determined.>

I<TODO: Talk about how modules are versioned and depots are not.>

I<TODO: Talk about value literals or things in the context of host languages,
each of the former is a depot from the perspective of the grammar.>

The root grammar token for Muldis D Plain Text is C<MDPT>.

=head1 START

Grammar:

    <MDPT> ::=
        ^ <shebang_line>? <ws>?
            <language_name> <ws>
            [<module> | <depot>]
        <ws>? $

See the sections in this file named L<SHEBANG LINE>, L</LANGUAGE NAME>,
L</MODULE SPECIFICATION>, and L</DEPOT SPECIFICATION>, for more details.

=head1 SHEBANG LINE

Grammar:

    <shebang_line> ::=
        '#!' <shebang_directive> <ws_break>

    <shebang_directive> ::=
        ...

    <ws_break> ::=
        ...

A C<shebang_line>, if it exists, must be the first characters of the text
file, and consists of a magic number which expressed as ASCII or UTF-8 is
C<#!>, followed by a Unix-like interpreter directive or path to an
executable that can interpret Muldis D Plain Text files.  When a Muldis D
Plain Text file starts with a shebang line, it can be invoked directly as
if it were an executable on a Unix-like system.  The format of
C<shebang_directive> isn't defined in this document; see the appropriate
external Unix/etc documentation for that; however, the Muldis D Plain Text
file must have at least one line-breaking whitespace character of some kind
following it, which is how we know where the Muldis D code begins.

Examples:

    #!/usr/bin/env muldisdre

=head1 LANGUAGE NAME

Grammar:

    <language_name> ::=
        <ln_family_name>
        <unspace> ':' <ln_syntax_name>
        <unspace> ':' <ln_script_name>
        <unspace> ':' <ln_authority>
        <unspace> ':' <ln_version_number>

    <ln_family_name> ::=
        Muldis_D

    <ln_syntax_name> ::=
        Plain_Text

    <ln_script_name> ::=
        <ln_elem_str>

    <ln_authority> ::=
        <ln_elem_str>

    <ln_version_number> ::=
        <ln_elem_str>

    <ln_elem_str> ::=
        <nonquoted_ln_elem_str> | <quoted_ln_elem_str>

    <nonquoted_ln_elem_str> ::=
        <[ a..z A..Z _ ]> <[ a..z A..Z 0..9 _ ]>+

    <quoted_ln_elem_str> ::=
        '"'
            [<[\ ..~]-["]> | '\\"']+
        '"'

I<TODO: Simply make ln_elem_str the same format as an unqualified identifier.>

As per the VERSIONING section of L<Muldis::D>, code written in Muldis D
Plain Text, whether I<module> or I<depot>, must start by declaring the
fully-qualified Muldis D language name it is written in.

Examples:

    Muldis_D:Plain_Text:ASCII:"http://muldis.com":"0.200"

    Muldis_D:Plain_Text:"Unicode(6.2.0,UTF-8,canon)":"http://muldis.com":"0.200"

    Muldis_D:Plain_Text:ASCII:"http://example.com":"42"

=head1 SEE ALSO

Go to L<Muldis::D> for the majority of distribution-internal
references, and L<Muldis::D::SeeAlso> for the majority of
distribution-external references.

=head1 AUTHOR

Darren Duncan (C<darren@DarrenDuncan.net>)

=head1 LICENSE AND COPYRIGHT

This file is part of the formal specification of the Muldis D language.

Muldis D is Copyright Â© 2002-2015, Muldis Data Systems, Inc.

See the LICENSE AND COPYRIGHT of L<Muldis::D> for details.

=head1 TRADEMARK POLICY

The TRADEMARK POLICY in L<Muldis::D> applies to this file too.

=head1 ACKNOWLEDGEMENTS

The ACKNOWLEDGEMENTS in L<Muldis::D> apply to this file too.

=cut
